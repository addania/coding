{"componentChunkName":"component---src-templates-blog-post-js","path":"/Farewell_my_Good_Old_Best_Friends_For_Loops/","webpackCompilationHash":"106a3720786ad8b666b2","result":{"data":{"markdownRemark":{"html":"<p><img src=\"https://i.imgur.com/hw5qopR.jpg\" title=\"Photo by Helena Lopes from Pexels\"></p>\n<p>I will miss you! Trully. All the code adventures we have been through together. Those code advent loop incention craziness we did together :) I shall never forget you and we WILL meet again. But the new era of functional programming came and it is time to explore new possibilities of xmap, filter and reduce. They say it is more elegant, more sexy and more readable with map, filter and reduce. I would argue against it... but I also want to learn new concepts and hone my skills. So here we are, let's explore unknown together.</p>\n<p><strong>MAP</strong></p>\n<p>Map can be used on an array to iterate over EVERY SINGLE element of it. And here we go already, right from the start, drawback of map compared to for loops is that map cannot be broken out of, whereas in loops we can use simple <code>break;</code> to get out of it (just saying ;) )</p>\n<p>Nevertheless, map will need an array to loop over and then a function. This function will be performed over every single element of the array and it will return A NEW array where each element will be whatever the function returns</p>\n<p>Example:</p>\n<pre><code>const array1 = [1, 4, 9, 16];\n// pass a function to map\nconst map1 = array1.map(x => x * 2);\nconsole.log(map1);\n// expected output: Array [2, 8, 18, 32]\n</code></pre>\n<p>This code can be re-written to make it more clear:</p>\n<pre><code>const array1 = [1, 4, 9, 16];\nconst myFunction = (x) => {\n  const double = x*2;\n  return double\n}\nconst map1 = array1.map(myFunction);\nconsole.log(map1);\n// expected output: Array [2, 8, 18, 32]\n</code></pre>\n<p>Yet another way how to write this code:</p>\n<pre><code>const array1 = [1, 4, 9, 16];\n// pass a function to map\nconst map1 = array1.map(function(x){ return x * 2});\nconsole.log(map1);\n// expected output: Array [2, 8, 18, 32]\n</code></pre>\n<p>Compare especially <strong>EXPLICIT RETURN</strong>:</p>\n<pre><code>const map1 = array1.map(function(x){ return x * 2});\n</code></pre>\n<p>with this <strong>IMPLICIT RETURN</strong>:</p>\n<pre><code>const map1 = array1.map(x => x * 2);\n</code></pre>\n<p>Here we can see more clearly that map receives a FUNCTION as input. This function can be either declared somewhere else (second example) or it can be anonymous function directly in between of the .map brackets (first example).</p>\n<p>It is also more clear that the body of the function can be literally anything, any calculation, but what matters is what is the return of that function. Because the return of the function will define what the new element of the new array will be.</p>\n<p>Some code re-factoring from for loops to using map:</p>\n<p>old:</p>\n<pre><code>function formatImpressions(input) {\n  // Receives an array of objects as inputs and substitutes empty or null impressions with 0.\n  for (let row = 0; row &#x3C; input.length; row++) {\n    if (!input[row].Impressions) {\n      input[row].Impressions = 0;\n    }\n    if (!input[row].Clicks) {\n      input[row].Clicks = 0;\n    }\n  }\n  return input;\n}\n</code></pre>\n<p>new:</p>\n<pre><code>export const formatImpressions = input => {\n  // Receives an array of objects as inputs and substitutes empty or null impressions with 0.\n\n  const formatNumbers = row => {\n    if (!row.Impressions) {\n      row.Impressions = 0;\n    }\n    if (!row.Clicks) {\n      row.Clicks = 0;\n    }\n    return row;\n  };\n  const output = input.map(formatNumbers);\n  return output;\n};\n</code></pre>\n<p>old:</p>\n<pre><code>function extractDate(input) {\n  // Receives an array of objects as input and extracts date entries into a Date format. Outputs data as \"dataWithDate\".\n  const dataWithDate = [];\n  for (let row = 0; row &#x3C; input.length; row++) {\n    const entry = { ...input[row] };\n    const oldDate = input[row].Date;\n\n    const year = oldDate.slice(6, 10);\n    const month = oldDate.slice(3, 5);\n    const day = oldDate.slice(0, 2);\n    const newDate = year + \"-\" + month + \"-\" + day;\n    const dateFormatted = new Date(newDate);\n    entry.Date = dateFormatted;\n    dataWithDate.push(entry);\n  }\n  return dataWithDate;\n}\n</code></pre>\n<p>new:</p>\n<pre><code>export const extractDate = input => {\n  // Receives an array of objects as input and extracts date entries into a Date format. Outputs data as \"dataWithDate\".\n  const convertDate = row => {\n    const entry = { ...row };\n    const oldDate = row.Date;\n    const year = oldDate.slice(6, 10);\n    const month = oldDate.slice(3, 5);\n    const day = oldDate.slice(0, 2);\n    const newDate = year + \"-\" + month + \"-\" + day;\n    const dateFormatted = new Date(newDate);\n    entry.Date = dateFormatted;\n    return entry;\n  };\n  const dataWithDate = input.map(convertDate);\n  return dataWithDate;\n};\n</code></pre>\n<p>old:</p>\n<pre><code>import _ from \"lodash\";\nfunction getMetrics(inputData, inputColumns) {\n  // Receives an array of objects as inputData and array of unique keys as inputColumns.\n  // Outputs array of column names which holds numeric values.\n  const output = [];\n  for (let item = 0; item &#x3C; inputColumns.length; item++) {\n    const col = inputColumns[item];\n    if (_.isNumber(inputData[col])) {\n      output.push(col);\n    }\n  }\n  return output;\n}\n</code></pre>\n<p>new:</p>\n<pre><code>export const getMetrics = (inputData, inputColumns) => {\n  // Receives an array of objects as inputData and array of unique keys as inputColumns.\n  // Outputs array of column names which holds numeric values.\n  const output = inputColumns.filter(col => typeof inputData[col] === \"number\");\n  return output;\n};\n</code></pre>\n<p>old:</p>\n<pre><code>import _ from \"lodash\";\nfunction getDimensions(inputData, inputColumns) {\n  // Receives an array of objects as inputData and array of unique keys as inputColumns.\n  // Outputs array of column names which holds string values (excluding date formats).\n  const output = [];\n  for (let item = 0; item &#x3C; inputColumns.length; item++) {\n    const col = inputColumns[item];\n    if (_.isString(inputData[col])) {\n      output.push(col);\n    }\n  }\n  return output;\n}\n</code></pre>\n<p>new:</p>\n<pre><code>export const getDimensions = (inputData, inputColumns) => {\n  // Receives an array of objects as inputData and array of unique keys as inputColumns.\n  // Outputs array of column names which holds string values (excluding date formats).\n  const output = inputColumns.filter(col => typeof inputData[col] === \"string\");\n  return output;\n};\n</code></pre>\n<p>old:</p>\n<pre><code>const moment = require(\"moment\");\nfunction formatDate(input) {\n  // Receives an array of objects as input and formats date entries into a \"DD. MMM\" format. Outputs data as \"dataWithDate\".\n  const formattedDateArray = [];\n  for (let row = 0; row &#x3C; input.length; row++) {\n    const entry = { ...input[row] };\n    const oldDate = input[row].Date;\n    const dateFormatted = moment(oldDate, \"DD.MM.YYYY\").format(\"DD. MMM\");\n    entry.Date = dateFormatted;\n    formattedDateArray.push(entry);\n  }\n  return formattedDateArray;\n}\n</code></pre>\n<p>new</p>\n<pre><code>const moment = require(\"moment\");\nexport const formatDate = input => {\n  // Receives an array of objects as input and formats date entries into a \"DD. MMM\" format. Outputs data as \"dataWithDate\".\n\n  const convertDate = row => {\n    const entry = { ...row };\n    const oldDate = row.Date;\n    const dateFormatted = moment(oldDate, \"DD.MM.YYYY\").format(\"DD. MMM\");\n    entry.Date = dateFormatted;\n    return entry;\n  };\n  const formattedDateArray = input.map(convertDate);\n  return formattedDateArray;\n};\n</code></pre>\n<p><strong>FOR EACH</strong>\nFor each is very similar to map. It iterates through each item of and array and performs a function over it. BUT it DOES NOT returns a NEW array. The forEach() method doesn’t actually return anything (undefined). It simply calls a provided function on each element in your array. This callback is allowed to mutate the calling array.</p>\n<pre><code>const books = [\"The Expanse\", \"Lord Of The Rings\", \"Harry Potter\"];\nbooks.forEach(function(book, i){\n    console.log(book);\n});\n\n//output in console.log:\nThe Expanse\nVM761:2 Lord Of The Rings\nVM761:2 Harry Potter\n</code></pre>\n<p>Notice how books.forEach is NOT assignd to ANY const.</p>\n<p>We can use forEach also to create a new array, but we would need to create it MANUALLY</p>\n<pre><code>const items = ['item1', 'item2', 'item3'];\nconst copy = [];\nitems.forEach(function(item){\n  copy.push(item);\n});\n</code></pre>\n<p><strong>FILTER</strong></p>\n<p>Filter iterates over each element of an array and ONLY returns those elements, which fulfill a condition which is given within the function.</p>\n<pre><code>const words = ['react', 'javascript', 'html', 'css'];\nconst result = words.filter(word => word.length > 5);\n// result: [\"javascript\"]\n\nconst result2 = words.filter(word => word.length &#x3C; 5);\n// result2: ['html', 'css'];\n</code></pre>\n<p>Filter can be re-factored in a way that we declare a function:</p>\n<pre><code>const words = ['react', 'javascript', 'html', 'css'];\nconst isLonger = (word) => {\n  return word.length > 5;\n}\nconst result = words.filter(isLonger);\n// result: [\"javascript\"]\n</code></pre>\n<p><strong>REDUCE</strong></p>\n<p>Reduce also iterates over every single element of an array and it also has an accumulator which is calculating for example SUM of all items. Result of reduce can be a single number (it can also be an array,  but for basic use it will return one value).</p>\n<p>Reduce receives 2 parameters, one is a function which will be performed over each element and second (optional) parameter is the initial value from which we start calculating.</p>\n<p>Reduce returns a new value as a result of calculations</p>\n<pre><code>const array1 = [1, 2, 3, 4];\nconst reducer = (accumulator, currentValue) => accumulator + currentValue;\n// 1 + 2 + 3 + 4\nconst result = array1.reduce(reducer));\n// result: 10\n\n// 5 + 1 + 2 + 3 + 4\nconst result = array1.reduce(reducer, 5));\n// result: 15\n</code></pre>\n<p>old:</p>\n<pre><code>import _ from \"lodash\";\nfunction calculateAggregates(array) {\n  // Receives an array of data as input and outputs an array of data aggregated per date.\n  // First element of the output array is array of aggregated impressions.\n  // Second element of the output array is array of aggregated clicks.\n  // Third element of the output array is array of unique dates.\n  let groupByDate = _.groupBy(array, \"Date\");\n  let uniqueDates = _.keys(groupByDate);\n  let impressionsArray = [];\n  let clicksArray = [];\n\n  for (let dayEntry = 0; dayEntry &#x3C; uniqueDates.length; dayEntry++) {\n    let totalImpressions = 0;\n    let totalClicks = 0;\n\n    for (\n      let dataRow = 0;\n      dataRow &#x3C; groupByDate[uniqueDates[dayEntry]].length;\n      dataRow++\n    ) {\n      totalImpressions =\n        totalImpressions +\n        groupByDate[uniqueDates[dayEntry]][dataRow].Impressions;\n      totalClicks =\n        totalClicks + groupByDate[uniqueDates[dayEntry]][dataRow].Clicks;\n    }\n    impressionsArray.push(totalImpressions);\n    clicksArray.push(totalClicks);\n  }\n  return [impressionsArray, clicksArray, uniqueDates];\n}\n</code></pre>\n<p>new</p>\n<pre><code>import _ from \"lodash\";\n\nexport const calculateAggregates = array => {\n  // Receives an array of data as input and outputs an array of data aggregated per date.\n  // First element of the output array is array of aggregated impressions.\n  // Second element of the output array is array of aggregated clicks.\n  // Third element of the output array is array of unique dates.\n  const groupByDate = _.groupBy(array, \"Date\");\n  const uniqueDates = Object.keys(groupByDate);\n  const impressionsArray = uniqueDates.map(item => {\n    const sumImp = groupByDate[item].reduce((acc, obj) => {\n      return acc + obj.Impressions;\n    }, 0);\n    return sumImp;\n  });\n  const clicksArray = uniqueDates.map(item => {\n    const sumClick = groupByDate[item].reduce((acc, obj) => {\n      return acc + obj.Clicks;\n    }, 0);\n    return sumClick;\n  });\n  return [impressionsArray, clicksArray, uniqueDates];\n};\n</code></pre>\n<p>**FILTER AND MAP COMBO **\nPowerful way of combining filter and map to get for example a list of guys which are SINGLE :) :) :) very useful (muhahahahaaa)</p>\n<pre><code>const guys = [\n  {name: 'Danny', single: true},\n  {name: 'Calvin', single: true},\n  {name: 'Mike', single: true},\n  {name: 'Jeff', single: false}\n];\n\nconst isSingle = person => person.single;\nconst getName = person => person.name;\nconst preys = guys.filter(isSingle).map(getName);\nconsole.log(preys) // [\"Danny\", \"Calvin\", \"Mike\"]\n</code></pre>\n<p>Reference:</p>\n<p><a href=\"https://www.codereadability.com/coding-without-loops/\">https://www.codereadability.com/coding-without-loops/</a></p>\n<p><a href=\"https://kuanhsuh.github.io/JS-functional-programming.html\">https://kuanhsuh.github.io/JS-functional-programming.html</a></p>\n<p><img src=\"https://i.imgur.com/fIyDFmN.jpg\" title=\"Photo by Pixabay from Pexels\"></p>","frontmatter":{"title":"Farewell my Good Old Best Buddies For Loops"},"excerpt":"I will miss you! Trully. All the code adventures we have been through together. Those code advent loop incention craziness we did together…"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Farewell_my_Good_Old_Best_Friends_For_Loops/"}}}