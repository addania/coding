{"componentChunkName":"component---src-templates-blog-post-js","path":"/Best_Practices/","webpackCompilationHash":"440635981ec110297d24","result":{"data":{"markdownRemark":{"html":"<p><img src=\"https://i.imgur.com/gyWBniE.jpg\" title=\"Photo by Pixabay from Pexels\"></p>\n<p>I would like to compile here couple of tips for the best practices I stumbled upon during my intro to programming universe :) Will be funny to review those in couple of years from now :)</p>\n<blockquote>\n<p><strong>Use Prettier</strong></p>\n</blockquote>\n<p>Code should always be ... pretty :) and of course neatly formatted - really be picky here, have your code simply <code>AWESOME</code></p>\n<pre><code>https://create-react-app.dev/docs/setting-up-your-editor/#formatting-code-automatically\n</code></pre>\n<blockquote>\n<p><strong>Fix ESLint warnings</strong></p>\n</blockquote>\n<p>Always make sure you have fixed all the ESLint warnings!</p>\n<blockquote>\n<p><strong>Delete console.logs</strong></p>\n</blockquote>\n<p>It certainly does not look professional to leave unintended console.logs which were part of your development or testing</p>\n<blockquote>\n<p><strong>Delete all comments</strong></p>\n</blockquote>\n<p>Of course only those which are remnants of tests or unused code. Relevant comments should still be kept.</p>\n<blockquote>\n<p><strong>Never use let or var</strong></p>\n</blockquote>\n<p>In React especially we want to avoid mutating variables. Therefore we use <code>const</code> instead which cannot be re-assigned. We should always keep in mind not the re-assign values.</p>\n<blockquote>\n<p><strong>Don't use mutating functions</strong></p>\n</blockquote>\n<p>As above, in React we want to avoid any mutation. All functions which mutate should be avoided. Such are:</p>\n<pre><code>.push\n.delete\n</code></pre>\n<p>Use non-mutating functions such as:</p>\n<pre><code>.map\n.filter\n</code></pre>\n<blockquote>\n<p><strong>Favour native ES6 functions</strong></p>\n</blockquote>\n<p>If there is a ES6 native function available, use that one before you reach out for other libraries like <code>lodash</code> or <code>moment</code>.</p>\n<blockquote>\n<p><strong>Use pure functions</strong></p>\n</blockquote>\n<p>All functions should be pure - same inputs always yields same output, no side-effects and no mutations.</p>\n<blockquote>\n<p><strong>Use arrow functions</strong></p>\n</blockquote>\n<p>Do not declare functions with word <code>function</code></p>\n<pre><code>function sum(a, b) {\n return a+b\n}\n</code></pre>\n<p>Use latest ES6 arrow function syntax:</p>\n<pre><code>const sum = (a, b) => {\n return a+b\n}\n</code></pre>\n<blockquote>\n<p><strong>Use explicit return</strong></p>\n</blockquote>\n<p>Avoid using word <code>return</code> if possible</p>\n<p>Instead of:</p>\n<pre><code>const getDimensions = (inputData, inputColumns) => {\n  return inputColumns.filter(column => typeof inputData[column] === \"string\");\n}\n</code></pre>\n<p>it is better to write:</p>\n<pre><code>const getDimensions = (inputData, inputColumns) =>\n  inputColumns.filter(column => typeof inputData[column] === \"string\");\n</code></pre>\n<blockquote>\n<p><strong>Avoid creating unnecessary variables</strong></p>\n</blockquote>\n<p>Instead of:</p>\n<pre><code>const parseData = csvData => {\n  const jsonData = csvJSON(csvData);\n  const formattedImpressions = formatImpressions(jsonData);\n  const formattedDates = extractDate(formattedImpressions);\n  const sortedData = sortArray(formattedDates);\n  const tableColumns = getColumns(sortedData[0]);\n  const metricColumns = getMetrics(sortedData[0], tableColumns);\n  const dimensionColumns = getDimensions(sortedData[0], tableColumns);\n  const finalData = formatDate(sortedData);\n  return [finalData, metricColumns, dimensionColumns];\n}\n</code></pre>\n<p>it is preferred to use:</p>\n<pre><code>const parseData = csvData => {\n  const sortedData = sortArray(extractDate(formatMetrics(parseCsv(csvData))));\n  return {\n    sortedData: sortedData,\n    metrics: getMetrics(sortedData[0], getColumns(sortedData[0])),\n    dimensions: getDimensions(sortedData[0], getColumns(sortedData[0]))\n  };\n};\n</code></pre>\n<blockquote>\n<p><strong>Separate concern</strong></p>\n</blockquote>\n<p>This is really <code>THE topic</code>! Each element should only do one thing. Elements which logically go together should be kept close together. An element should not be concerned with anything that is not necessarily their business. Separate business logic from the presentation layer.</p>\n<blockquote>\n<p><strong>Add tests for all functions</strong></p>\n</blockquote>\n<p>Each function should be tested properly. Thorough test suit will improve software quality, make your life easier in long run and enable you to catch errors early. Especially before they go to production.</p>\n<blockquote>\n<p><strong>Return objects rather then arrays</strong></p>\n</blockquote>\n<p>If you need to output multiple values, do not use an array, use preferably an object where you specify what you are returning</p>\n<p>Instead of:</p>\n<pre><code>const parseData = csvData => {\n  ...\n  return [finalData, metricColumns, dimensionColumns];\n}\n</code></pre>\n<p>better practice is:</p>\n<pre><code>const parseData = csvData => {\n  ...\n  return {\n    sortedData: sortedData,\n    metrics: metrics,\n    dimensions: dimensions\n  };\n}\n</code></pre>\n<blockquote>\n<p><strong>Reduce lines of code</strong></p>\n</blockquote>\n<p>Always strive for efficiency - less lines of code, less reading, less maintenance</p>\n<blockquote>\n<p><strong>Do not define a function within a function</strong></p>\n</blockquote>\n<p>No function inception :) If you need to define sub-function, define it outside of an existing function (can still be in the same file)</p>\n<blockquote>\n<p><strong>Avoid repeating code</strong></p>\n</blockquote>\n<p>Abstract anything into a function or a const, that would need to be repeated multiple times in code. It will allow you then to adapt changes in one place, instead of say...30</p>\n<blockquote>\n<p><strong>Remove legacy</strong></p>\n</blockquote>\n<p>Check if all your functions, components, tests or dependencies are actually being used. It is often the case that we forget to remove a test after we have removed a function.</p>\n<blockquote>\n<p><strong>Do not use abbreviations</strong></p>\n</blockquote>\n<p>All names of variables, functions, components, etc. should be always full names, even if it is a common abbreviation</p>\n<ul>\n<li>n => number</li>\n<li>i => index</li>\n<li>e => event</li>\n<li>acc => accumulator</li>\n<li>min => minumum or minus</li>\n</ul>\n<blockquote>\n<p><strong>Use positive names</strong></p>\n</blockquote>\n<p>Avoid using negative names, because if you need to use them in negative conditions, we would have double negations. Which is unnecessary complication.</p>\n<p>Example:</p>\n<ul>\n<li>notAvailable</li>\n<li>nonUser</li>\n</ul>\n<p>Instead of:</p>\n<pre><code>if ( !notAvailable ) {}\n</code></pre>\n<p>we can use:</p>\n<pre><code>if ( available ) {}\n</code></pre>\n<blockquote>\n<p><strong>Do not use types in names</strong></p>\n</blockquote>\n<p>Since Typescript is used, it is not necessary to name variables with types:</p>\n<ul>\n<li>nameString</li>\n<li>ListComponent</li>\n<li>computeFunction</li>\n</ul>\n<p>Words like <code>string</code>, <code>component</code>, <code>function</code> are redundant</p>\n<blockquote>\n<p><strong>Use named exports</strong></p>\n</blockquote>\n<p>Avoid default exports: </p>\n<pre><code>export default App\n</code></pre>\n<p>Instead use named exports:</p>\n<pre><code>export const App = () => (...)\n</code></pre>\n<p>An interesting article about this topic is here:</p>\n<p><a href=\"https://humanwhocodes.com/blog/2019/01/stop-using-default-exports-javascript-module/\">https://humanwhocodes.com/blog/2019/01/stop-using-default-exports-javascript-module/</a></p>\n<blockquote>\n<p><strong>Keep relevant context</strong></p>\n</blockquote>\n<p>Sometimes modules which are imported from some other place are too general, like <code>refresh</code>. We still want to keep its context, that it is coming from api.</p>\n<p>Instead of:</p>\n<pre><code>import { refresh } from 'api'\n...\nrefresh()\n</code></pre>\n<p>it is better to use:</p>\n<pre><code>import * as api from 'api'\n...\napi.refresh()\n}\n</code></pre>\n<p>Same goes for React. We want to know which elements are imported from React directly:</p>\n<pre><code>import * as React from 'react'\n</code></pre>\n<blockquote>\n<p><strong>Use atomic commits</strong></p>\n</blockquote>\n<p>Each commit should only consist of one change. Therefore avoid needing word <code>and</code> in the commit message. Always think about what is the minimum viable commit - smallest useful change.</p>\n<blockquote>\n<p><strong>Use commits to tell stories about the code</strong></p>\n</blockquote>\n<p>Good commit messages are very helpful to future you or to other developers to understand code changes and reason behind those changes. Good commit messages should always convey <code>INTENT</code>.</p>\n<p>Good commit message consists of:</p>\n<p>1// Commit title - a short one-liner</p>\n<p>2// At least one line break - this line break then allows to neatly list all commit titles with:</p>\n<pre><code>git log --pretty=oneline\n</code></pre>\n<p>3// Commit body - longer description of what the change does and an explanation why the change was done</p>\n<p>4// Contex - outline context or alternatives you considered</p>\n<p>Commit messages can contain link to bug tracking system or link to blog posts which explain the problem</p>\n<blockquote>\n<p><strong>Rename or move, then commit</strong></p>\n</blockquote>\n<p>Good practice is to first rename or move file, then commit (without any further changes to the file)! Only after the commit you should do more changes to the file. Reason is, that if you rename or move file AND make changes to it, in the change history it will be shown as if entire file was removed and new one was added. You will not be able to track and compare changes within the file.</p>\n<pre><code>git mv oldfile newfile\ngit commit -m \"moved oldfile to newfile\"\n</code></pre>\n<blockquote>\n<p><strong>Review your commit history</strong> </p>\n</blockquote>\n<p>You should review the development history so that you can tell meaningful stories from it, rather than having a scatterplot of all commits. To remove, reorder, edit, merge and split commits use:</p>\n<pre><code>git rebase --interactive\n</code></pre>\n<blockquote>\n<p><strong>Deconstruct all props</strong></p>\n</blockquote>\n<p>Do not simply use <code>(props)</code></p>\n<p>Instead of:</p>\n<pre><code>export const Subheader = (props) => {}\n</code></pre>\n<p>deconstruct all props:</p>\n<pre><code>export const Subheader = ({ text, color, dimensions }) => {}\n</code></pre>\n<blockquote>\n<p><strong>Object keys should be camelCased</strong></p>\n</blockquote>\n<p>Instead of:</p>\n<pre><code>const data={\n  Date: \"2020-02-20\",\n  Impressions: 152369\n}\n</code></pre>\n<p>we should implement camelCase:</p>\n<pre><code>const data={\n  date: \"2020-02-20\",\n  impressions: 152369\n}\n</code></pre>\n<blockquote>\n<p><strong>Functions should not have React dependency</strong></p>\n</blockquote>\n<p>Basically use a component when we need to display HTML. Use functions without React dependency</p>\n<blockquote>\n<p><strong>Use plural name if you generate more items</strong></p>\n</blockquote>\n<p>If you have a component within which you map through a list and then generate multiple items, then name of the component should be plural.</p>\n<p>Example: Filter => Filters</p>\n<blockquote>\n<p><strong>Avoid using meaningless text in links</strong></p>\n</blockquote>\n<p>For example <code>in this article</code> or <code>here</code></p>\n<p><img src=\"https://i.imgur.com/XREQjDp.jpg\" title=\"Photo by Jeswin Thomas from Pexels\"></p>","frontmatter":{"title":"Best Practices"},"excerpt":"I would like to compile here couple of tips for the best practices I stumbled upon during my intro to programming universe :) Will be funny…"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Best_Practices/"}}}