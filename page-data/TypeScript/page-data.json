{"componentChunkName":"component---src-templates-blog-post-js","path":"/TypeScript/","result":{"data":{"markdownRemark":{"html":"<p><img src=\"https://i.imgur.com/n6YTT3v.jpg\" title=\"Photo by Matej from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Matej from Pexels</em></p></p>\n<h2>Intro</h2>\n<p>This article is basically my notes following an amazing <a href=\"https://www.udemy.com/course/understanding-typescript/\">Typescript course</a> by Maximilian Schwarzm√ºller and <a href=\"https://skillerwhale.com/\">SkillerWhale</a> training notes which I would recommend to everyone who wants to learn Typescript.</p>\n<blockquote>\n<p>Typescript is a <code>superset</code> to Javascript which means it is a programming languages which builds on top of Javascript. It adds new features and advantages to Javascript. It allows to write cleaner, less error-prone and more powerful code.</p>\n</blockquote>\n<blockquote>\n<p>Big disadvantage of Typescript is that it cannot be executed by Javascript environments like a browser. But good news is that Typescript is also a tool - it is also a <code>compiler</code> which we can run on our Typescript files and convert them to vanilla Javascript. Typescript brings new features which are then compiled to vanilla Javascript <code>workarounds</code>. Such features might be easier to write in Typescript (or using nicer syntax) while it would be an aweful lot of complex code in Javascript.</p>\n</blockquote>\n<blockquote>\n<p>Most importantly Typescript enables defining and using <code>types</code>, which forces us to be more explicit how our code works, it catches unexpected and unnecessary errors early. It also allows to use next-generation Javascript features which can be then compiled to be used on older browsers. It also adds non-Javascript features like <code>Interfaces</code> and <code>Generics</code> which cannot be comiled to JS (but they only help during development, they actually don't need to be compiled to vanilla JS). It adds meta-programming features like <code>Decorators</code>.</p>\n</blockquote>\n<blockquote>\n<p>To install Typscript you need to have <code>node.js</code> installed:</p>\n</blockquote>\n<pre><code>nodejs.org/en/\n</code></pre>\n<blockquote>\n<p>Node.js will also install NPM tool (Node Package Manager) which will allow us to install Typescript globally with <code>npm install</code> command</p>\n</blockquote>\n<blockquote>\n<p>To install Typescript:</p>\n</blockquote>\n<pre><code>npm install -g typescript\n</code></pre>\n<blockquote>\n<p>Maybe you need to add <code>sudo</code> in front of it:</p>\n</blockquote>\n<pre><code>sudo npm install -g typescript\n</code></pre>\n<blockquote>\n<p>Typescript file has <code>.ts</code> extension, for example:</p>\n</blockquote>\n<pre><code>app.ts\n</code></pre>\n<blockquote>\n<p>To envoke TS compiler we will use command <code>tsc</code> and then file name which we want to compile:</p>\n</blockquote>\n<pre><code>tsc app.ts\n</code></pre>\n<h2>Setting up Typescript project</h2>\n<p><img src=\"https://i.imgur.com/2QEDSKd.jpg?1\" title=\"Photo by Markus Spiske from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Markus Spiske from Pexels</em></p></p>\n<blockquote>\n<p>We will start creating an html file with following content:</p>\n</blockquote>\n<pre><code class=\"language-es6\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    &#x3C;title>Typescript Course&#x3C;/title>\n    &#x3C;script src=\"app.js\"  defer>&#x3C;/script>\n  &#x3C;/head>\n  &#x3C;body>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<blockquote>\n<p>Especially important is the script tag which will envoke our <code>app.js</code> file and will execute it:</p>\n</blockquote>\n<pre><code>&#x3C;script src=\"app.js\"  defer>&#x3C;/script>\n</code></pre>\n<blockquote>\n<p>Then in the same folder add <code>app.ts</code> file</p>\n</blockquote>\n<pre><code>touch app.ts\n</code></pre>\n<blockquote>\n<p>Add some <code>console.log</code> in there:</p>\n</blockquote>\n<pre><code>console.log(\"Monsters for the win!\")\n</code></pre>\n<blockquote>\n<p>Now let's try to compile our <code>.ts</code> file and see if we can console it in browser:</p>\n</blockquote>\n<pre><code>tsc app.ts\n</code></pre>\n<blockquote>\n<p>New file will be produced: <code>app.js</code></p>\n</blockquote>\n<blockquote>\n<p>Now open the <code>index.html</code> in your broswer and <code>CTRL + i</code> to see the console. You should see the message you consoled.</p>\n</blockquote>\n<blockquote>\n<p>Problem is however, for now we will need to always save code, compile it, and manually refresh the browser. But we can automate the browser refresh by installing a tool.</p>\n</blockquote>\n<blockquote>\n<p>Go to your main project folder and initialize npm with <code>npm init</code>. It will create the <code>package.json</code> file. Hit enter for each question it asks you</p>\n</blockquote>\n<pre><code>npm init\n</code></pre>\n<blockquote>\n<p>Then we will install a <code>lite-server</code> package:</p>\n</blockquote>\n<pre><code>npm install --save-dev lite-server\n</code></pre>\n<blockquote>\n<p>Then go to <code>package.json</code> and add a <code>start</code> script after the <code>test</code> script (make sure you separate them with comma):</p>\n</blockquote>\n<pre><code>\"test\": \"echo \\\"Error: no test specified\\\" &#x26;&#x26; exit 1\",\n\"start\": \"lite-server\"\n</code></pre>\n<blockquote>\n<p>Above means that if I type in console <code>npm start</code> I will start a <code>lite server</code> which will serve <code>index.html</code> next to <code>package.json</code> at url:</p>\n</blockquote>\n<pre><code>http://localhost:3000\n</code></pre>\n<blockquote>\n<p>This will automatically reload the page if a file changes in our folder. So for example if I open <code>app.ts</code>, change the message, CTRL+S to save changes and then <code>tsc app.ts</code> in terminal, then my browser page will automatically reload to reflect the changes.</p>\n</blockquote>\n<h2>Core types</h2>\n<p><img src=\"https://i.imgur.com/BBgWcbe.jpg\" title=\"Photo by Ludvig Hedenborg from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Ludvig Hedenborg from Pexels</em></p></p>\n<p>Core types are data types provided by Typescript/Javascript (but they are not exclusive, we can define our own).</p>\n<p>Core types are:</p>\n<ul>\n<li><strong>number</strong> - there is only one number type, there is no difference between integers or floats (8, 8.6, -10)</li>\n<li><strong>string</strong> - text (\"monster\") - which can be denoted by double or single quotes or backticks:\",' or `</li>\n<li><strong>boolean</strong> - true or false</li>\n</ul>\n<blockquote>\n<p>Defining type in the code is done with a colon and word <code>number</code>, <code>string</code> or <code>boolean</code> etc:</p>\n</blockquote>\n<pre><code>const add = (n1: number, n2: number) => (n1 + n2);\n</code></pre>\n<blockquote>\n<p>If I passed string to the above function, I will get a compilation error.</p>\n</blockquote>\n<pre><code>add('1', 2)\n</code></pre>\n<blockquote>\n<p>Error will be seen when I compile the code with:</p>\n</blockquote>\n<pre><code>tsc app.ts\n</code></pre>\n<blockquote>\n<p>Error will look like this:</p>\n</blockquote>\n<pre><code>error TS2345: Argument of type '\"1\"' is not assignable to parameter of type 'number'.\n</code></pre>\n<blockquote>\n<p>I will only get error during <code>compilation</code> (during development), not during runtime (because browsers do not have built-in Typescript support). It does not change Javascript to work differently. But it adds extra sanity check!</p>\n</blockquote>\n<blockquote>\n<p>Important is also to notice that even though compilation threw an error, by default the file was <code>still</code> compiled and served (but we can setup a blocker for that later).</p>\n</blockquote>\n<blockquote>\n<p>Javascript uses <code>dynamic types</code> which are resolved at runtime. Typescript uses <code>static types</code> which are set during development, allowing us to catch errors early (before they go to production).</p>\n</blockquote>\n<blockquote>\n<p><code>Type inference</code> means that Typescript tries to detect type of data.</p>\n</blockquote>\n<blockquote>\n<p>If you initialize a <code>constant</code> with number <code>5</code>, it will be of inferred type 5 when you hover over the number1 in <code>.ts</code> file. It is because as for constants you cannot re-assign their value:</p>\n</blockquote>\n<pre><code>const number1=5;\n// if you hover over number1 you will see: const number1: 5\n</code></pre>\n<blockquote>\n<p>If you initialize a <code>variable</code> with number 5, it will be of inferred type <code>number</code> (as for variables you can re-assign their value):</p>\n</blockquote>\n<pre><code>let number2=5;\nlet number2: number\n</code></pre>\n<blockquote>\n<p>We can actually write our own type in both declarations:</p>\n</blockquote>\n<pre><code>const number1: number = 5;\nlet number2: number = 5;\n</code></pre>\n<blockquote>\n<p>But it is redundant and not encouraged (not best practice), as Typescript can infer the data type itself from how I initialize the constant or variable.</p>\n</blockquote>\n<blockquote>\n<p>Best practice would be to define a type <code>if you do not assign value but only initialize a variable</code>:</p>\n</blockquote>\n<pre><code>let x;\n</code></pre>\n<blockquote>\n<p>Then it is actually encouraged to define type:</p>\n</blockquote>\n<pre><code>let x: number;\n</code></pre>\n<h2>Object types</h2>\n<p><img src=\"https://i.imgur.com/dGwZPCQ.jpg\" title=\"Photo from mocah.org\"><p style=\"font-size: 12px; text-align: right\"><em>Photo from mocah.org</em></p></p>\n<blockquote>\n<p>Typescript automatically infers object keys and complains when we access property which does not exist:</p>\n</blockquote>\n<pre><code>const hero = {\n    name: \"Addania\",\n    title: \"The Horde Slayer\"\n}\nconsole.log(hero.nickname);\n</code></pre>\n<blockquote>\n<p>We can explicitly define that hero will be an <code>object type</code>:</p>\n</blockquote>\n<pre><code>const hero: {} = {\n    name: \"Addania\",\n    title: \"The Horde Slayer\"\n}\n</code></pre>\n<p>or like this:</p>\n<pre><code>const hero: object = {\n    name: \"Addania\",\n    title: \"The Horde Slayer\"\n}\n</code></pre>\n<blockquote>\n<p>Above only says to Typescript that hero will be an object. If we want to be explicit of which type is which key, we can do it like this:</p>\n</blockquote>\n<pre><code>const hero: {\n    name: string;\n    title: string;\n} = {\n    name: \"Addania\",\n    title: \"The Horde Slayer\"\n}\n</code></pre>\n<blockquote>\n<p>Notice the semi-colon <code>;</code> between curly brackets. Semicolon is a Typescript way to define types in an object. Javascript way of giving multiple keys in an object is using comma.</p>\n</blockquote>\n<blockquote>\n<p>Anyway, it is not recommended to explicitly define types if Typescript can infer them.</p>\n</blockquote>\n<blockquote>\n<p>We can also add types for nested objects. Example object:</p>\n</blockquote>\n<pre><code>const hero = {\n  name: \"Addania\",\n  title: \"The Horde Slayer\",\n  mounts: [\"Spectral Steed\", \"Blue Proto-Drake\"],\n  skills: {\n    enchanting: 360,\n    jewelcrafting: 320\n  }\n}\n</code></pre>\n<blockquote>\n<p>This is how types would be defined:</p>\n</blockquote>\n<pre><code>const hero:{\n    name: string;\n    title: string;\n    mounts: string[];\n    skills: {\n        enchanting: number;\n        jewelcrafting: number;\n    };\n}\n = {\n  name: \"Addania\",\n  title: \"The Horde Slayer\",\n  mounts: [\"Spectral Steed\", \"Blue Proto-Drake\"],\n  skills: {\n    enchanting: 360,\n    jewelcrafting: 320\n  }\n}\n</code></pre>\n<h2>More about object type</h2>\n<p><strong>Object Types</strong></p>\n<blockquote>\n<p>TypeScript has a general object type that corresponds to JavaScript's object type. This type includes all non-primitive values: arrays, dates, sets, maps, functions (callable objects), as well as objects in the narrower sense (things that can be written out as an object literal).</p>\n</blockquote>\n<blockquote>\n<p>Since the object type is so general, you are unlikely to ever want to use it in practice. In this session you will learn how to write and work with types for objects in the narrower sense.</p>\n</blockquote>\n<blockquote>\n<p>In the simplest case, object types are written out exactly like object literals, but instead of assigning values to properties, you assign types:</p>\n</blockquote>\n<pre><code>type Message = { text: string, urgent: boolean }\nlet welcome: Message = { text: 'Welcome!', urgent: false }\n</code></pre>\n<blockquote>\n<p>As with all types, you can also use object types directly, without first assigning them to a type alias:</p>\n</blockquote>\n<pre><code>let welcome: { text: string, urgent: boolean } = { text: 'Welcome!', urgent: false }\n</code></pre>\n<blockquote>\n<p>You can also leave out any explicit type annotations and let TypeScript infer the object type for you:</p>\n</blockquote>\n<pre><code>// The inferred type of welcome is { text: string, urgent: boolean }\nlet welcome = { text: 'Welcome!', urgent: false }\n</code></pre>\n<blockquote>\n<p>But it is good practice to use explicit type annotations everywhere. And with objects, more than with primitives, the inferred type will often not be what you want. For example, if you want your object to have optional or read-only properties (discussed later in this session), you will have to tell the compiler with an explicit annotation.</p>\n</blockquote>\n<blockquote>\n<p>An object type can include properties of any other type. It can also have many nested levels, in a similar way to defining a complex object literal. For example:</p>\n</blockquote>\n<pre><code>type Message = { text: string, urgent: boolean }\ntype MessageSender = {\n messages: Message[],\n scheduledFor: Date,\n format: 'email'|'inapp'|'sms',\n from: {\n   email: string,\n   name: {\n     first: string,\n     last: string,\n   },\n },\n}\nlet messages: Message[] = [ /** ... */ ]\nlet messageSender: MessageSender = {\n messages: messages,\n scheduledFor: new Date(2018, 5, 21),\n format: 'email',\n from: {\n   email: 'orcaniser@skillerwhale.com',\n   name: { first: 'Eelton', last: 'John' },\n },\n}\n</code></pre>\n<p><strong>Type Compatibility (Structural Typing)</strong></p>\n<blockquote>\n<p>In TypeScript, one object type A is compatible with another object type B when every property in B has a matching property in A. A matching property is a property with the same key and a compatible type - where compatibility is checked recursively in the case of properties that are themselves objects.</p>\n</blockquote>\n<blockquote>\n<p>Object type A is compatible with object type B even if A has additional properties not present in B (but then B will not be compatible with A).</p>\n</blockquote>\n<pre><code>type Message = { text: string, urgent: boolean }\ntype Todo = { text: string, urgent: true | false }\ntype DetailedMessage = { text: string, urgent: boolean, detail: string }\n</code></pre>\n<blockquote>\n<p>Here, the types Message and Todo are both compatible with each other. (Note the types boolean and true | false are mutually compatible, since the sets of values described by these types are identical.)</p>\n</blockquote>\n<blockquote>\n<p>The type DetailedMessage is also compatible with both Message and Todo, but Message and Todo are not compatible with DetailedMessage, because they are missing the additional detail: string property.</p>\n</blockquote>\n<blockquote>\n<p>Whenever a value of one type is required by the compiler, a value of a compatible type is allowed. For example, if you have a function that requires a parameter of type Message, you can pass it an argument of type Todo or DetailedMessage without raising an error:</p>\n</blockquote>\n<pre><code>function sendMessage (message: Message) {\n // do some messaging\n}\nlet message: Message = {\n text: 'Your order has been shipped.',\n urgent: false\n}\nlet todo: Todo = {\n text: 'Ship order 00046728',\n urgent: true\n}\nlet detailedMessage: DetailedMessage = {\n text: 'You have a new message.',\n urgent: false,\n detail: 'Your order is delayed due to ...'\n}\nsendMessage(message) // ok because message is a Message\nsendMessage(todo) // ok because Todo is compatible with Message\nsendMessage(reminder) // ok because DetailedMessage is compatible with Message\n</code></pre>\n<blockquote>\n<p>This is because TypeScript implements a structural typing system, as opposed to a nominal typing system.</p>\n</blockquote>\n<blockquote>\n<p>In a structural typing system, one type is considered compatible with another when it has the same (or compatible) members. Compatibility in nominal typing systems is stricter: whenever a value of one type is required, only a value of that named type - or of a subtype explicitly declared as such - is allowed.</p>\n</blockquote>\n<blockquote>\n<p>Other example:</p>\n</blockquote>\n<pre><code>type Message = { text: string; urgent: boolean };\ntype Text = { text: string };\nconst welcome: Message = { text: \"xxx\", urgent: true };\nconst text: Text = { text: \"xxx\" };\nconst printing = (a: Text) => {\n console.log(a.text);\n};\nprinting(text);\nprinting(welcome); // Message is compatible with Text\nconst printing2 = (a: Message) => {\n console.log(a.text);\n};\nprinting2(text); // text is not compatible with Message\nprinting2(welcome);\n</code></pre>\n<p><strong>Optional Properties</strong></p>\n<blockquote>\n<p>Sometimes you will want to limit the properties that your objects can have, but without insisting that they have all of these properties all of the time. In principle, you could do this by typing some properties as unions with undefined.</p>\n</blockquote>\n<pre><code>type Message = { text: string, urgent: boolean, detail: string | undefined }\nlet messageWithoutDetail: Message = {\n text: 'Your order has been shipped.',\n urgent: false,\n detail: undefined\n}\nlet messageWithDetail: Message = {\n text: 'You have a new message.',\n urgent: false,\n detail: 'Your order is delayed due to ...'\n}\n</code></pre>\n<blockquote>\n<p>This approach can be tedious, however, especially if you want to have several potentially undefined properties. In order to satisfy the TypeScript compiler, you have to explicitly give your messageWithoutDetail object a detail property with a value of undefined. But in JavaScript, it would be possible to access a detail property on this object (which would have the value undefined) without explicitly setting it.</p>\n</blockquote>\n<blockquote>\n<p>The explicit detail assignment is needed by the compiler, but is not needed by the JavaScript run-time engine.</p>\n</blockquote>\n<blockquote>\n<p>To simplify your code in these cases, TypeScript includes a ? modifier to indicate that a property is optional. This implicitly makes the type of that property a union with undefined, but also allows you to leave the property out altogether when defining objects of the relevant type.</p>\n</blockquote>\n<pre><code>type Message = { text: string, urgent: boolean, detail?: string }\nlet messageWithoutDetail: Message = {\n text: 'Your order has been shipped.',\n urgent: false\n}\nlet messageWithDetail: Message = {\n text: 'You have a new message.',\n urgent: false,\n detail: 'Your order is delayed due to ...'\n}\n</code></pre>\n<blockquote>\n<p>Other examples of optional properties:</p>\n</blockquote>\n<pre><code>type Flat = { location: string; area: number; price: number | undefined };\ntype Flat2 = { location: string; area: number; price?: number };\n\nconst newHome: Flat = { location: \"Prag\", area: 60 }; // error, price needs to be provided, but can have value of undefined\nconst newHome2: Flat = { location: \"Prag\", area: 60, price: undefined }; // ok\nconst newHome3: Flat = { location: \"Prag\", area: 60, price: 700 }; // ok\nconst homeSweetHome: Flat2 = { location: \"Prag\", area: 60 }; // ok, because price is optional and does not need to be defined\nconst homeSweetHome2: Flat2 = { location: \"Prag\", area: 60, price: 700 }; // ok\nconst homeSweetHome3: Flat2 = { location: \"Prag\", area: 60, price: undefined }; // ok, because price can be undefined\n</code></pre>\n<blockquote>\n<p>You can use control flow and type narrowing to handle optional properties, by first checking whether the property is undefined.</p>\n</blockquote>\n<pre><code>let message: Message = { /* ... */ }\nlet details: string[] = []\n// Error: Argument of type 'string | undefined' is not assignable to parameter of type 'string'\ndetails.push(message.details)\nif (message.detail !== undefined) {\n // OK: message.details has been narrowed to type 'string'\n details.push(message.detail)\n}\n</code></pre>\n<blockquote>\n<p>Another example:</p>\n</blockquote>\n<pre><code>type Message2 = { text: string; urgent: boolean; detail?: string };\nlet details: string[] = [];\nconst message: Message2 = { text: \"Hi\", urgent: false, detail: \"blue\" };\ndetails.push(message.detail); // error because detail can be undefined and in details variable we want to only have strings\n</code></pre>\n<p><strong>Excess Property Checks</strong></p>\n<blockquote>\n<p>TypeScript's structural typing system, where types are considered compatible even if they have additional properties, gives you a lot of flexibility when working with object types.\nOptional properties take advantage of a flexible feature of JavaScript - that undefined properties can always be accessed at run-time (and have the value undefined) - to save you from writing extra lines of code just to satisfy the compiler.</p>\n</blockquote>\n<blockquote>\n<p>Combining these two features of TypeScript, however, creates a hole in the compiler that bugs could potentially fall through. Consider the following code:</p>\n</blockquote>\n<pre><code>type Message = { text: string, urgent: boolean, detail?: string }\nconst message: Message = {\n text: 'Welcome!',\n urgent: false,\n deetail: 'Your account has been created.'\n}\n</code></pre>\n<blockquote>\n<p>Here the message variable has a property called deetail instead of a property called detail. This is almost certainly a typo, and a bug in the code.</p>\n</blockquote>\n<blockquote>\n<p>Another example:</p>\n</blockquote>\n<pre><code>type Message3 = { text: string; urgent: boolean; detail?: string };\nconst message3 = {\n text: \"Welcome!\",\n urgent: false,\n deetail: \"Your account has been created.\",\n};\nconst printing3 = (a: Message3) => {\n console.log(a.text);\n};\nprinting3(message3); //compiler considers this as ok, but it is a hole in the system! message3 is compatible with Message3\n</code></pre>\n<blockquote>\n<p>But given the rules of structural typing and optional properties alone, this would not be an error: an object does not have to have the optional detail property to count as a Message, and it can have any additional properties - deetail or anything else - and still be compatible with the Message type.</p>\n</blockquote>\n<blockquote>\n<p>In order to catch bugs like these, TypeScript imposes excess property checks in certain situations on top of its core structural typing system. Where excess property checks apply, one object type will be considered compatible with another when it has all the same properties as the other type and no additional properties.</p>\n</blockquote>\n<blockquote>\n<p>There are two situations where TypeScript uses excess property checks:\nWhen an object literal is assigned to a variable with an explicit type (as in the example above with Message).\nWhen an object literal is passed directly as a function argument (as in the example below).</p>\n</blockquote>\n<blockquote>\n<p>Because of this, the buggy code above in fact does generate an error, as does the similarly buggy code in the function call below:</p>\n</blockquote>\n<pre><code>type Message = { text: string, urgent: boolean, detail?: string }\nfunction sendMessage (message: Message) {\n // do message sending\n}\n\nsendMessage({\n text: 'Welcome!',\n urgent: false,\n // Error: Object literal may only specify known properties, and 'deetail'\n // does not exist in type 'Message'. Did you mean to write 'detail'?\n deetail: 'Your account has been created.'\n})\n</code></pre>\n<blockquote>\n<p>Recap on when excess properties apply:</p>\n</blockquote>\n<blockquote>\n<p>Excess properties check will apply and detect our error if we explicitly assign a type:</p>\n</blockquote>\n<pre><code>type Message4 = { text: string; urgent: boolean; detail?: string };\nconst message4: Message4 = {\n text: \"Welcome!\",\n urgent: false,\n deetail: \"Your account has been created.\", // we will get an error here now! excess properties are not allowed\n};\nconst printing4 = (a: Message3) => {\n console.log(a.text);\n};\nprinting4(message4);\n</code></pre>\n<blockquote>\n<p>Another way how excess properties check will apply and detect our error if we pass object literal directly to our function!</p>\n</blockquote>\n<pre><code>type Message5 = { text: string; urgent: boolean; detail?: string };\nconst printing5 = (a: Message5) => {\n console.log(a.text);\n};\n\nprinting5({\n text: \"Welcome!\",\n urgent: false,\n deetail: \"Your account has been created.\", // we will get an error here now! excess properties are not allowed\n});\n</code></pre>\n<blockquote>\n<p>In some cases, excess property checks may result in a compiler error that doesn't correspond to a bug in your code - because you really do intend the object in question to have an additional property not specified in its type. In these cases, the simplest and usually best solution is just to include the additional property as an explicit optional property in the type definition.</p>\n</blockquote>\n<p><strong>Read-Only Properties</strong></p>\n<blockquote>\n<p>You can indicate that a property cannot be reassigned using the readonly property modifier. TypeScript will indicate an error if a line of code reassigns the value of a readonly property after it has been set.\nYou prepend the readonly modifier to a property that you want to be read-only.</p>\n</blockquote>\n<pre><code>type Message = {\n readonly text: string,\n urgent: boolean\n}\nlet welcome: Message = {\n text: 'Welcome',\n urgent: false\n}\n// Error: Cannot assign to 'text' because it is a read-only property\nwelcome.text = 'Welcome!!'\nfunction print (message: Message) {\n // Error: Cannot assign to 'text' because it is a read-only property\n message.text = `** ${message.text} **`\n console.log(message)\n}\n</code></pre>\n<blockquote>\n<p>Another example:</p>\n</blockquote>\n<pre><code>type Message6 = {\n  readonly text: string;\n  urgent: boolean;\n};\nlet welcome6: Message6 = {\n  text: \"Welcome\",\n  urgent: false,\n};\nwelcome6.text = \"Bem vindo\"; // error when trying to assign a new value to the text\n</code></pre>\n<blockquote>\n<p>readonly can be particularly useful for function parameter types, providing a degree of assurance that the function will not modify the values that are passed to it.\nNote that specifying a property as readonly only prevents reassignments to that property, however. It does not prevent the value itself from being changed if it is mutable. For example, an array assigned to a readonly property can still have new items added to it.</p>\n</blockquote>\n<pre><code>type Message7 = {\n readonly clients: Array&#x3C;string>;\n};\nlet welcome7: Message7 = {\n clients: [\"A\", \"B\"],\n};\nwelcome7.clients = [\"A\", \"B\", \"C\"]; // assigning new value to clients is not allowed\nwelcome7.clients.push(\"C\"); // but mutating array is still allowed\n</code></pre>\n<p><strong>Typing Methods in Object Types</strong></p>\n<blockquote>\n<p>Object types can include method types as well as data types.\nTo type a method on an object you use a function type expression. Function type expressions mirror the syntax of arrow functions, with a typed list of parameters in brackets, and a return type after the => arrow. For example:</p>\n</blockquote>\n<pre><code>type SendMessageFunction = (messages: Message[], saveLocalCopy: boolean) => string\n</code></pre>\n<blockquote>\n<p>Another example:</p>\n</blockquote>\n<pre><code>type Print = (a: Message5) => void\nconst printing8: Print = (a) => {\n console.log(a.text);\n};\n</code></pre>\n<p>You can use a function type expression as an object property type like any other. Objects annotated with that type will then need to implement a method matching that function signature.</p>\n<pre><code>type MessageSender = {\n sendAll: (messages: Message[], saveLocalCopy: boolean) => string\n}\nlet sender: MessageSender = {\n sendAll: (messages: Message[], saveLocalCopy: boolean) => {\n   // do some sending\n   return 'OK'\n}\nsender.sendAll(someMessages)\n</code></pre>\n<blockquote>\n<p>Note that the parameter names in the implementation of a function or method do not have to match the parameter names in the type definition. However, the convention is to use the same names unless you have a good reason not to.</p>\n</blockquote>\n<h2>Array type</h2>\n<p><img src=\"https://i.imgur.com/PqcRvxa.jpg\" style=\"width: 800px\"><p style=\"font-size: 12px; text-align: right; width: 100%\"><em>Photo from wowhead.com</em></p></p>\n<blockquote>\n<p>Let's imagine we have an array of all our very precious pets:</p>\n</blockquote>\n<pre><code>let pets = [\"Wind Rider Cub\", \"Phoenix Hatchling\"]\n</code></pre>\n<blockquote>\n<p>To define type as array of strings we say:</p>\n</blockquote>\n<pre><code>let pets: string[];\n</code></pre>\n<blockquote>\n<p>or alternatively:</p>\n</blockquote>\n<pre><code>let pets: Array&#x3C;string>;\n</code></pre>\n<blockquote>\n<p>To define type as array of numbers we say:</p>\n</blockquote>\n<pre><code>let hordeKillsPerDay: number[];\n</code></pre>\n<blockquote>\n<p>or alternatively:</p>\n</blockquote>\n<pre><code>let hordeKillsPerDay: Array&#x3C;number>;\n</code></pre>\n<blockquote>\n<p>To define type as mixed array (of numbers or strings) we say:</p>\n</blockquote>\n<pre><code>let mixedAchievements: any[];\n</code></pre>\n<blockquote>\n<p>or alternatively:</p>\n</blockquote>\n<pre><code>let mixedAchievements: Array&#x3C;any>;\n</code></pre>\n<blockquote>\n<p>You can also be more specific:</p>\n</blockquote>\n<pre><code>let mixedAchievements: (string | number)[];\n</code></pre>\n<blockquote>\n<p>or alternatively:</p>\n</blockquote>\n<pre><code>let mixedAchievements: Array&#x3C;string | number>;\n</code></pre>\n<p><strong>More on Array types</strong></p>\n<blockquote>\n<p>Arrays in <code>JavaScript</code> can have elements of different types. This is usually undesirable, and is a potential source of bugs. For example, when mapping or filtering an array, you want to assume all the elements have the same type.</p>\n</blockquote>\n<blockquote>\n<p>Arrays in <code>TypeScript</code>, on the other hand, can only have elements of the same type.</p>\n</blockquote>\n<blockquote>\n<p>There are two syntax options for defining an array. Because arrays are so common, TypeScript provides a short way to define array types, using square brackets:</p>\n</blockquote>\n<pre><code>const strings: string[] = ['once', 'upon', 'a', 'time']\n</code></pre>\n<blockquote>\n<p>You can also use the Array generic type. Generic types are like functions for types, which take their arguments in angle brackets:</p>\n</blockquote>\n<pre><code>const strings: Array&#x3C;string> = ['once', 'upon', 'a', 'time']\n</code></pre>\n<blockquote>\n<p>TypeScript will raise a type error if you try to add an element of the wrong type to an array. The benefit of this restriction is that it can infer the type of every element in your array, and will raise an error if you try to do anything with an array element that is not compatible with its type.</p>\n</blockquote>\n<blockquote>\n<p>You can loosen Typescript's array type restriction in a controlled way by creating an <code>array of a union type</code>. For example, arrays with the following type can contain a mixture of strings and numbers:</p>\n</blockquote>\n<pre><code>const arrayWithStringsAndNumbers: (string | number)[] = [1, 'two', 3]\n</code></pre>\n<blockquote>\n<p>Be careful, the <code>|</code> union type operator takes precedence over the <code>[]</code> array type operator, so the brackets are necessary to create an array type of a union type. Dropping the brackets will give you a union type where one of the subtypes is an array:</p>\n</blockquote>\n<pre><code>let stringORArrayOfNumbers: string | number[] = 'just a string'\n</code></pre>\n<blockquote>\n<p>TypeScript's restriction on arrays is generally a good thing, and you are unlikely to need to use union types in this way to loosen that restriction. You are more likely to use unions of literal types to tighten the restriction even further. For example:</p>\n</blockquote>\n<pre><code>type ErrorCode = 400 | 401 | 403\nconst serverResponsesFromLast24Hours: number[] = [\n  /* array of all server responses as numbers */\n]\nconst errorCodesFromLast24Hours: ErrorCode[] = []\nfor (const response of serverResponsesFromLast24Hours) {\nif (response === 400 || response === 401 || response === 403) {\nerrorCodesFromLast24Hours.push(response)\n  }\n}\n// Error: Argument of type '200' is not assignable to parameter of type 'ErrorCode'\nerrorCodesFromLast24Hours.push(200)\n</code></pre>\n<blockquote>\n<p>The more precise you can be about the types of values that can go into your arrays, the more helpful the compiler can be in ensuring that those values are used appropriately throughout your code.</p>\n</blockquote>\n<blockquote>\n<p>If you do not explicitly annotate your array variables, TypeScript will infer the type based on the types of the elements in the initial assignment. There are called <code>Inferred Array Types</code>.</p>\n</blockquote>\n<pre><code>const x = [1, 2, 3] // x has the inferred type 'number[]'\nconst y = ['one', 'two', 'three'] // y has the inferred type 'string[]'\nconst z = [1, true, 'three'] // z has the inferred type '(string | number | boolean)[]'\n</code></pre>\n<blockquote>\n<p>The inferred type will always be a <code>general</code> type, like number or string, and not a <code>literal</code> type, like 1 or 'three'. If the elements in the initial assignment have different types, the inferred type of the array will be a union of all those types.</p>\n</blockquote>\n<blockquote>\n<p>If your initial assignment is an empty array, TypeScript will look at how you use the array to infer the type.</p>\n</blockquote>\n<pre><code>const x = [] // x initially has the inferred type 'any[]'\nx.push(1) // x now has the inferred type 'number[]'\nx.push('two') // x now has the inferred type '(number | string)[]'\n</code></pre>\n<blockquote>\n<p>The inferred type will adapt based on the values you add to the array, so when you lookup elements from the array subsequently you will get a suitably cautious union type. But there will be nothing to stop you adding more values of different types.</p>\n</blockquote>\n<blockquote>\n<p>For this reason, it is good practice to explicitly annotate any array that is initialised as an empty array.</p>\n</blockquote>\n<pre><code>const x: Array&#x3C; string | number > = []\n</code></pre>\n<p><strong>Readonly Arrays</strong></p>\n<blockquote>\n<p>Arrays in JavaScript are <code>mutable</code>: you can add and remove elements using the push, pop, shift, and unshift methods, reassign the elements at any index, and modify the whole array with methods like sort:</p>\n</blockquote>\n<pre><code>const numbers = [2, 4]\nnumbers.push(1) // [2, 4, 1]\nnumbers[1] = 3 // [2, 3, 1]\nnumbers.sort() // [1, 2, 3]\n</code></pre>\n<blockquote>\n<p>As seen above, even if we declare an array as a <code>const</code>, we still can <code>mutate</code> it. Const only prevents up from re-assigning the entire array like so:</p>\n</blockquote>\n<pre><code>const numbers = [2, 4]\nnumbers = [1,2,3] // not possible\n</code></pre>\n<blockquote>\n<p>But we can still re-assign individual elements of an array:</p>\n</blockquote>\n<pre><code>const numbers = [2, 4]\nnumbers[1] = 3 // [2, 3]\n</code></pre>\n<blockquote>\n<p>TypeScript arrays are also <code>mutable</code> by default, but you can create an <code>immutable</code> array using the <code>ReadonlyArray</code> generic type or the <code>readonly</code> type modifier. TypeScript will raise a compiler error if you attempt to alter a readonly array.</p>\n</blockquote>\n<pre><code>const numbers: readonly number[] = [2, 4] // or: const numbers: ReadonlyArray&#x3C;number> = [2, 4]\nnumbers.push(1) // Error: Property 'push' does not exist on type 'readonly number[]'.\nnumbers[1] = 3 // Error: Index signature in type 'readonly number[]' only permits reading.\nnumbers.sort() // Error: Property 'sort' does not exist on type 'readonly number[]'.\n</code></pre>\n<blockquote>\n<p>Note that this is not the same as the difference between <code>let</code> and <code>const</code> arrays. You cannot reassign a different array to a <code>const</code> variable, but you can still <code>mutate</code> the array itself. On the other hand, you cannot <code>mutate</code> a readonly array, but if it is assigned to a <code>let</code> variable, you can still reassign a different array to that variable.</p>\n</blockquote>\n<blockquote>\n<p>Summary or arrays re-assigning and mutability:</p>\n</blockquote>\n<pre><code>let numbers: ReadonlyArray&#x3C;number> = [1, 2];\nnumbers = [3, 4]; // OK: re-assigning whole array is ok because it is declared as let\nnumbers[1] = 0; // Error: numbers is readonly therefore its individual elements cannot be re-assigned\n\nconst pets: ReadonlyArray&#x3C;string> = [\"pheonix hatchling\", \"bear cub\"];\npets = [\"pebble\"]; // Error: array declared as const cannot be re-assigned\npets[0] = \"personal world destroyer\"; // Error: pets is readonly therefore its individual elements cannot be re-assigned\n\nconst mounts: Array&#x3C;string> = [\"spectral tiger\", \"drake of the west wind\"];\nmounts = [\"fire hawk\", \"flameward hippogryph\"]; // Error: array declared as const cannot be re-assigned\nmounts[1] = \"heart of the aspects\"; // OK: individual elements of const srray can still be re-assigned\n\nlet titles: Array&#x3C;string> = [\"Savior of Azeroth\", \"Dragonslayer\"];\ntitles = [\"the Flamebreaker\", \"Defender of a Shattered World\"]; // OK: array declared as let can be re-assigned\ntitles[1] = \"Blessed Defender of Nordrassil\"; // OK: individual elements of let array can still be re-assigned\n</code></pre>\n<blockquote>\n<p>Please note, that <code>readonly</code> is only on the surface and refers to the level on which is it declared. Imagine we have array of objects:</p>\n</blockquote>\n<pre><code>const achievements: ReadonlyArray&#x3C;{ name: string; date: number }> = [\n  { name: \"Bucket List\", date: 1644150502 },\n  { name: \"Chromatic Champion\", date: 1644150502 },\n];\n\nachievements[0] = {name: \"Taste the Rainbow!\", date: 1644150502} // Error: you cant re-assign given element because achievements is readonly\nachievements[0].name = \"Taste the Rainbow\" // OK: readonly is only on the surface level of array elements, but if we dig deeper we can change values\n</code></pre>\n<blockquote>\n<p>In above example we can see that we cant assign a new object to <code>achievements[0]</code> but we can change its name or date: <code>achievements[0].name</code></p>\n</blockquote>\n<blockquote>\n<p>If we do not even want to be able to change the name or date of those objects, then we need to add readonly further down the tree:</p>\n</blockquote>\n<pre><code>const achievements: ReadonlyArray&#x3C;{ readonly name: string; readonly date: number }> = [\n  { name: \"Bucket List\", date: 1644150502 },\n  { name: \"Chromatic Champion\", date: 1644150502 },\n];\n\nachievements[0] = {name: \"Taste the Rainbow!\", date: 1644150502} // Error: you cant re-assign given element because achievements is readonly\nachievements[0].name = \"Taste the Rainbow\" // Error: name is now also readonly property of the object\n</code></pre>\n<blockquote>\n<p>Readonly modifier can be used on arrays, objects or properties of object.</p>\n</blockquote>\n<blockquote>\n<p>We can also make an entire object readonly:</p>\n</blockquote>\n<pre><code>type Item = Readonly&#x3C;{item: string, amount: number}>\n</code></pre>\n<p><strong>String Indexed Access</strong></p>\n<blockquote>\n<p>JavaScript <code>arrays</code> are special kinds of <code>objects</code>.</p>\n</blockquote>\n<pre><code>const iAmArray = ['elementOnIndexZero', 'elementOnIndexOne', 'elementOnIndexTwo']\niAmArray[0] // 'elementOnIndexZero'\n</code></pre>\n<blockquote>\n<p>Under the hood in Javascript, the array looks something like this:</p>\n</blockquote>\n<pre><code>iAmArray = {\n  '0': 'elementOnIndexZero',\n  '1': 'elementOnIndexOne',\n  '2': 'elementOnIndexTwo',\n}\niAmArray[0] // 'elementOnIndexZero'\n</code></pre>\n<blockquote>\n<p>You can access indexed elements of an array using a string as well as a number.</p>\n</blockquote>\n<pre><code>const x = [2, 4, 6, 8]\nx[0] === x['0'] // true\n</code></pre>\n<blockquote>\n<p>TypeScript attempts to accommodate this quirk by allowing <code>string-keyed property access</code> when it can be certain that the string can successfully be parsed as a number.</p>\n</blockquote>\n<blockquote>\n<p>In practice, this means when the string is a string representation of a number that is either passed as a literal value or a variable with a literal type.</p>\n</blockquote>\n<pre><code>const x: number[] = [2, 4, 6, 8]\nlet literalVariable: '0' = '0'\nlet stringVariable: string = '0'\nx['0'] // ok\nx[literalVariable] // ok\nx[stringVariable] // Error: Element implicitly has an 'any' type because index expression is not of type 'number'.\n</code></pre>\n<blockquote>\n<p>The last case here raises an error because there is no type guarantee that <code>stringVariable</code> will hold a string representation of a number.</p>\n</blockquote>\n<blockquote>\n<p>To get all of this to work, TypeScript allows you to access an array property using any string-keyed property, but implicitly gives the resulting element the any type if it cannot be parsed as a number. If you have the <code>noImplicitAny</code> compiler flag disabled, therefore, the last line in the example above will not raise an error.</p>\n</blockquote>\n<blockquote>\n<p>More usefully, TypeScript will also allow you to access string-keyed properties of arrays when it can be certain that these correspond to genuine properties or methods on the array.</p>\n</blockquote>\n<pre><code>const x: number[] = [2, 4, 6, 8]\n\nconst arrayPropertyKey = 'length'\n\nx['length'] // ok: equivalent to `x.length`\nx[arrayPropertyKey] // ok: also equivalent to `x.length`\nx['sort'] // ok: equivalent to x.sort, i.e. retrieves the fill method on x (without calling it)\nx['sort']() // ok: equivalent to x.sort(), i.e. retrieves the fill method on x (and calls it)\n</code></pre>\n<p><strong>Unchecked Indexed Access</strong></p>\n<blockquote>\n<p>Because the elements of TypeScript arrays all have the same type, the compiler \"knows\" the type of each element. But there is a catch.</p>\n</blockquote>\n<pre><code>const totals: number[] = [1, 2, 3]\n\nfor (const total of totals) {\n// total has type 'number' :)\n}\n\n// firstTotal has type 'number' :/\nconst firstTotal = totals[0]\n\n// fourthTotal has type 'number' :(\nconst fourthTotal = totals[3]\n</code></pre>\n<blockquote>\n<p>The compiler gives fourthTotal an inferred type of number, but in fact totals[3] is undefined. This is called <code>unchecked index access</code>: the compiler doesn't force you to check whether the element at any given index exists.</p>\n</blockquote>\n<blockquote>\n<p>If you are worried about this possibility, you can enable the <code>noUncheckedIndexedAccess</code> compiler flag. With this flag enabled, the type of elements accessed using an index will be a union type with undefined:</p>\n</blockquote>\n<pre><code>const totals: number[] = [1, 2, 3]\n\nfor (const total of totals) {\n// total has type 'number' :)\n}\n\n// firstTotal has type 'number | undefined' :/\nconst firstTotal = totals[0]\n\n// fourthTotal has type 'number | undefined' :)\nconst fourthTotal = totals[3]\n</code></pre>\n<blockquote>\n<p>Unchecked index access is a way in which TypeScript is not completely type safe. But because the errors that it lets through are rare, and enabling <code>noUncheckedIndexedAccess</code> forces you to write extra manual checks every time you need to access an element, this option is disabled by default.</p>\n</blockquote>\n<h2>Tuples</h2>\n<p><img src=\"https://i.imgur.com/OTOEqWp.jpg\" title=\"Photo by Gela Del Rosario from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Gela Del Rosario from Pexels</em></p></p>\n<blockquote>\n<p>Typescript allows us to add a new type: <code>Tuple</code>. They are available in other programming languages but not in JS. Tuples are fixed length arrays. Example tuple:</p>\n</blockquote>\n<pre><code>const profession= [1, \"cooking\"]\n</code></pre>\n<blockquote>\n<p>By inference Typescript will think that profession is an array of either a number or string.</p>\n</blockquote>\n<pre><code>profession: (number | string)[]\n</code></pre>\n<blockquote>\n<p>Typescript will allow to add elements to the array or re-assign values:</p>\n</blockquote>\n<pre><code>profession.push(\"first aid\");\nprofession[1]=2;\n</code></pre>\n<blockquote>\n<p>So in this scenario, inference does not work the way we want it to work. How to say to Typescript that we can only have exactly 2 elements? Tuple is perfect for this.</p>\n</blockquote>\n<pre><code>const role: [number, string] = [1, \"cooking\"]\n</code></pre>\n<blockquote>\n<p>This tells Typescript I want a special array which should have exactly two elements out of which first one is number and second one is string. Please note, <code>.push</code> will still work as push is exception and works on Tuples!</p>\n</blockquote>\n<h2>Enum type</h2>\n<blockquote>\n<p>Enum is another data type which exists in Typescript and other languages but does not exist in JS. Enums are global variables that can have only limited number of options. For example for the role, we can have options: guildMaster, officer, guildee. These in code should be represented as numbers (starting from 0) but we also want to have human readable labels on top of them.</p>\n</blockquote>\n<blockquote>\n<p>Imagine we then need to work with those values in the code. We could of course just have those as normal string values (not enums) but then we would need to remember if it was <code>guild-master</code> or <code>guild_master</code> or <code>guildMaster</code>.. Which can be cumbersome.</p>\n</blockquote>\n<blockquote>\n<p>Another possibility would be to define 3 different global constants where each of role name would be a constant and hold a number:</p>\n</blockquote>\n<pre><code>const guildMaster = 0;\nconst officer = 1;\nconst guildee = 2;\n</code></pre>\n<blockquote>\n<p>And then we can work variable names in code:</p>\n</blockquote>\n<pre><code>if (officer){ console.log(\"Hi Officer!\")}\n</code></pre>\n<blockquote>\n<p>But then again I needed 3 global variables.</p>\n</blockquote>\n<blockquote>\n<p>Enums can help us in such cases.Enum is a <code>custom type</code> and are written in upper-case.</p>\n</blockquote>\n<blockquote>\n<p>How to create Enum:</p>\n</blockquote>\n<pre><code>enum Role { guildMaster, officer, guildee};\n</code></pre>\n<blockquote>\n<p>Behind the scenes <code>guild-master</code> receives number 0 (poor life of guild masters), <code>officer</code> gets number 1 and <code>guildee</code> gets number 2.</p>\n</blockquote>\n<blockquote>\n<p>We can also start from any custom number:</p>\n</blockquote>\n<pre><code>enum Role { guildMaster = 5, officer, guildee};\n</code></pre>\n<blockquote>\n<p>The rest of them will pick up and have 6 for officer and 7 for guildee.</p>\n</blockquote>\n<blockquote>\n<p>Or we assign custom numbers to each of them:</p>\n</blockquote>\n<pre><code>enum Role { guildMaster = 5, officer = 100, guildee = 200};\n</code></pre>\n<blockquote>\n<p>We are also not restricted to use numbers, we can use text:</p>\n</blockquote>\n<pre><code>enum Role { guildMaster = \"THE MASTER\", officer = 100, guildee = 200};\n</code></pre>\n<blockquote>\n<p>Then we can access this values just like on an object:</p>\n</blockquote>\n<pre><code>enum Role { guildMaster = \"THE MASTER\", officer = 1, guildee = 0 }\n\nconst hero = {\n  name: \"Addania\",\n  title: \"The Horde Slayer\",\n  mounts: [\"Ashes of Al'ar\", \"Spectral Steed\", \"Blue Proto-Drake\"],\n  skills: {\n    enchanting: 360,\n    jewelcrafting: 320\n  },\n  role: Role.guildMaster\n}\n</code></pre>\n<blockquote>\n<p>Now you are maybe asking how did I define the enum? At least for me this worked:</p>\n</blockquote>\n<pre><code>enum Role { guildMaster = \"THE MASTER\", officer = 1, guildee = 0 }\n\nconst hero: {\n    name: string;\n    title: string;\n    mounts: string[];\n    skills: {\n        enchanting: number;\n        jewelcrafting: number;\n    };\n    role: Role;\n\n} = {\n    name: \"Addania\",\n    title: \"The Horde Slayer\",\n    mounts: [\"Ashes of Al'ar\", \"Spectral Steed\", \"Blue Proto-Drake\"],\n    skills: {\n        enchanting: 360,\n        jewelcrafting: 320\n    },\n    role: Role.guildMaster\n}\n</code></pre>\n<h2>Any</h2>\n<blockquote>\n<p>Stores any value in there, Typescript will never yell at you.</p>\n</blockquote>\n<blockquote>\n<p>We can say:</p>\n</blockquote>\n<pre><code>let petName: any;\n</code></pre>\n<blockquote>\n<p>Or at least we can say <code>any</code> array:</p>\n</blockquote>\n<pre><code>let petList: any[];\n</code></pre>\n<blockquote>\n<p>However, good practice is that we AVOID <code>any</code>!</p>\n</blockquote>\n<h2>Union type:</h2>\n<blockquote>\n<p>Imagine I want to have a function which should work on both numbers AND strings. It would either add 2 numbers or concatenate 2 strings:</p>\n</blockquote>\n<pre><code>const combine = (input1, input2) => {\n    const result = input1 + input2\n    return (result)\n};\n</code></pre>\n<blockquote>\n<p>Union type can help us in case we want to work with 2 or more types (can be multiple):</p>\n</blockquote>\n<pre><code>const combine = (input1: number | string, input2: number | string) => {\n    const result = input1 + input2\n    return (result)\n};\n</code></pre>\n<h2>More about union types:</h2>\n<p><strong>Unions of Sets and Types</strong></p>\n<blockquote>\n<p>Every type describes a set of values - the values that have that type. The boolean type describes the set of the two possible Boolean values, true and false, the string type describes the set of all of the possible strings, and so on.</p>\n</blockquote>\n<blockquote>\n<p>In set theory, the union of two or more sets is the (super)set containing all the elements of those (sub)sets. The union of the set of all rational numbers and the set of all irrational numbers, for example, is the set of all real numbers.</p>\n</blockquote>\n<blockquote>\n<p>In type theory, the union of two or more types is the (super)type which describes the union of the sets described by those (sub)types. The boolean type, for example, is effectively the union of the literal types true and false.</p>\n</blockquote>\n<blockquote>\n<p>In TypeScript, you can construct unions of any subtypes with the | operator. For example:</p>\n</blockquote>\n<pre><code>type OptionalString = string | undefined // e.g. 'hello whale', undefined\ntype StringOrNumber = string | number // e.g. 'The meaning of life', 42\ntype OneOrMoreNumbers = number | number[] // e.g. 8, 12, [1, 2, 3, 4, 5]\ntype Primitive = boolean | string | number | bigint // e.g. true, 'true', 82, 10n\n</code></pre>\n<blockquote>\n<p>The | operator is intentionally similar to the logical \"or\" operator, ||. You can read it as \"or\". The values of type X | Y must be either of type X or of type Y.</p>\n</blockquote>\n<p><strong>Unions and Supertypes</strong></p>\n<blockquote>\n<p>Unions are supertypes of their component subtypes. Likewise, any built-in supertype (though not explicitly defined as a union) is equivalent to a union of all its subtypes, in the sense that it describes the exact same set of values.</p>\n</blockquote>\n<blockquote>\n<p>For example, the general object type is equivalent to a union of every specific object type you might define. And the maximally general any and unknown types are equivalent to unions of every other type.</p>\n</blockquote>\n<blockquote>\n<p>The unknown type behaves in all respects just like a union of every other type, and fits naturally into the rest of the type system. The any type is special, however: it is like a union of every other type which also signals that type checking should be disabled for variables of that type.</p>\n</blockquote>\n<blockquote>\n<p>Because supertypes are equivalent to unions of their subtypes, writing an explicit union of a supertype with any of its subtypes is effectively meaningless: the resulting union will be no different from the supertype itself.</p>\n</blockquote>\n<blockquote>\n<p>For example, a union with any results in a type that exactly equivalent to any itself, and likewise for unknown.</p>\n</blockquote>\n<pre><code>type AnyByAnotherName = any | string\n\ntype UnknownByAnotherName = unknown | number\n</code></pre>\n<blockquote>\n<p>In unions with any and unknown, meanwhile, any takes priority.</p>\n</blockquote>\n<pre><code>type AnyInDisguise = any | unknown\n</code></pre>\n<blockquote>\n<p>This means that any variable with the <code>AnyInDisguise</code> type will have all type checking disabled for it, just like an ordinary any variable.</p>\n</blockquote>\n<p><strong>Unions of Literal Types</strong></p>\n<blockquote>\n<p>You can create unions of primitive types like string and number to describe even larger and more general sets of values. On the other side, you can create unions of literal types to describe smaller and more precise sets of values.</p>\n</blockquote>\n<blockquote>\n<p>When dealing with HTTP response codes, for example, the number type is too general, as not every number is a valid response code. In JavaScript, or TypeScript without unions of literal types, you might check that numbers are within the desired range at run-time:</p>\n</blockquote>\n<pre><code>function validateResponse (response) {\n  if (response === 400 || response === 401 || response === 403 || response === 404) {\n    return response\n  }\n  throw new Error()\n}\n\nfunction server (code) {\n  switch (option) {\n    case 400:\n      return computerSaysNo()\n    case 401:\n      return logInPlease()\n    case 403:\n      return itsASecret()\n    case 404:\n      return cantFindIt()\n  }\n}\n\nconst errorCode = validateResponse(400)\nserver(errorCode)\n</code></pre>\n<p>With a union of literal types, you can instead shift the burden of validation onto the compiler:</p>\n<pre><code>type ErrorCode = 400 | 401 | 403 | 404\n\nfunction server (option: ErrorCode) {\n  switch(option) {\n    case 400:\n      return computerSaysNo()\n    case 401:\n      return logInPlease()\n    case 403:\n      return itsASecret()\n    case 404:\n      return cantFindIt()\n  }\n}\n\nserver(400)\n</code></pre>\n<p><strong>Arrays of Union Types</strong></p>\n<blockquote>\n<p>In JavaScript, arrays can contain a mixture of values of different types. Typically, however, you want arrays to only contain values of the same type, and TypeScript enforces this restriction.</p>\n</blockquote>\n<blockquote>\n<p>By creating an array of a union type, however, you can loosen this restriction in a controlled way. For example, arrays with the following type can contain a mixture of strings and numbers:</p>\n</blockquote>\n<pre><code>type stringsAndNumbers = (string | number)[]\n</code></pre>\n<blockquote>\n<p>Note that the | union type operator takes precedence over the [] array type operator, so the brackets are necessary to create an array type of a union type. Dropping the brackets will give you a union type, where one of the subtypes is an array:</p>\n</blockquote>\n<pre><code>type stringOrNumbers = string | number[]\n</code></pre>\n<blockquote>\n<p>Above example would be a union type of a string or an array of numbers</p>\n</blockquote>\n<blockquote>\n<p>Partly for this reason, it is conventional to leave a space either side of the | operator, and no spaces before the [] operator.</p>\n</blockquote>\n<blockquote>\n<p>TypeScript's restriction on arrays is generally a good thing, and you are unlikely to need to use union types in this way to loosen that restriction. You are more likely to use unions of literal types to tighten the restriction even further. For example:</p>\n</blockquote>\n<pre><code>type ErrorCode = 400 | 401 | 403 | 404\n\nconst serverResponsesFromLast24Hours: number[] = [\n  /* array of all server responses as numbers */\n]\n\nconst errorCodesFromLast24Hours: ErrorCode[] = []\n\nfor (const response of serverResponsesFromLast24Hours) {\n  if (response === 400 || response === 401 || response === 403 || response === 404) {\n    errorCodesFromLast24Hours.push(response)\n  }\n}\n\n// Error: Argument of type '200' is not assignable to parameter of type 'ErrorCode'\nerrorCodesFromLast24Hours.push(200)\n</code></pre>\n<blockquote>\n<p>The more precise you can be about the types of values that can go into your arrays, the more helpful the compiler can be in ensuring that those values are used appropriately throughout your code.</p>\n</blockquote>\n<p><strong>Unions of Object Types</strong></p>\n<blockquote>\n<p>With unions of object types, the union does not merge the properties of the underlying types together. Suppose you have the following types in your code:</p>\n</blockquote>\n<pre><code>type Customer = {\n  name: string,\n  customerSaverNumber: number\n}\n\ntype Employee = {\n  name: string,\n  employeeDiscountCode: number,\n}\n\ntype CheckoutUser = Customer | Employee\n</code></pre>\n<blockquote>\n<p>A valid instance of CheckoutUser must be either a Customer or an Employee, and not a hybrid of the two. In other words, it must have a name property, and then either a customerSaveNumber or an employeeDiscountCode, <code>but not both</code>.</p>\n</blockquote>\n<blockquote>\n<p>The following variable, therefore, does not satisfy the definition of CheckoutUser (is not a valid instance of CheckoutUser):</p>\n</blockquote>\n<pre><code>let customerEmployeeHybrid = {\n  name: 'Rod',\n  customerSaverNumber: 479823498,\n  employeeDiscountCode: 094839\n}\n</code></pre>\n<blockquote>\n<p>However, because of TypeScript's structural typing system, an object is compatible with either the Customer or the Employee type when it has all of the properties of that type, even if it has additional properties as well.</p>\n</blockquote>\n<blockquote>\n<p>For this reason, the <code>customerEmployeeHybrid</code> variable is compatible with both the Customer type and the Employee type. As a result, it is also compatible with the CheckoutUser union type.</p>\n</blockquote>\n<blockquote>\n<p>It is important to remember that this is just the result of the structural typing system. The customerEmployeeHybrid variable is compatible with the Customer and Employee types, but is not a valid instance of either. The difference here will show up anywhere excess property checks apply, such as with a direct assignment to an explicitly annotated variable:</p>\n</blockquote>\n<pre><code>let hybridCustomer: Customer = {\n  name: 'Rod',\n  customerSaverNumber: 479823498,\n  // Error: Object literal may only specify known properties,\n  // and 'employeeDiscountCode' does not exist in type 'Customer'\n  employeeDiscountCode: 094839\n}\n\nlet hybridEmployee: Employee = {\n  name: 'Tod',\n  // Error: Object literal may only specify known properties,\n  // and 'customerSaverNumber' does not exist in type 'Employee'\n  customerSaverNumber: 479823498,\n  employeeDiscountCode: 094839\n}\n</code></pre>\n<blockquote>\n<p>Other examples:</p>\n</blockquote>\n<pre><code>type Customer = {\n name: string;\n customerSaverNumber: number;\n};\n\ntype Employee = {\n name: string;\n employeeDiscountCode: number;\n};\n\ntype CheckoutUser = Customer | Employee;\n\ntype Hybrid = {\n name: string;\n customerSaverNumber: number;\n employeeDiscountCode: number;\n};\n\nconst a: Customer = { name: \"mia\", customerSaverNumber: 1 }; // OK\n\nconst b: CheckoutUser = { name: \"mia\", customerSaverNumber: 1 }; // OK\n\nconst c: Hybrid = { name: \"mia\", customerSaverNumber: 1 }; // error, c is missing employee discount code\n\nconst d: Employee = { name: \"pete\", employeeDiscountCode: 202 }; // OK\n\nconst e: CheckoutUser = { name: \"pete\", employeeDiscountCode: 202 }; // OK\n\nconst f: Hybrid = { name: \"pete\", employeeDiscountCode: 202 }; // error, d is missing customerSaverNumber\n\nconst k: Hybrid = {\n name: \"david\",\n customerSaverNumber: 1,\n employeeDiscountCode: 202,\n}; // OK\n\n\nconst g: Customer = {\n name: \"dave\",\n customerSaverNumber: 1,\n employeeDiscountCode: 202,\n}; // error\n</code></pre>\n<blockquote>\n<p>This error is because we explicitly specify what time g should be type Customer, this is an example when excess properties checks kick in. Typescript does not allow us to have additional property of employeeDiscountCode</p>\n</blockquote>\n<pre><code>const h: Employee = {\n name: \"david\",\n customerSaverNumber: 1,\n employeeDiscountCode: 202,\n}; // error\n</code></pre>\n<blockquote>\n<p>This error is because we explicitly specify what time h should be type Employee, this is an example when excess properties checks kick in. Typescript does not allow us to have additional property of customerSaverNumber</p>\n</blockquote>\n<blockquote>\n<p>If we passed above to a function which expects a of a type Customer as an argument, it would work though. This is because excess properties check do not apply and Typescript's default structural typing is in place:</p>\n</blockquote>\n<pre><code>const printMe = (a: Customer) => {\n console.log(a.name);\n};\n\nconst i = {\n name: \"jake\",\n customerSaverNumber: 2,\n employeeDiscountCode: 202,\n};\n\nprintMe(i); // this is ok - because excess properties check does not apply and Typescript's default structural typing is in place\n</code></pre>\n<blockquote>\n<p>If we however, passed value of i directly to the call of the function instead of as a constant, typescript will have a problem with it:</p>\n</blockquote>\n<pre><code>const printMe = (a: Customer) => {\n console.log(a.name);\n};\n\n\nprintMe({\n name: \"alan\",\n customerSaverNumber: 3,\n employeeDiscountCode: 202,\n}); // error - excess properties check kicks in and Typescript's default structural typing is overriden by more strict nominal typing\n</code></pre>\n<p><strong>Unions of Object Types and Excess Property Checks</strong></p>\n<blockquote>\n<p>Excess property checks prevent you from assigning an object literal to an explicitly annotated variable if the literal includes properties not in the annotated type.</p>\n</blockquote>\n<blockquote>\n<p>However, there is a loophole in the compiler when it comes to assigning object literals to unions of object types. If the additional property exists in any of the subtypes of the union, the assignment is allowed:</p>\n</blockquote>\n<pre><code>type Customer = {\n  name: string,\n  customerSaverNumber: number\n}\n\ntype Employee = {\n  name: string,\n  employeeDiscountCode: number\n}\n\ntype CheckoutUser = Customer | Employee\n\nlet customerEmployeeHybrid: CheckoutUser = {\n  name: 'Rod',\n  customerSaverNumber: 479823498, // no error\n  employeeDiscountCode: 094839 // no error\n}\n</code></pre>\n<blockquote>\n<p>Because the compiler raises no error in this case, you might think that unions of object types do merge the properties of the underlying types together, contrary to what you saw on the previous slide. But what is actually going on here is more subtle.</p>\n</blockquote>\n<blockquote>\n<p>Excess property checks work by checking whether each property in the value exists in the type. Does customerSaverNumber exist in the CheckoutUser type? There is no definite answer here: it does exist in Customer, but it doesn't exist in Employee. But excess property checks have to give a definite answer, and since a \"no\" would rule out perfectly legitimate assignments of Customer values, it has to say \"yes\".</p>\n</blockquote>\n<blockquote>\n<p>The case is the same with employeeDiscountCode: it does exist in Employee, but it doesn't exist in Customer.</p>\n</blockquote>\n<blockquote>\n<p>The end result in this case is a legitimate assignment to a CheckoutUser variable that would not be a legitimate assignment to either a Customer variable or an Employee variable. Ideally the assignment of this hybrid object wouldn't be allowed, but the compiler cannot rule it out without also ruling out perfectly acceptable assignments of (non-hybrid) Customer and Employee values as well.</p>\n</blockquote>\n<p><strong>Discriminating Properties</strong></p>\n<blockquote>\n<p>To get around the potentially problematic situation described in the previous slide, you can give the underlying types used in a union of object types a discriminating property: a property with the same key, but an incompatible type. For example, you could give the Customer and Employee object types each a role property with a different literal type:</p>\n</blockquote>\n<pre><code>type Customer = {\n  role: 'Customer',\n  name: string,\n  customerSaverNumber: number\n}\n\ntype Employee = {\n  role: 'Employee',\n  name: string,\n  employeeDiscountCode: number\n}\n\ntype CheckoutUser = Customer | Employee\n</code></pre>\n<blockquote>\n<p>With discriminating properties like these, it becomes impossible to create a hybrid object that is compatible with both types, and so the problematic situation from the previous slide will never arise. Any valid assignment to a CheckoutUser variable will have to have a role property, and the value of that property will determine which other properties are allowed.</p>\n</blockquote>\n<pre><code>let customerWithEmployeeDiscountCode: CheckoutUser = {\n  role: 'Customer',\n  name: 'Rod',\n  customerSaverNumber: 479823498,\n  // Error: Object literal may only specify known properties,\n  // and 'employeeDiscountCode' does not exist in type 'Customer'\n  employeeDiscountCode: 094839\n}\n\nlet employeeWithCustomerSaverNumber: CheckoutUser = {\n  role: 'Employee',\n  name: 'Tod',\n  // Error: Object literal may only specify known properties,\n  // and 'customerSaverNumber' does not exist in type 'Employee'\n  customerSaverNumber: 479823498,\n  employeeDiscountCode: 094839\n}\n</code></pre>\n<p><strong>Tagged Union Types</strong></p>\n<blockquote>\n<p>A union of object types in which each object contains a discriminating property is known variously as a tagged union, a discriminated union, or a sum type. Tagged unions are a useful data type common in functional programming languages, which TypeScript is able to bring to JavaScript.</p>\n</blockquote>\n<blockquote>\n<p>It is common to use the name 'tag' for the discriminating property (at least when no other more meaningful name suggests itself from the nature of the data). But you can use any name you want.</p>\n</blockquote>\n<blockquote>\n<p>In the example from previous slide, the discriminating property was included in the relevant subtypes themselves, but in many cases your code will be more maintainable if you include it in the higher-level union type instead. That way the subtypes can change independently of each other:</p>\n</blockquote>\n<pre><code>type Customer = {\n  name: string,\n  customerSaverNumber: number\n}\n\ntype Employee = {\n  name: string,\n  employeeDiscountCode: number\n}\n\ntype CheckoutUser = { tag: 'Customer', value: Customer }\n                  | { tag: 'Employee', value: Employee }\n</code></pre>\n<blockquote>\n<p>With the discriminating property in the union type, you can also easily add further options that don't have any additional data associated with them:</p>\n</blockquote>\n<pre><code>type CheckoutUser = { tag: 'Anonymous' }\n                  | { tag: 'Manager' }\n                  | { tag: 'Customer', value: Customer }\n                  | { tag: 'Employee', value: Employee }\n</code></pre>\n<blockquote>\n<p>There is nothing intrinsically special or different about tagged unions like these: they behave in all respects like any other union of object types. But because of the discriminating property, you can use them with switch statements to cleanly handle each subtype separately. The compiler will use type narrowing in each case block to determine which properties are available, and - as long as you haven't disabled strict null checks - will typically also be able to warn you if you forget to cover any of the cases.</p>\n</blockquote>\n<pre><code>const validCustomerSaverNumbers: number[] = [ /** ... */ ]\n\nconst validEmployeeDiscountCodes: number[] = [ /** ... */ ]\n\nfunction discountApplies (checkoutUser: CheckoutUser): boolean {\n  switch (checkoutUser.tag) {\n    case 'Anonymous':\n      return false\n    case 'Manager':\n      return true\n    case 'Customer':\n      return validCustomerSaverNumbers.includes(checkoutUser.value.customerSaverNumber)\n    case 'Employee':\n      return validEmployeeDiscountCodes.includes(checkoutUser.value.employeeDiscountCode)\n  }\n}\n</code></pre>\n<blockquote>\n<p>Note that in the 'Customer' and 'Employee' cases you need to access other properties on the checkoutUser.value object, rather than on checkoutUser directly.</p>\n</blockquote>\n<h2>Literal types</h2>\n<p><img src=\"https://i.imgur.com/niHJjzd.jpg\" title=\"Photo by Suzy Hazelwood from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Suzy Hazelwood from Pexels</em></p></p>\n<blockquote>\n<p>Sometimes we might want to restrict value not only to string, number or boolean, but maybe we want to be even stricter. We can limit to only a specific value. For example for constants TS infers that the literal type is for example: 4.6</p>\n</blockquote>\n<pre><code>const myNum=4.6\n</code></pre>\n<blockquote>\n<p>If my parameter can only have 2 values (for example output can only be either: \"calculation result: \" or \"concatenation result: \"), we can use union types together with literal types:</p>\n</blockquote>\n<pre><code>const combine = (input1: number | string, input2: number | string, output: \"calculation result: \" | \"concatenation result: \") => {\n    let result;\n    if (typeof input1 === \"number\" &#x26;&#x26; typeof input2 === \"number\") {\n        result = input1 + input2\n    } else {\n        result = input1.toString() + input2.toString()\n    }\n    return (output + result)\n};\nconsole.log(combine(1, 2, \"calculation result: \"));\nconsole.log(combine(\"A\", \"B\", \"concatenation result: \"));\n</code></pre>\n<h2>Type aliases</h2>\n<p><img src=\"https://i.imgur.com/30FPntX.jpg\" title=\"Photo by sebastiaan stam from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by sebastiaan stam from Pexels</em></p></p>\n<blockquote>\n<p>Instead of writing our union types all the time:</p>\n</blockquote>\n<pre><code>input1: number | string;\ninput2: number | string;\n</code></pre>\n<blockquote>\n<p>you create them on top of your file with word <code>type</code> and provide name of your alias or custom type. Please note that <code>type</code> is again only available in Typescript.</p>\n</blockquote>\n<pre><code>type Combinable = number | string;\ntype OutputMessage = \"calculation result: \" | \"concatenation result: \";\nconst combine = (input1: Combinable, input2: Combinable, output: OutputMessage) => {\n    let result;\n    if (typeof input1 === \"number\" &#x26;&#x26; typeof input2 === \"number\") {\n        result = input1 + input2\n    } else {\n        result = input1.toString() + input2.toString()\n    }\n    return (output + result)\n};\nconsole.log(combine(1, 2, \"calculation result: \"));\nconsole.log(combine(\"A\", \"B\", \"concatenation result: \"));\n</code></pre>\n<blockquote>\n<p>You can create type aliases not only for union types, but also for for example object types. This allows avoiding repetition and manage types centrally.</p>\n</blockquote>\n<pre><code>type Char = { name: string; level: number };\nconst char1: Char = { name: \"Addania\", level: 255 };\nconsole.log(char1.name);\n</code></pre>\n<h2>Return type</h2>\n<p><img src=\"https://i.imgur.com/OfCWNEV.jpg\" title=\"Photo by P C from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by P C from Pexels</em></p></p>\n<blockquote>\n<p>In a simple function we can not only decide what types the parameters of function will be but also the return type. This is usually infered by typescript:</p>\n</blockquote>\n<blockquote>\n<p>In a simple function like this, return value from function will be of type number:</p>\n</blockquote>\n<pre><code>const add = (n1: number, n2: number) => {\n    return n1 + n2\n}\n</code></pre>\n<blockquote>\n<p>When we hover over the add function, we will see following:</p>\n</blockquote>\n<pre><code>const add: (n1: number, n2: number) => number\n</code></pre>\n<blockquote>\n<p>Typescript inferred that return value will be number. But we can assign return type explicitly:</p>\n</blockquote>\n<pre><code>const add2 = (n1: number, n2: number): number => {\n    return n1 + n2\n}\n</code></pre>\n<blockquote>\n<p>Imagine following function:</p>\n</blockquote>\n<pre><code>const add = (n1: number, n2: number) => {\n    return n1.toString() + n2.toString()\n}\n</code></pre>\n<blockquote>\n<p>When we hover over the add function, we will see that return is a string:</p>\n</blockquote>\n<pre><code>const add: (n1: number, n2: number) => string\n</code></pre>\n<blockquote>\n<p>Typescript inferred that return will be string. But we can assign return type explicitly:</p>\n</blockquote>\n<pre><code>const add2 = (n1: number, n2: number): string => {\n    return n1 + n2\n}\n</code></pre>\n<blockquote>\n<p>Best practice is to let Typescript infer types.</p>\n</blockquote>\n<h2>Void type:</h2>\n<p><img src=\"https://i.imgur.com/n51Q4mm.jpg\" title=\"Photo by David Yu from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by David Yu from Pexels</em></p></p>\n<blockquote>\n<p>Void type does not exist in Javascript, but we might know it from other languages.</p>\n</blockquote>\n<blockquote>\n<p>WHAT on Earth is the void type? Imagine you have a function which returns nothing and only prints some text:</p>\n</blockquote>\n<pre><code>const printResult=(n1: number)=> (\n    console.log(\"Result: \" + n1)\n)\n</code></pre>\n<blockquote>\n<p>If you then hover over <code>printResult</code>, you will see that Typescript infers that it returns <code>void</code>:</p>\n</blockquote>\n<pre><code>printResult: (n1: number) => void\n</code></pre>\n<blockquote>\n<p>We could actually specify it explicitly (but this is not recommended):</p>\n</blockquote>\n<pre><code>const printResult=(n1: number):void => (\n    console.log(\"Result: \" + n1)\n)\n\nprintResult(2)\n</code></pre>\n<blockquote>\n<p>So <code>void</code> means I do not have return statement in my function.</p>\n</blockquote>\n<blockquote>\n<p>Practically my function returns something though. Console.log the return of <code>printResult</code> would yield <code>undefined</code>.</p>\n</blockquote>\n<pre><code>const printResult=(n1: number):void => (\n    console.log(\"Result: \" + n1)\n)\nconsole.log(print(2))\n</code></pre>\n<blockquote>\n<p><code>Undefined</code> is a REAL value in Javascript!</p>\n</blockquote>\n<blockquote>\n<p>There is another way (but VERY NOT recommended way) to specify that my function will return <code>undefined</code>, but this only works when your function HAS a return statement which is empty:</p>\n</blockquote>\n<pre><code>const printResult=(n1: number):undefined => (\n    console.log(\"Result: \" + n1)\n    return;\n)\nconsole.log(print(2))\n</code></pre>\n<h2>Function type</h2>\n<p><img src=\"https://i.imgur.com/M2Zf5ER.jpg\" title=\"Photo by Miguel √Å. Padri√±√°n from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Miguel √Å. Padri√±√°n from Pexels</em></p></p>\n<blockquote>\n<p>We are able to tell to Typescript that certain variable is expected to be a function.</p>\n</blockquote>\n<blockquote>\n<p>Imagine a code like this:</p>\n</blockquote>\n<pre><code>const add = (n1: number, n2: number) => {\n    return n1 + n2\n}\nlet newFunction;\nnewFunction=add;\nconsole.log(newFunction(1,2))\n</code></pre>\n<blockquote>\n<p>In order to tell explicitly to Typescript that <code>newFunction</code> will be a function, so that later on we cannot assign it just a number <code>newFunction=2</code>, we can define the function type:</p>\n</blockquote>\n<pre><code>let newFunction: Function;\n</code></pre>\n<blockquote>\n<p>We can also use an arrow notation where we can define a return type:</p>\n</blockquote>\n<pre><code>let newFunction: () => number;\n</code></pre>\n<blockquote>\n<p>We can also add types of parameters which we also need to enter:</p>\n</blockquote>\n<pre><code>let newFunction: (a: number, b: number) => number;\n</code></pre>\n<p><strong>Function types and callbacks</strong></p>\n<p><img src=\"https://i.imgur.com/tp0nHv2.jpg\" title=\"Photo by Hassan OUAJBIR from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Hassan OUAJBIR from Pexels</em></p></p>\n<blockquote>\n<p>Imagine I have a function which will receive 2 numbers as paramenters and also a third parameter which will be another function (callback function):</p>\n</blockquote>\n<pre><code>const printResult = (n1: number): void => (\n    console.log(\"Result: \" + n1)\n)\nconst add = (n1: number, n2: number, callback): number => {\n    const result = n1 + n2\n    callback(result);\n    return result\n}\nconst output = add(10, 20, printResult)\n</code></pre>\n<blockquote>\n<p>Another way how we can do this using anonymous function (where I define the function right in the place where I call it):</p>\n</blockquote>\n<pre><code>const add = (n1: number, n2: number, callback): number => {\n    const result = n1 + n2\n    callback(result);\n    return result\n}\nconst output = add(10, 20, (result) => {\n  console.log(\"Result is: \" + result)\n }\n)\n</code></pre>\n<blockquote>\n<p>How to now define the function type:</p>\n</blockquote>\n<pre><code>const add = (n1: number, n2: number, callback: (num: number) => void ): number => {\n    const result = n1 + n2\n    callback(result);\n    return result\n}\n</code></pre>\n<p><strong>More on function types</strong></p>\n<blockquote>\n<p>Function signatures in TypeScript are simply annotated versions of JavaScript function signatures.</p>\n</blockquote>\n<pre><code>// annotated function declaration\nfunction add (a: number, b: number): number {\n  return a + b\n}\n\n// annotated function expression\nconst multiply = function (c: number, d: number): number {\n  return c * d\n}\n\n// annotated arrow function expression\nconst subtract = (e: number, f: number): number => {\n  return e - f\n}\n</code></pre>\n<blockquote>\n<p>If you don't explicitly annotate the parameter or return types, the TypeScript compiler will infer them for you.</p>\n</blockquote>\n<blockquote>\n<p>While the compiler is generally good at inferring return types, unannotated parameters will usually have an inferred type of any (you will see the exceptions later on). Assuming you have the default <code>noImplicitAny</code> flag enabled, this will raise an error, so as a general rule <code>parameter types must always be annotated</code>.</p>\n</blockquote>\n<blockquote>\n<p>Functions that do not include an explicit return value have an inferred return type of void, which you can also specify explicitly.</p>\n</blockquote>\n<pre><code>function logger (): void {\nconsole.log('Hey Skillers!')\n}\n\nfunction loggerWithReturn (): void {\nconsole.log('Have a great day!')\nreturn\n}\n</code></pre>\n<blockquote>\n<p>JavaScript's default return value (for functions that don't specify one) is undefined, hence undefined is the only value assignable to a variable of type void. There are some slight differences between the types void and undefined, however.</p>\n</blockquote>\n<blockquote>\n<p>If your function explicitly returns undefined, its inferred return type will be undefined rather than void.</p>\n</blockquote>\n<blockquote>\n<p>And although a function whose annotated return type is void can explicitly return undefined, a function whose annotated return type is undefined must do so:</p>\n</blockquote>\n<pre><code>// OK\nfunction logger (): void {\nconsole.log('Hey Skillers!')\nreturn undefined\n}\n\n// Error: A function whose declared type is neither 'void' nor 'any' must return a value.\nfunction logger (): undefined {\nconsole.log('Hey Skillers!')\n}\n</code></pre>\n<blockquote>\n<p>You will see another difference between void and undefined later on. For now, just note that you should always use void as the return type for functions that do not return an explicit value (and not use it for anything else).</p>\n</blockquote>\n<p><strong>Function Parameters</strong></p>\n<blockquote>\n<p>Functions in JavaScript are all technically <code>variadic</code> functions: they are able to accept a variable number of arguments. This is why you can get unintended consequences related to undefined or NaN instead of run-time errors when you pass in the wrong number of arguments:</p>\n</blockquote>\n<pre><code>function doNothing (number) {\nreturn number\n}\n\ndoNothing(1, 2, 3, 4, 5) // 1\ndoNothing() // undefined\n\nfunction add (a, b, c) {\nreturn a + b + c\n}\n\nadd() // NaN\nadd(1) // NaN\nadd(1, 2, 3, 4, 5) // 6\n</code></pre>\n<blockquote>\n<p>TypeScript protects you from this buggy behaviour by throwing a compilation error any time you pass in the wrong number of arguments. When you really do want flexibility in the number of arguments you can pass to a function, there are two controlled ways in which TypeScript allows this.</p>\n</blockquote>\n<p><strong>Optional Parameters</strong></p>\n<blockquote>\n<p>The parameter list in a function signature can end with any number of optional parameters, marked as optional with the ? operator. You do not need to supply an argument corresponding to an optional parameter when you call the function, and the compiler will guard against run-time errors by making the type of this parameter a union with undefined.</p>\n</blockquote>\n<pre><code>function add (a: number, b: number, c?: number) {\nreturn c === undefined\n? a + b\n: a + b + c\n}\n\nadd(1) // Error: Expected 2 arguments, but got 1\nadd(1, 2) // 3\nadd(1, 2, 3) // 6\n</code></pre>\n<blockquote>\n<p>As with JavaScript, you can also make an argument optional by providing a default value after the type annotation:</p>\n</blockquote>\n<pre><code>function multiply (a: number, b: number = 10) {\nreturn a \\* b\n}\n\nmultiply(12, 10) // 120\nmultiply(12) // 120\n</code></pre>\n<blockquote>\n<p>In this case, the parameter's type will not be a union with undefined, since the default value will be used whenever the argument is not specified.</p>\n</blockquote>\n<p><strong>Rest Parameters</strong></p>\n<blockquote>\n<p>In the case of an unknown number of arguments you can use a rest parameter, just as you would in JavaScript. Since rest parameters are <code>arrays</code>, they must be annotated as an array type.</p>\n</blockquote>\n<pre><code>function add (...numbers: number[]) {\nreturn numbers.reduce((a, b) => a + b, 0)\n}\n\nadd(1, 2, 3, 4, 5) // 15\nadd() // 0\n</code></pre>\n<blockquote>\n<p>Similarly but when we know first two parameters, and rest of the parameters are of an unknown length:</p>\n</blockquote>\n<pre><code>function add (x: number, y: number, ...numbers: number[]) {\n  return x+y+numbers.reduce((a, b) => a + b, 0)\n  }\nadd(1, 2, 3, 4, 5) // 15\nadd(1,2) // 0\n</code></pre>\n<p><strong>Function Type Expressions</strong></p>\n<blockquote>\n<p>You can provide types for your functions inline, by annotating the parameters and the return value directly in the function signature, as you have seen. But you can also specify the type of a function separately from its implementation using a <code>function type expression</code>.</p>\n</blockquote>\n<blockquote>\n<p>The syntax for <code>function type expressions</code> mirrors the syntax for arrow functions, but you can use them to annotate both styles of function expression:</p>\n</blockquote>\n<pre><code>type NumberToString = (value: number, leadingZeros: number) => string\n\nconst numberToString: NumberToString = (value, leadingZeros) => {\nreturn value.toString().padLeft(leadingZeros)\n}\n\n// -OR-\n\nconst numberToString: NumberToString = function (value, leadingZeros) {\nreturn value.toString().padLeft(leadingZeros)\n}\n</code></pre>\n<blockquote>\n<p>The <code>NumberToString</code> type specifies a function that takes two number arguments and returns a string. The numberToString variable is assigned a function that matches this type signature.</p>\n</blockquote>\n<blockquote>\n<p>Note that, if you provide a function type annotation, you do not need to provide explicit type annotations for the parameters or the return value in the function expression itself, as these will be inferred to match those in the function type.</p>\n</blockquote>\n<blockquote>\n<p>Also note that there is no way to explicitly annotate a function declaration with a function type expression. You need to write a function expression, assign that to a variable, and annotate the variable with the function type.</p>\n</blockquote>\n<blockquote>\n<p>Function type expressions are mainly useful in two cases.</p>\n</blockquote>\n<blockquote>\n<p>The first case is when you want to provide a type annotation for a function parameter passed to a higher-order function:</p>\n</blockquote>\n<pre><code>type Action = 'Submit' | 'Cancel'\n\ntype Handler = (input: string) => void\n\nconst submitCallbacks: Handler[] = []\n\nconst cancelCallbacks: Handler[] = []\n\nconst addListener = (action: Action, handler: Handler) => {\nswitch (action) {\ncase 'Submit':\nsubmitCallbacks.push(handler)\nbreak\ncase 'Cancel':\ncancelCallbacks.push(handler)\nbreak\n }\n}\n</code></pre>\n<blockquote>\n<p>When passing a function expression as an argument, you do not need to explicitly annotate its parameters or return type. As with function expressions assigned to annotated function variables, these types will be inferred based on the type of the parameter:</p>\n</blockquote>\n<pre><code>addListener('Submit', (input) => {\ninputs.push(input)\nconsole.log('thank you for you input')\n})\n</code></pre>\n<blockquote>\n<p>The second case in which function type expressions are useful is when you want to specify the type signature of a method on an object type:</p>\n</blockquote>\n<pre><code>type SetOfNumbers = {\nvalues: number[],\nadd: (value: number) => void,\ndelete: (value: number) => void,\ncontains: (value: number) => boolean,\nentries: () => number[]\n}\n</code></pre>\n<p><strong>Compatibility of Function Types (Structural Typing)</strong></p>\n<blockquote>\n<p>TypeScript implements a structural typing system, which means that the type of the value you assign to a variable doesn't have to be identical to the type of the variable, it only has to be compatible with it.</p>\n</blockquote>\n<blockquote>\n<p>With object types, for example, object type B is compatible with object type A if it contains at least the same properties as object type A. It can contain additional properties as well (at least where excess property checks don't apply).</p>\n</blockquote>\n<blockquote>\n<p>Something similar is true of functions: you can assign a function of type B to a function variable of type A, as long as type B is compatible with type A.</p>\n</blockquote>\n<blockquote>\n<p>For function type B to be compatible with function type A, three things have to hold:</p>\n</blockquote>\n<ul>\n<li>\n<ol>\n<li>The return type of function type B must be compatible with the return type of function type A.</li>\n</ol>\n</li>\n</ul>\n<pre><code>let returnsStringB = (): string => 'boo!'\nlet returnsStringOrNumberA = (): string | number => Math.random() &#x3C; 0.5 ? 2 : 'boo!'\n\nreturnsStringOrNumberA = returnsStringB // OK: B can be assigned to A because B is compatible with A\nreturnsStringB = returnsStringOrNumberA // ERROR: A is not compatible with B, B cant handle numbers\n</code></pre>\n<blockquote>\n<p>The first assignment is fine, because string is compatible with string | number. But the second assignment is not allowed, because string | number is not compatible with string.</p>\n</blockquote>\n<ul>\n<li>\n<ol start=\"2\">\n<li>The types of the parameters in function type A must be compatible with the types of the parameters in function type B. (Note this is the opposite way round from the first condition.)</li>\n</ol>\n</li>\n</ul>\n<pre><code>let takesStringB = (x: string): void => {}\nlet takesStringOrNumberA = (x: string | number): void => {}\n\ntakesStringB = takesStringOrNumberA // OK\ntakesStringOrNumberA = takesStringB // ERROR\n</code></pre>\n<blockquote>\n<p>The first assignment is fine, because takesStringOrNumber can be called with a string (as the type of takesString expects). The second assignment is not allowed, because takesString can't be called with a number (but the type of takesStringOrNumber says that it can be).</p>\n</blockquote>\n<blockquote>\n<p>Another way to think about this is: in the place of takeStringB we expect something that can handle strings. If we provide it with a function that can handle string and numbers, we are fine. In the second line, in the place of takesStringOrNumberA we expect a function that can handle strings and numbers. But if we pass there a function which can only with with strings, then this is not OK.</p>\n</blockquote>\n<ul>\n<li>\n<ol start=\"3\">\n<li>Function type B must have no more parameters than function type A (unless those additional parameters are optional or rest parameters), but it can have fewer.</li>\n</ol>\n</li>\n</ul>\n<pre><code>let takesTwoArguments = (x: number, y: number) => x + y\n\ntakesTwoArguments = (x: number) => x + 10 // OK\ntakesTwoArguments = (x: number, y: number, z: number) => x + y + z // ERROR\ntakesTwoArguments = (x: number, y: number, z?: number) => x + y // OK\n</code></pre>\n<blockquote>\n<p>The first assignment is fine: the compiler will insist on a second argument when you call this function, but the function body will ignore it and there will be no run-time error. The second assignment, however, raises an error, because the compiler would only allow you to call this function with two arguments, and the required third argument would be undefined. For the same reason, the third assignment will not raise an error: since the third parameter is optional, the function body will not cause a run-time error when its value is undefined.</p>\n</blockquote>\n<blockquote>\n<p>Don't worry if you don't understand all of these rules at once, this is the kind of thing that becomes clearer over time, with practice. For now, the important thing to know is that each of these constraints exists to make sure that type errors will not slip through when handling functions and function assignments.</p>\n</blockquote>\n<p><strong>Function Type Compatibility with void</strong></p>\n<blockquote>\n<p>In general, for one function to be compatible with another function, the return type of the first function must be compatible with that of the second function. As we saw above, this is to prevent type errors from sneaking past the compiler:</p>\n</blockquote>\n<pre><code>type ReturnsNumber = (x: number) => number\n\nconst returnsStringOrNumber: ReturnsNumber = (x: number): string | number => {\nreturn x &#x3C; 10 ? x + 2 : 'x is too large'\n}\n\n// ERROR: Type '(x: number) => string | number' is not assignable to type 'ReturnsNumber'.\n// Type 'string | number' is not assignable to type 'number'.\n// Type 'string' is not assignable to type 'number'.\n</code></pre>\n<blockquote>\n<p>If this assignment was allowed, then returnsStringOrNumber(20) would have the string value 'x is too large' (because of the function itself), but the type number (because of the ReturnsNumber type annotation). To prevent this kind of type error, assignments like these are not allowed.</p>\n</blockquote>\n<blockquote>\n<p>There is one exception to this general rule, however. A function that returns any value (not just undefined) is compatible with a void function.</p>\n</blockquote>\n<blockquote>\n<p>This exception exists to allow common patterns like these:</p>\n</blockquote>\n<pre><code>const source = [4, 8, 16]\nconst destination = []\n\nsource.forEach(n => destination.push(n))\n</code></pre>\n<blockquote>\n<p>The array method, forEach, requires a void function as its argument, but here we are passing it a function that returns a number (the push method returns the new length of the array).</p>\n</blockquote>\n<blockquote>\n<p>Strictly speaking this shouldn't be allowable, because the only value compatible with void is undefined. And because of this exception, type errors can get past the compiler:</p>\n</blockquote>\n<pre><code>type ReturnsVoid = () => void\n\nconst returnsString: ReturnsVoid = () => 'not undefined!!'\n\nconst result = returnsString() // result has type 'void', but its value is a 'string'\n</code></pre>\n<blockquote>\n<p>Type errors like these can never give rise to any run-time errors, however. They simply mean that you have a value that is not undefined that the compiler will not let you use as such (because it is assigned to a variable with the type void).</p>\n</blockquote>\n<blockquote>\n<p>Note that this exception only applies to void functions, not to functions that have a return type of undefined. This is another key difference between void and undefined as return types.</p>\n</blockquote>\n<p><strong>Never Return type</strong></p>\n<blockquote>\n<p>The never type represents values that can never occur at run-time. It is not possible to assign anything to a variable of type never. In other words, the set described by this type is the empty set.</p>\n</blockquote>\n<blockquote>\n<p>Perhaps surprisingly, the never type has some practical applications. One such application is as the return type of a function that will never return, either because it always throws an error, or because it runs forever.</p>\n</blockquote>\n<pre><code>function tick (): never {\nlet counter: number = 0\nwhile (true) counter += 1\n}\n\nfunction fail (): never {\nthrow new Error('something went wrong')\n}\n</code></pre>\n<blockquote>\n<p>TypeScript uses control flow analysis to determine whether a function will never return, and in principle can give functions an inferred return type of never in these cases.</p>\n</blockquote>\n<blockquote>\n<p>The inferred return type for functions that never return, however, is only never for function expressions. For function declarations, the inferred type is void.</p>\n</blockquote>\n<pre><code>// the inferred type of failDeclaration is '() => void'\nfunction failDeclaration () {\nthrow new Error('something went wrong')\n}\n\n// the inferred type of failExpression is '() => never'\nconst failExpression = function () {\nthrow new Error('something went wrong')\n}\n\n// the inferred type of failExpressionArrow is also '() => never'\nconst failExpressionArrow = () => {\nthrow new Error('something went wrong')\n}\n</code></pre>\n<blockquote>\n<p>Ideally, the return type for function declarations that never return would also be never. But when the never type was introduced, this was found to be too big a breaking change for a lot of existing code, so for practical reasons the more accurate inference was only applied to function expressions.</p>\n</blockquote>\n<h2>Unknown type</h2>\n<p><img src=\"https://i.imgur.com/GPUfFFD.jpg\" title=\"Photo by Kaique Rocha from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Kaique Rocha from Pexels</em></p></p>\n<blockquote>\n<p>Unknown is used if we do not know yet, if it is number or a string. We can store any numbers in there without getting errors:</p>\n</blockquote>\n<pre><code>let userInput: unknown;\nuserInput = \"mia\"\nconsole.log(userInput)\nuserInput = 5\nconsole.log(userInput)\nuserInput = true\nconsole.log(userInput)\n</code></pre>\n<blockquote>\n<p>This looks similar to <code>any</code> type. But it IS different.</p>\n</blockquote>\n<blockquote>\n<p>Type <code>unknown</code> type cannot be then assigned to other variable which is for example of a type string. Typescript will throw an error.</p>\n</blockquote>\n<pre><code>let userInput: unknown;\nlet userName: string;\nuserInput = 5\nuserInput = \"mia\"\nuserName=userInput\n</code></pre>\n<blockquote>\n<p>Whereas with <code>any</code> it will not throw an error:</p>\n</blockquote>\n<pre><code>let userInput: any;\nlet userName: string;\nuserInput = 5\nuserInput = \"mia\"\nuserName=userInput\n</code></pre>\n<blockquote>\n<p>If the type of a variable is unknown in order to use it to assign it to a string, we need to check the type:</p>\n</blockquote>\n<pre><code>if (typeof userInput === \"string\") {\nuserName = userInput\n}\n</code></pre>\n<blockquote>\n<p><code>Unknown</code> is a better choice to any ,when we are not sure of which type the input will be (like when user enters something), because if enables type checks and forces us to check our types in the code manually. If we use any, all the type checks are disabled - typescript gives up.</p>\n</blockquote>\n<h2>Never type</h2>\n<p><img src=\"https://i.imgur.com/GrnyFyS.jpg\" title=\"Photo by Elina Krima from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Elina Krima from Pexels</em></p></p>\n<blockquote>\n<p>Functions which throw error cancel the script after the word <code>throw</code>, so that there is no possibility it will ever return anything.</p>\n</blockquote>\n<pre><code>const generateError = (message: string, code: number) => {\n    throw { message: message, errorCode: code }\n}\ngenerateError(\"Upsy\", 500)\n</code></pre>\n<blockquote>\n<p>So the type of such function is not <code>void</code> (because <code>void</code> returns <code>undefined</code>). Type of such function is <code>never</code>.</p>\n</blockquote>\n<pre><code>const generateError = (message: string, code: number): never => {\n    throw { message: message, errorCode: code }\n}\ngenerateError(\"Upsy\", 500)\n</code></pre>\n<blockquote>\n<p>We can also console log this and see there is no console log:</p>\n</blockquote>\n<pre><code>const generateError = (message: string, code: number): never => {\n    throw { message: message, errorCode: code }\n}\nconst something = generateError(\"Upsy\", 500)\nconsole.log(something)\n</code></pre>\n<blockquote>\n<p>Also another function which would <code>never</code> return anything is an infite loop function:</p>\n</blockquote>\n<pre><code>const generateError = (message: string, code: number): never => {\n    while (true){}\n}\nconst something = generateError(\"Upsy\", 500)\nconsole.log(something)\n</code></pre>\n<h2>Watchmode</h2>\n<p><img src=\"https://i.imgur.com/6tOCEK8.jpg\" title=\"Photo by Jordan Benton from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Jordan Benton from Pexels</em></p></p>\n<blockquote>\n<p>So far after each change of our file we needed to manually run tsc <code>app.ts</code>.</p>\n</blockquote>\n<blockquote>\n<p>We can enter the watchmode and make sure that compilation watches for any change of the file and if it changes then it re-compiles automatically.</p>\n</blockquote>\n<blockquote>\n<p>How to enter watchmode:</p>\n</blockquote>\n<pre><code>tsc app.ts --watch\n</code></pre>\n<blockquote>\n<p>Or alternatively:</p>\n</blockquote>\n<pre><code>tsc app.ts -w\n</code></pre>\n<blockquote>\n<p>You can then exit it with:</p>\n</blockquote>\n<pre><code>CTRL + C\n</code></pre>\n<blockquote>\n<p>How about I have more files than one. Let's add another file called <code>analytics.ts</code> and this file will contain following command:</p>\n</blockquote>\n<pre><code>console.log(\"Sending...\")\n</code></pre>\n<blockquote>\n<p>In order to use this file in our project, we need to add it to the script tag of out <code>index.html</code>:</p>\n</blockquote>\n<pre><code>&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n&#x3C;head>\n    &#x3C;meta charset=\"UTF-8\">\n    &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    &#x3C;title>Typescript Course&#x3C;/title>\n    &#x3C;script src=\"app.js\" defer>&#x3C;/script>\n    &#x3C;script src=\"analytics.js\" defer>&#x3C;/script>\n&#x3C;/head>\n&#x3C;body>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<blockquote>\n<p>Now imagine we want to compile automatically every time any of these two files changes.</p>\n</blockquote>\n<blockquote>\n<p>For that we will need to do only once:</p>\n</blockquote>\n<pre><code>tsc --init\n</code></pre>\n<blockquote>\n<p>It will initiate the whole folder as a typescript project. It will also create <code>tsconfig.json</code> file.</p>\n</blockquote>\n<blockquote>\n<p>Now we will be able to run just <code>tsc</code> in the terminal and it will compile all the .ts files in our project.</p>\n</blockquote>\n<blockquote>\n<p>We can combine it with watchmode!</p>\n</blockquote>\n<pre><code>tsc -w\n</code></pre>\n<p>or</p>\n<pre><code>tsc --watch\n</code></pre>\n<h2>Excluding and including files to compile</h2>\n<blockquote>\n<p><code>tsconfig.json</code> file is a critical file which tells Typescript how to compile this whole project!</p>\n</blockquote>\n<blockquote>\n<p>It is possible to exclude certain files from compilation. In order to do that you need to add exclude command at the end of the <code>tsconfig.json</code> file. Make sure you add the command betwee two curly brackets and separate them by comma:</p>\n</blockquote>\n<pre><code>    /* Advanced Options */\n    \"forceConsistentCasingInFileNames\": true /* Disallow inconsistently-cased references to the same file. */\n  },\n  \"exclude\": [\n    \"analytics.ts\"\n  ]\n}\n</code></pre>\n<blockquote>\n<p>You will need to re-run the compilation with <code>tsc</code> command. Notice that file <code>analytics.js</code> is not created.</p>\n</blockquote>\n<blockquote>\n<p>We can use it with regular expressions to check for any file ending with <code>.dev.ts</code></p>\n</blockquote>\n<pre><code>},\n  \"exclude\": [\n    \"*.dev.ts\"\n  ]\n}\n</code></pre>\n<blockquote>\n<p>We exclude a file ending with <code>.dev.ts</code> in ANY folder</p>\n</blockquote>\n<pre><code>},\n  \"exclude\": [\n    \"**/*.dev.ts\"\n  ]\n}\n</code></pre>\n<blockquote>\n<p>Typically what we DO WANT to exclude are files in <code>node_modules</code> folder (which holds all dependencies):</p>\n</blockquote>\n<pre><code>},\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n</code></pre>\n<blockquote>\n<p>We can exlude any folder from compilation and no files within this folder will be compiled:</p>\n</blockquote>\n<pre><code>},\n  \"exclude\": [\n    \"folder_name_to_exclude\"\n  ]\n}\n</code></pre>\n<blockquote>\n<p>By default this folder will be excluded by Typescript (so we do not necessarily need to do it, but we can)</p>\n</blockquote>\n<blockquote>\n<p>On the other hand we can explicitely say which files to INCLUDE in our compilation. Anything else will be ignored:</p>\n</blockquote>\n<pre><code>},\n  \"exclude\": [\n    \"node_modules\"\n  ],\n  \"include\": [\n      \"app.ts\",\n      \"analytics.ts\"\n  ]\n}\n</code></pre>\n<blockquote>\n<p>I can also include whole folder which I want to include in compilation. For example folder called \"section1\":</p>\n</blockquote>\n<pre><code>},\n  \"exclude\": [\n    \"node_modules\"\n  ],\n  \"include\": [\n      \"app.ts\",\n      \"analytics.ts\",\n      \"section1\"\n  ]\n}\n</code></pre>\n<blockquote>\n<p>If I have both exclude and include, Typescript will compile what is INCLUDED minus what is EXCLUDED</p>\n</blockquote>\n<blockquote>\n<p>Command file is like include but only applies to files (I cannot use it on folders):</p>\n</blockquote>\n<pre><code>},\n  \"exclude\": [\n    \"node_modules\"\n  ],\n  \"files\": [\n      \"app.ts\",\n      \"analytics.ts\"\n  ]\n}\n</code></pre>\n<h2>tsconfig.json options</h2>\n<h3>Target</h3>\n<p><img src=\"https://i.imgur.com/LIWQef6.jpg\" title=\"Photo by vedanti from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by vedanti from Pexels</em></p></p>\n<blockquote>\n<p>Target tells for which target Javascript version we want to compile our code and which runs in set of browsers. And you dedefine which browsers support the compiled code by setting the target.</p>\n</blockquote>\n<pre><code> \"compilerOptions\": {\n    /* Basic Options */\n    // \"incremental\": true,\n    \"target\": \"es5\",\n</code></pre>\n<blockquote>\n<p>Default target is <code>es5</code>. And I can see it, because in my <code>.ts</code> files I use <code>const</code> and <code>let</code>, which if I open the <code>.js</code> file I will see <code>var</code> everywhere. Because in <code>es5</code> we do not have <code>let</code> and <code>const</code>!! <code>es5</code> makes sure that code will run in older browsers, but maybe I want to use <code>es6</code> and then I have other build tool which will transpile the Javascript code which can be then read by older browsers. Or maybe we want to ship code that ONLY works in modern browsers.</p>\n</blockquote>\n<blockquote>\n<p>We can delete the es5 and press <code>CTRL+SPACE</code> it will give you all the possible options. You can set target to es6 which is equivalent to es2015. Or use even more recent version like: es2020</p>\n</blockquote>\n<h3>Libraries</h3>\n<p><img src=\"https://i.imgur.com/zZbnUAa.jpg\" title=\"Photo by Skitterphoto from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Skitterphoto from Pexels</em></p></p>\n<blockquote>\n<p>Allows to specify which default objects and features Typescript knows (for example working with the DOM). If \"lib\" is empty, defaults are assumed based on our target. As our target is es5 or es6 than it assumes default libraries like working with DOM API, etc.</p>\n</blockquote>\n<blockquote>\n<p>Add a button to the index.html file:</p>\n</blockquote>\n<pre><code>&#x3C;body>\n    &#x3C;button>Click Me!&#x3C;/button>\n&#x3C;/body>\n</code></pre>\n<blockquote>\n<p>And then let us add event listener to the button, so that we console log a message when button is clicked. Add this to the .ts file:</p>\n</blockquote>\n<pre><code>const button = document.querySelector(\"button\")!;\nbutton.addEventListener(\"click\", () => {\n    console.log(\"Button Clicked!\")\n})\n</code></pre>\n<blockquote>\n<p>We needed to add ! after querySelector (to tell to Typescript that this button WILL exist).</p>\n</blockquote>\n<blockquote>\n<p>Typescript does not complain for example about if the (HTML) document even exists, or if there is property like querySelector or addEventListener, etc. It does not complain becaise lib is commented out, and our target is es5 or es6. But in theory our application maybe is not for browsers, maybe it is a node.js application. Leaving lib empty is recommended.</p>\n</blockquote>\n<blockquote>\n<p>If we uncomment lib and leave the array empty, then we override defaults and the libraries are empty, which means now we get all sorts of array, that typescript does not reckognize document, or even console.log, toString, Array&#x3C;>, etc.</p>\n</blockquote>\n<blockquote>\n<p>If we uncomment lib, then we should add custom libraries to our tsconfig.json file which would overwrite defaults. If you hit CTRL+SPACE you get auto-completion and see list of options. For our Javascript project we would need:</p>\n</blockquote>\n<pre><code>     \"lib\": [\n       \"DOM\",\n       \"ES6\",\n       \"DOM.Iterable\",\n       \"ScriptHost\"\n     ],\n</code></pre>\n<blockquote>\n<p>But above is equivalent if we leave it empty becasue then defaults are assumed based on our es6 target.</p>\n</blockquote>\n<pre><code>\"lib\": [],\n</code></pre>\n<h3>allowJS and checkJS</h3>\n<blockquote>\n<p>This option allows Javascript files to be compiled. AllowJS will compile .js files. CheckJS will still check syntax of .js files, but it will not compile them. But it does not make sense if you have both .ts and .js files becaue then it will leave to double-compilation. This could be however used in projects where we dont have Typescript at all, but we still want to check .js files.</p>\n</blockquote>\n<h3>JSX</h3>\n<blockquote>\n<p>This is relevant only for React projects. It specifies what JSX code is generated.</p>\n</blockquote>\n<h3>sourceMap</h3>\n<p><img src=\"https://i.imgur.com/fNmTHCH.jpg\" title=\"Photo by Pixabay from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Pixabay from Pexels</em></p></p>\n<blockquote>\n<p>Source Map helps with debugging and development. You can see .js files from your project in the browser -> developer tools (or CTRL+SHIFT+i)->Sources</p>\n</blockquote>\n<blockquote>\n<p>However, we only see the js files, not our ts files. Source map if set to true, will create new files in the project folder: <code>app.js.map</code> which in browser will be translated as app.ts file. Which can be practical especially if we use some easy nice syntax in ts which would then be very complicated in js.</p>\n</blockquote>\n<pre><code>\"sourceMap\": true,\n</code></pre>\n<blockquote>\n<p>In the sources we will see our code and also we will be able to put cursor in a specific line of the code and stop then execution of the code there. Which is good for debugging (like adding <code>debugger</code> in the code). But this is only done in browser and we are not polluting our code in reality.</p>\n</blockquote>\n<h3>outDir and rootDir</h3>\n<blockquote>\n<p>These help us in bigger projects to organize the folder structure. Usually we will not want to have all files laying around in the project root folder. A typical project will want to have a <code>src</code> and <code>dist</code> subfolders. <code>dist</code> usually holds all output files (like the javascript files) and <code>src</code> might hold all typescript files.</p>\n</blockquote>\n<blockquote>\n<p>By default Typescript will compile the Typescript files into Javascript files and put them right next to Typescript files.</p>\n</blockquote>\n<blockquote>\n<p>With <code>outDir</code> we can tell Typescript where output (Javascript) files will be stored, for example in <code>dist</code> folder:</p>\n</blockquote>\n<pre><code>\"outDir\": \"./dist\",\n</code></pre>\n<blockquote>\n<p>While our .ts files might reside in <code>src</code> folder.</p>\n</blockquote>\n<blockquote>\n<p>Please note that then you also need to adpat <code>index.html</code> file to point to the .js files in dist folder:</p>\n</blockquote>\n<pre><code>&#x3C;script src=\"dist/app.js\" defer>&#x3C;/script>\n&#x3C;script src=\"dist/analytics.js\" defer>&#x3C;/script>\n</code></pre>\n<blockquote>\n<p>You will also need to adapt <code>tsconfig.json</code> file in case you have include and you will need to add new parth to the files:</p>\n</blockquote>\n<pre><code>\"include\": [\n    \"src/app.ts\",\n    \"src/analytics.ts\"\n]\n</code></pre>\n<blockquote>\n<p>Also if we had subfolder structure in the <code>src</code> folder, this will be replicated in the <code>dist</code> folder.</p>\n</blockquote>\n<blockquote>\n<p>With <code>rootDir</code> I can set Typescript to only read files from this folder. It is equivalent if we used <code>include</code>.</p>\n</blockquote>\n<pre><code>\"rootDir\": \"./src\",\n</code></pre>\n<blockquote>\n<p>The difference however is that <code>rootDir</code> will also make sure that <code>outDir</code> will replicate folder structure of the <code>rootDir</code></p>\n</blockquote>\n<blockquote>\n<p>Often we set both <code>outDir</code> and <code>rootDir</code></p>\n</blockquote>\n<h3>removeComments</h3>\n<blockquote>\n<p>Any comments in the <code>.ts</code> file will be ignored in the <code>.js</code> file:</p>\n</blockquote>\n<pre><code>\"removeComments\": true,\n</code></pre>\n<h3>noEmit</h3>\n<blockquote>\n<p><code>noEmit</code> setting will make sure no <code>.js</code> files are produced (for example if I only want to check my files)</p>\n</blockquote>\n<pre><code>\"noEmitOnError\": true,\n</code></pre>\n<blockquote>\n<p>There is another one <code>noEmitOnError</code> which makes sure no <code>.js</code> file is produced if there was a compilation error. It is enought that in one file there is an error and no <code>js</code> files will be generated.</p>\n</blockquote>\n<pre><code>\"noEmitOnError\": true,\n</code></pre>\n<h3>Strict</h3>\n<blockquote>\n<p>This enables all strict type-checking options</p>\n</blockquote>\n<blockquote>\n<p>We can set strict to true, which will be equivalent to enabling all the rest of strict options to true:</p>\n</blockquote>\n<pre><code>\"strict\": true,\n</code></pre>\n<blockquote>\n<p>is the same as:</p>\n</blockquote>\n<pre><code>\"noImplicitAny\": true,\n\"strictNullChecks\": true,\n\"strictFunctionTypes\": true,\n\"strictBindCallApply\": true,\n\"strictPropertyInitialization\": true,\n\"noImplicitThis\": true,\n\"alwaysStrict\": true,\n</code></pre>\n<blockquote>\n<p><code>noImplicitAny</code> will always throw error if a parameter of a function is implied by Typescript to be of ANY type (which we should avoid). It forces us to be specific about what data we expect. For variables, it does not complain.</p>\n</blockquote>\n<pre><code>\"strictNullChecks\": true,\n</code></pre>\n<blockquote>\n<p><code>strictNullChecks</code> is checking if the objects we try to access actually exist. So for our button, we needed to add <code>!</code>after the querySelector, because otherwise Typescript would complain that it is not sure if that selector exists. It is because of this option. If it is true, it throws such errors to notify if some element might be null / might not exist.</p>\n</blockquote>\n<pre><code>\"strictNullChecks\": true,\n</code></pre>\n<h3>noUnused...</h3>\n<blockquote>\n<p><code>noUnusedLocals</code> will ensure we dont have unused variables in the file. FOllowing code with throw an error, because user1 is defined but never used:</p>\n</blockquote>\n<pre><code>const adding = (a1: number, a2: number) => {\n  const user1 = 'mia'\n  return a1+a2;\n};\n</code></pre>\n<blockquote>\n<p>However. this one checks block scoped variables. The global variables are allowed not being used in a file because maybe they are used in another file. SO this code will not throw an error for user2, it will only throw error for user1:</p>\n</blockquote>\n<pre><code>const user2 = \"addania\";\n\nconst adding = (a1: number, a2: number) => {\n  const user1 = \"mia\";\n  return a1 + a2;\n};\n</code></pre>\n<blockquote>\n<p><code>noUnusedParameters</code> will ensure that all parameters of the function are used in the body of the function. Following code will throw an error cause a2 is not used. Error will read: <code>a2 is declared but its value is never read</code>.</p>\n</blockquote>\n<pre><code>const adding = (a1: number, a2: number) => {\n  return a1;\n};\n</code></pre>\n<h3>noImplicitReturns</h3>\n<blockquote>\n<p>This is also an important setting. It makes sure that our functions cover all branches and return something under all circumstances.</p>\n</blockquote>\n<blockquote>\n<p>Following function only return something when addition is more then a zero. But it does not cover cases when it it zero and less. So not all paths are covered and we will be warned with the message: <code>No all code pathes return a value</code>.</p>\n</blockquote>\n<pre><code>const adding = (a1: number, a2: number) => {\n  if (a1 + a2 > 0) {\n    return a1 + a2;\n  }\n};\n</code></pre>\n<blockquote>\n<p>We need to add final return, even if it does not return anything to fix this error:</p>\n</blockquote>\n<pre><code>const adding = (a1: number, a2: number) => {\n  if (a1 + a2 > 0) {\n    return a1 + a2;\n  }\n  return;\n};\n</code></pre>\n<h2>Syntax:</h2>\n<p><img src=\"https://i.imgur.com/equqbFL.jpg\" title=\"Photo by Miguel Constantin Montes from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Miguel Constantin Montes from Pexels</em></p></p>\n<blockquote>\n<p><code>!</code> means I am sure my element with certain ID will always be there in the <code>.html</code> file because I checked that id:</p>\n</blockquote>\n<pre><code>const input1 = document.getElementById(\"num1\")!;\n</code></pre>\n<blockquote>\n<p>A cleaner way how to work aroudn this error is to have a run-time check if the button exists with and if statement:</p>\n</blockquote>\n<pre><code>const button = document.getQuerySelector(\"button\")\nif (button) {\n  button.addEventListener(\"click\", () => {\n    console.log(\"clicked\"\n  )})\n}\n</code></pre>\n<blockquote>\n<p><code>as HTMLInputElement</code> means TYPECASTING which says what kind of element it will be, in following case it will be an input element:</p>\n</blockquote>\n<pre><code>const input1 = document.getElementById(\"num1\")! as HTMLInputElement;\n</code></pre>\n<h2>Typescript Next Generation Features</h2>\n<blockquote>\n<p>Typescript does not only allow creating types and compiles the code. It also allows using some next generation Javascript (introduced with ES6) and new features and makes it easier to write your code - modern syntax. It does not stop there, if you use modern javascript syntax and want to compile the code to older version like <code>\"target\": \"es5\"</code> in the tsconfig.json, then it will compile your shiny modern code to the older javascript with workarounds so that it can be run on older browsers.</p>\n</blockquote>\n<h3>let and const</h3>\n<blockquote>\n<p>Modern Javascript features allow to define <code>const</code> which will not change and <code>let</code> which can change.</p>\n</blockquote>\n<blockquote>\n<p>We cannot re-assign new value to const, while we can do it for let. If we try to re-assign a constant, we get a typescript error. In the browser we would also get an runtime error:</p>\n</blockquote>\n<pre><code>const user = \"mia\"\nuser = \"addania\"\n</code></pre>\n<blockquote>\n<p>We can still use <code>var</code> as before, which allows to re-assign values. We should not use <code>var</code> not anymore.</p>\n</blockquote>\n<blockquote>\n<p><code>let</code> and <code>const</code> have one important difference to var regarding the scope in which they are available.</p>\n</blockquote>\n<blockquote>\n<p><code>var</code> has a global and function scope. Function scope means that var is only available within the function itself, but outside of the function all variables are global - available in our file.</p>\n</blockquote>\n<blockquote>\n<p>But these two scopes are not the only scopes. There are other scopes like in if statements.</p>\n</blockquote>\n<pre><code>const user2 = \"addania\";\nif (user2 === \"addania\") {\n  var b = 'i am be'\n}\nconsole.log(\"b\", b)\n</code></pre>\n<blockquote>\n<p>This would work with var in Javascript - like in a browser. Because var is not in the function, it will have global scope. Typescript will compail about it, warning us though, because it is not good code to write.</p>\n</blockquote>\n<blockquote>\n<p>This would not work with let and const. This would throw an error:</p>\n</blockquote>\n<pre><code>const user2 = \"addania\";\nif (user2 === \"addania\") {\n  let b = 'i am be'\n  let c = 'i am ci'\n}\nconsole.log(b, c)\n</code></pre>\n<blockquote>\n<p>let and const introduced new scope - block scope which is part of if statements, for loops, functions or even any snippet within curly braces - we can randomly add curly braces to the code and create a block scope:</p>\n</blockquote>\n<pre><code>{\n  const onlyAvailableHere = \"I'm VIP\"\n  let user\n}\n</code></pre>\n<h3>Arrow functions</h3>\n<blockquote>\n<p>Instead using function keyword:</p>\n</blockquote>\n<pre><code>function add(a: number, b: number) {\n  return a+b\n}\n</code></pre>\n<blockquote>\n<p>We can use arrow functions:</p>\n</blockquote>\n<pre><code>const add = (a: number, b: number) => {\n  return a+b\n}\n</code></pre>\n<blockquote>\n<p>Still possible like this:</p>\n</blockquote>\n<pre><code>const add = function(a: number, b: number){\n  return a+b\n}\n</code></pre>\n<blockquote>\n<p>Benefits of arrow functions:</p>\n</blockquote>\n<ul>\n<li>shorter syntax</li>\n<li>we can ommit <code>return</code> keyword: <code>const add = (a: number, b: number) => a+b</code> (called implicit return)</li>\n<li>we can omit parameter braces if we only have one parameter: <code>const double = a => a*2</code></li>\n</ul>\n<blockquote>\n<p>Please note, if we have no parameters, we need to use empty parenthesis <code>() =></code></p>\n</blockquote>\n<h3>Default function parameters</h3>\n<blockquote>\n<p>We can have a function with 2 parameters, but we can set a parameter to have a default value, if this value is not provided when the function is called. It is done using <code>=</code> sign:</p>\n</blockquote>\n<pre><code>const adding = (a1: number, a2: number = 0) => a1 + a2;\nconsole.log(\"addng with default: \", adding(5));\n</code></pre>\n<blockquote>\n<p>This only works if the parameter with the default value is the <strong>last one</strong>. This code below would not work / compile:</p>\n</blockquote>\n<pre><code>const adding = (a1: number = 1, a2: number) => a1 + a2;\nconsole.log(\"addng with default: \", adding(5));\n</code></pre>\n<blockquote>\n<p>If all arguments would have default value, then it would work:</p>\n</blockquote>\n<pre><code>const adding = (a1: number = 1, a2: number = 5) => a1 + a2;\nconsole.log(\"addng with default: \", adding());\n</code></pre>\n<blockquote>\n<p>Rule is, first declare parameters which are obligatory and only then parameters which are option and all need to have a default value set.</p>\n</blockquote>\n<h3>SPREAD OPERATOR</h3>\n<blockquote>\n<p>Spread operator is really useful to pull out elements of an array.</p>\n</blockquote>\n<pre><code>const hobbies = [\"yoga\", \"cross-fit\"];\nconst activeHobbies = ['hiking', ...hobbies]\n</code></pre>\n<blockquote>\n<p>...hobbies will not add whole hobbies array and add it to the activeHobbies array. Result will not be: ['hiking', [\"yoga\", \"cross-fit\"]]</p>\n</blockquote>\n<blockquote>\n<p>The result will be: [\"hiking2, \"yoga\", \"cross-fit\"]</p>\n</blockquote>\n<blockquote>\n<p>Spread operator will pull out individual values from the array.</p>\n</blockquote>\n<blockquote>\n<p>Another example:</p>\n</blockquote>\n<pre><code>activeHobbies.push(...hobbies)\n</code></pre>\n<blockquote>\n<p>Spread operator works also for objects. If we have <code>person</code> object and we declare a new constant copiedPerson and simply assign person to it like this:</p>\n</blockquote>\n<pre><code>const person = {\n  name: 'adda',\n}\nconst copiedPerson = person\n</code></pre>\n<blockquote>\n<p>Then we are only referencing this object. We do not create a new object with new memory address. We only create a new pointer which will point to the same memory address where person lives. This is important concept, because it can cause mutating existing objects which in React will NOT cause re-render.</p>\n</blockquote>\n<blockquote>\n<p>Spread operator will help to create a new object with new memory address and it will pull out all the key-value pairs from <code>person</code> and idd them to the completely brand new shiny object <code>copiedPerson</code></p>\n</blockquote>\n<pre><code>const person = {\n  name: 'adda',\n}\nconst copiedPerson = {...person}\n</code></pre>\n<blockquote>\n<p>Same goes for arrays. To create a new array from the old one:</p>\n</blockquote>\n<pre><code>const hobbies = [\"yoga\", \"cross-fit\"];\nconst activeHobbies = [...hobbies]\n</code></pre>\n<blockquote>\n<p>To create a new array of hobbies and want to add something more to it:</p>\n</blockquote>\n<pre><code>const hobbies = [\"yoga\", \"cross-fit\"];\nconst activeHobbies = [ ...hobbies, 'hiking',]\n</code></pre>\n<blockquote>\n<p>we can also change the order in case hiking should be first:</p>\n</blockquote>\n<pre><code>const hobbies = [\"yoga\", \"cross-fit\"];\nconst activeHobbies = ['hiking', ...hobbies]\n</code></pre>\n<h3>Rest operator</h3>\n<blockquote>\n<p>Imagine you want to create a function which will add unlimited amount of numbers. We do not know if it will be 2 or 10 or 1000. Rest parameter will help to create an array from the incoming parameters:</p>\n</blockquote>\n<pre><code>const addUnlimited = (...numbers: Array&#x3C;number>) => {\n  let total = 0;\n  numbers.forEach((num) => {\n    total = total + num;\n  });\n  return total;\n};\nconsole.log(\"unlimited\", addUnlimited(10, 20, 30, 40));\nconsole.log(\"unlimited\", addUnlimited(10, 20));\nconsole.log(\"unlimited\", addUnlimited());\n</code></pre>\n<blockquote>\n<p>Same example using reduce:</p>\n</blockquote>\n<pre><code>const addUnlimited2 = (...numbers: Array&#x3C;number>) => {\n  return numbers.reduce((currentResult, currentValue) => currentResult + currentValue, 0);\n};\nconsole.log(\"unlimited2\", addUnlimited(10, 20, 30, 40));\nconsole.log(\"unlimited2\", addUnlimited(10, 20));\nconsole.log(\"unlimited2\", addUnlimited());\n</code></pre>\n<blockquote>\n<p>If our function should accept exactly 5 numbers, then we can limit it by a typing is as a tupple instead of array of numbers.</p>\n</blockquote>\n<pre><code>const addUnlimited2 = (...numbers: [number, number, number, number, number]) => {\n  return numbers.reduce((currentResult, currentValue) => currentResult + currentValue, 0);\n};\n</code></pre>\n<h3>Array and Object descrtucturing</h3>\n<blockquote>\n<p>If we have an array and we want to extract its values into separate constants we can use array destructuring:</p>\n</blockquote>\n<pre><code>const hobbies = [\"yoga\", \"cross-fit\"];\nconst [ hobby1, hobby2 ] = hobbies\n</code></pre>\n<blockquote>\n<p>Destructure means you really pull emelents out of the array.</p>\n</blockquote>\n<blockquote>\n<p>We can even use rest parameters and store the rest of the values to a dedicated constant for example <code>other</code>. All remaining elements in the other will be an <strong>array</strong> of strings:</p>\n</blockquote>\n<pre><code>const hobbies = [\"yoga\", \"cross-fit\", \"hiking\", \"surfing\", \"diving\"];\nconst [ hobby1, hobby2, ...other ] = hobbies\n</code></pre>\n<blockquote>\n<p>Same works for objects. Here we take the person object and pull out all the key-value paris and assign first three to dedicated constants and the rest to the otherInfo const:</p>\n</blockquote>\n<pre><code>const human = {\n  firstName: \"mia\",\n  id: \"1\",\n  gender: \"female\",\n  age: 18,\n  nationality: undefined,\n};\nconst { firstName, id, gender, ...otherInfo } = human;\n</code></pre>\n<blockquote>\n<p>Please note that the constant names need to reflect the key names in the original object. Order does not matter, but the names do!</p>\n</blockquote>\n<blockquote>\n<p>If we wanted to overwrite those names, we put a colon there <code>:</code></p>\n</blockquote>\n<pre><code>const human = {\n  firstName: \"mia\",\n  id: \"1\",\n  gender: \"female\",\n  age: 18,\n  nationality: undefined,\n};\nconst { firstName: randomName, id, gender, ...otherInfo } = human;\n</code></pre>\n<h2>Best practises tips:</h2>\n<p><img src=\"https://i.imgur.com/VDxi6vE.jpg\" title=\"Photo by Porapak Apichodilok from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Porapak Apichodilok from Pexels</em></p></p>\n<blockquote>\n<p><strong>Do not ignore</strong></p>\n</blockquote>\n<p>Do not use <code>@ts-ignore</code>. It turns off the compiler completely from the next line and prevents from spotting type errors</p>\n<blockquote>\n<p><strong>Do not use React.FunctionComponent</strong>\nEee:</p>\n</blockquote>\n<pre><code>type Props = { foo: string }\nconst Foo: React.FunctionComponent&#x3C;Props> = ({ foo }) => &#x3C;div>{foo}&#x3C;/div>\n</code></pre>\n<p>Approved:</p>\n<pre><code>const Foo = ({ foo }: Props) => &#x3C;div>{foo}&#x3C;/div>\n</code></pre>\n<blockquote>\n<p><strong>Do not use enums</strong></p>\n</blockquote>\n<p>Nein:</p>\n<pre><code>enum Direction { Up, Down, Left, Right}\n</code></pre>\n<p>Jaaaa:</p>\n<pre><code>type Direction = \"up\" | \"down\" | \"left\" | \"right\"\n</code></pre>\n<blockquote>\n<p><strong>Do not use wide types like object or any</strong></p>\n</blockquote>\n<p>Always try to find concrete types</p>\n<p><img src=\"https://i.imgur.com/ob6G3qI.jpg\" title=\"Photo by Pixabay from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Pixabay from Pexels</em></p></p>\n<p><strong>Intersection types</strong></p>\n<p><img src=\"https://i.imgur.com/KlTaZzV.png\" title=\"Photo by Deva Darshan from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Deva Darshan from Pexels</em></p></p>\n<blockquote>\n<p>Intersection types allow us to combine other types</p>\n</blockquote>\n<blockquote>\n<p>Imagine we have a following types:</p>\n</blockquote>\n<pre><code>type Admin = {\n  name: string;\n  privileges: Array&#x3C;string>\n}\n\ntype Employee = {\n  name: string;\n  startDate: Date;\n}\n</code></pre>\n<blockquote>\n<p>What if I want to combine these two objects to a new type <code>ElevatedEmployee</code> which should contain all of above? Of course we could create a new type and define it manually:</p>\n</blockquote>\n<pre><code>type ElevatedEmployee = {\n  name: string;\n  startDate: Data;\n  priviledges: Array&#x3C;string>\n}\n</code></pre>\n<blockquote>\n<p>But since we already have a type for Admin and for Employee, we can combine them and create a new type based on them. This will also allow us to have one source of truth. IN order to define an intersection type, weuse <code>ampersand</code> symbol.</p>\n</blockquote>\n<pre><code>type ElevatedEmployee = Admin &#x26; Employee;\nconst david: ElevatedEmployee = {\n  name: \"Dave\",\n  privileges: [],\n  startDate: new Date(),\n}\n</code></pre>\n<blockquote>\n<p>We could also achieve this with interfaces:</p>\n</blockquote>\n<pre><code>interface Admin {\n  name: string;\n  privileges: Array&#x3C;string>;\n}\n\ninterface Employee {\n  name: string;\n  startDate: Date;\n}\n\ninterface ElevatedEmployee extends Admin, Employee {}\n\nconst david: ElevatedEmployee = {\n  name: \"Dave\",\n  privileges: [],\n  startDate: new Date(),\n};\n</code></pre>\n<blockquote>\n<p>Intersection can be used for any types, not only objects:</p>\n</blockquote>\n<pre><code>type Combinable = string | number\ntype Calculatable = number | boolean\ntype Universal = Combinable &#x26; Calculatable\n</code></pre>\n<blockquote>\n<p>As a result Universal type will be of a type number, because number is the only <code>intersection</code> between (string or number) and (number or boolean).</p>\n</blockquote>\n<blockquote>\n<p>Why is that? Simply because of the way intersections are implemented. Intersections of union types will result in whatever is common for both union types. Intersection of object will result in combination of all its objects.</p>\n</blockquote>\n<p><strong>Type guards</strong></p>\n<p><img src=\"https://i.imgur.com/NYjRWPJ.png\" title=\"Photo by Mike from Pexels\"><p style=\"font-size: 12px; text-align: right\"><em>Photo by Mike from Pexels</em></p></p>\n<blockquote>\n<p>Type guards help us with union types. Because we need to know which exact type we are getting at run time.</p>\n</blockquote>\n<p><strong>a) typeof type guard</strong></p>\n<blockquote>\n<p>Imagine a function which can get Combinable parameters - strings or numbers. In order to process those numbers correctly, we need to have a logic which distinguished between strings and numbers. When those are strings or at least one of them is a string, we concatenate them. If both are numbers then we add them up:</p>\n</blockquote>\n<pre><code>type Combinable = string | number;\n\nconst addUp = (a: Combinable, b: Combinable) => {\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return a.toString() + b.toString();\n  }\n  return a + b;\n};\n\nconsole.log(\"strings: \", addUp(\"m\", \"n\"));\nconsole.log(\"numbers: \", addUp(1, 2));\nconsole.log(\"string &#x26; number: \", addUp(\"m\", 1));\n</code></pre>\n<blockquote>\n<p><code>if (typeof a === \"string\" || typeof b === \"string\") {...}</code> is called a type guard. It allows us to use the flexibility of the union type gives us, bubt still ensures that our code runs correctly at run time.</p>\n</blockquote>\n<p><strong>b) typeof type guard</strong></p>\n<p><strong>Interfaces</strong></p>\n<blockquote>\n<p>They represent objects! type can represent anything, interface only object</p>\n</blockquote>\n<pre><code>interface Adda {\n  name: string,\n  nick: string,\n  age: number\n}\n</code></pre>\n<blockquote>\n<p>It is matter of custom. Whichever I choose I should be consistent.</p>\n</blockquote>\n<p><strong>Alias</strong></p>\n<blockquote>\n<p>Is when we extract our own type:</p>\n</blockquote>\n<pre><code>type User = {\n  id: string,\n  age: number\n}\n</code></pre>\n<p><strong>Promises</strong></p>\n<blockquote>\n<p>How to type a promise from an api? Use <code>Promise&#x3C;></code></p>\n</blockquote>\n<pre><code>interface LukeSkywalker {\n  name: string;\n  height: string;\n  mass: string;\n  hair_color: string;\n  skin_color: string;\n  eye_color: string;\n  birth_year: string;\n  gender: string;\n}\n\nexport const fetchLukeSkywalker = async (): Promise&#x3C;LukeSkywalker> => {\n  const data = await fetch(\"https://swapi.dev/api/people/1\").then((res) => {\n    return res.json();\n  });\n\n  return data;\n};\n</code></pre>\n<blockquote>\n<p>Another possibility is to use casting -> with word <code>as</code>. We can cast data to LukeSkywalker.</p>\n</blockquote>\n<pre><code>interface LukeSkywalker {\n  name: string;\n  height: string;\n  mass: string;\n  hair_color: string;\n  skin_color: string;\n  eye_color: string;\n  birth_year: string;\n  gender: string;\n}\n\nexport const fetchLukeSkywalker = async () => {\n  const data = await fetch(\"https://swapi.dev/api/people/1\").then((res) => {\n    return res.json();\n  });\n\n  return data as LukeSkywalker;\n};\n</code></pre>\n<p><strong>Sets</strong></p>\n<blockquote>\n<p>Sets are collections of values. A value in the Set may only occur once; it is unique in the Set's collection.</p>\n</blockquote>\n<pre><code>const guitarists = new Set();\n</code></pre>\n<blockquote>\n<p>How to type sets?</p>\n</blockquote>\n<pre><code>const guitarists = new Set&#x3C;string>();\n</code></pre>\n<p><strong>Objects with variables as keys</strong></p>\n<blockquote>\n<p>How to type objects which can have a variable as a key to avoid errors such as? No index signature with a parameter of type 'string' was found on type '{}'</p>\n</blockquote>\n<blockquote>\n<p>In this case the index is refering to the key of the object. Any such TS errors about index usually refer to the key of object (unless you work with arrays).</p>\n</blockquote>\n<blockquote>\n<p>First solution</p>\n</blockquote>\n<pre><code>const createCache = () => {\n  const cache = {};\n\n  const add = (id: string, value: string) => {\n    cache[id] = value;\n  };\n\n  return {\n    cache,\n    add,\n  };\n};\n</code></pre>\n<blockquote>\n<p>There are couple of ways how to type such an object:</p>\n</blockquote>\n<pre><code>const cache: {\n    [id: string]: string;\n    } = {};\n</code></pre>\n<blockquote>\n<p>In above example I can use also any other key, not only id. I can use index, or any other work (k, n):</p>\n</blockquote>\n<pre><code>const cache: {\n    [index: string]: string;\n    } = {};\n</code></pre>\n<blockquote>\n<p>Or:</p>\n</blockquote>\n<pre><code>const cache: {\n    [k: string]: string;\n    } = {};\n</code></pre>\n<blockquote>\n<p>This [k: string] inside of a type is called index signature.</p>\n</blockquote>\n<blockquote>\n<p>Another approach is to use interface:</p>\n</blockquote>\n<pre><code>interface Cache {\n  [id: string]: string;\n}\n</code></pre>\n<blockquote>\n<p>Or even using Record. Record allows to add any number of keys to that object at runtime.</p>\n</blockquote>\n<pre><code> const cache: Record&#x3C;string, string> = {};\n</code></pre>\n<p><strong>Typing catch errors</strong></p>\n<blockquote>\n<p>In javascript for each try block, we can only have 1 catch block</p>\n</blockquote>\n<blockquote>\n<p>We can throw any error:</p>\n</blockquote>\n<pre><code>throw 'What the!?'\nthrow 7\nthrow {wut: 'is this'}\nthrow null\nthrow new Promise(() => {})\nthrow undefined\n</code></pre>\n<blockquote>\n<p>Now imagine a situation like this:</p>\n</blockquote>\n<pre><code>const tryCatchDemo = (state: \"fail\" | \"succeed\") => {\n  try {\n    if (state === \"fail\") {\n      throw new Error(\"Failure!\");\n    }\n  } catch (e) {\n      return e.message;\n    }\n};\n</code></pre>\n<blockquote>\n<p>TS will yell at us that: 'e' is of type 'unknown' and we want to access message on the e.</p>\n</blockquote>\n<blockquote>\n<p>If we try to type \"e\" directly, it will yell that: Catch clause variable type annotation must be 'any' or 'unknown' if specified.</p>\n</blockquote>\n<pre><code>const tryCatchDemo = (state: \"fail\" | \"succeed\") => {\n  try {\n    if (state === \"fail\") {\n      throw new Error(\"Failure!\");\n    }\n  } catch (e: Error) {\n      return e.message;\n    }\n};\n</code></pre>\n<blockquote>\n<p>One way to fix this is:</p>\n</blockquote>\n<pre><code>const tryCatchDemo = (state: \"fail\" | \"succeed\") => {\n  try {\n    if (state === \"fail\") {\n      throw new Error(\"Failure!\");\n    }\n  } catch (e) {\n    if(e instanceof Error){return e.message;}\n    }\n};\n</code></pre>\n<p><strong>Extending interface</strong></p>\n<blockquote>\n<p>A reminder: interface is a type for objects. type can be anything, but interface can only be object.</p>\n</blockquote>\n<blockquote>\n<p>Look at the code below, it has a duplication of id everywhere:</p>\n</blockquote>\n<pre><code>interface User {\n  id: string;\n  firstName: string;\n  lastName: string;\n}\n\ninterface Post {\n  id: string;\n  title: string;\n  body: string;\n}\n</code></pre>\n<blockquote>\n<p>How can we avoid duplication? We can create Id Interface and extend the User and Post with Id.</p>\n</blockquote>\n<pre><code>interface Id {\n  id: string\n}\n\ninterface User extends Id {\n  firstName: string;\n  lastName: string;\n}\n\ninterface Post extends Id {\n  title: string;\n  body: string;\n}\n</code></pre>\n<blockquote>\n<p>Please note that extends is only available for interfaces, and not for types.</p>\n</blockquote>\n<blockquote>\n<p>Why is it usefull? If I change my mind and I want id to be number, I can then only change it in one place instead of multiple.</p>\n</blockquote>\n<blockquote>\n<p>we can use extends with more items:</p>\n</blockquote>\n<pre><code>interface Post extends Id, User {\n    title: string;\n  body: string;\n}\n</code></pre>\n<p><strong>Object intersection</strong></p>\n<blockquote>\n<p>This combines objects. Imagine we have a scenario like this:</p>\n</blockquote>\n<pre><code>interface User {\n  id: string;\n  firstName: string;\n  lastName: string;\n}\n\ninterface Post {\n  title: string;\n  body: string;\n}\nexport const getDefaultUserAndPosts = (): unknown => {\n  return {\n    id: \"1\",\n    firstName: \"Matt\",\n    lastName: \"Pocock\",\n    posts: [\n      {\n        title: \"How I eat so much cheese\",\n        body: \"It's pretty edam difficult\",\n      },\n    ],\n  };\n};\n</code></pre>\n<blockquote>\n<p>How do we type this return statement instead of unknown so it's both User AND { posts: Post[] }?</p>\n</blockquote>\n<blockquote>\n<p>We can do it like this:</p>\n</blockquote>\n<pre><code>interface User {\n  id: string;\n  firstName: string;\n  lastName: string;\n}\n\ninterface Post {\n  title: string;\n  body: string;\n}\nexport const getDefaultUserAndPosts = (): User &#x26; { posts: Array&#x3C;Post> } => {\n  return {\n    id: \"1\",\n    firstName: \"Matt\",\n    lastName: \"Pocock\",\n    posts: [\n      {\n        title: \"How I eat so much cheese\",\n        body: \"It's pretty edam difficult\",\n      },\n    ],\n  };\n};\n</code></pre>\n<blockquote>\n<p>This little operator &#x26; is called intersection and it allows us to combine types. (While extends allows for inheritance)</p>\n</blockquote>\n<blockquote>\n<p>We can intersect more things: User &#x26; { posts: Array<Post> } &#x26; { age: number }</p>\n</blockquote>\n<p><strong>Pick</strong></p>\n<blockquote>\n<p>What if we have a type like this:</p>\n</blockquote>\n<pre><code>interface User {\n  id: string;\n  firstName: string;\n  lastName: string;\n}\n</code></pre>\n<blockquote>\n<p>and we want to create a new type which will contain everything except for id?\nWe can use omit to do that:</p>\n</blockquote>\n<pre><code>type MyType = Omit&#x3C;User, \"id\">\n</code></pre>\n<blockquote>\n<p>We can omit multiple items:</p>\n</blockquote>\n<pre><code>type MyType = Omit&#x3C;User, \"id\", \"firstName\">\n</code></pre>\n<p><strong>Pick</strong></p>\n<blockquote>\n<p>Maybe we want to only get 1 single property form already defined type.</p>\n</blockquote>\n<blockquote>\n<p>Image we only want property lastName from User:</p>\n</blockquote>\n<pre><code>interface User {\n  id: string;\n  firstName: string;\n  lastName: string;\n}\n</code></pre>\n<blockquote>\n<p>We can then use pick utility in TS to do so:</p>\n</blockquote>\n<pre><code>type MyType = Pick&#x3C;User, \"lastName\">\n</code></pre>\n<p><strong>Typing Asynch functions</strong></p>\n<blockquote>\n<p>Imagine you have a situation like this:</p>\n</blockquote>\n<pre><code>interface User {\n  id: string;\n  lastName: string;\n}\n\nconst createThenGetUser = async (\n  createUser: unknown,\n  getUser: unknown,\n): Promise&#x3C;User> => {\n  const userId: string = await createUser();\n  const user = await getUser(userId);\n  return user;\n};\n</code></pre>\n<blockquote>\n<p>You want to replace unknowns with proper type:</p>\n</blockquote>\n<pre><code>interface User {\n  id: string;\n  lastName: string;\n}\n\nconst createThenGetUser = async (\n  createUser: () => Promise&#x3C;string>,\n  getUser: (id: string) => Promise&#x3C;User>\n): Promise&#x3C;User> => {\n  const userId: string = await createUser();\n  const user = await getUser(userId);\n  return user;\n};\n</code></pre>\n<p><strong>Return type of function</strong></p>\n<blockquote>\n<p>How can we say to TS to take the type from a return statement of a function?</p>\n</blockquote>\n<pre><code>const myFunc = () => {\n  return 123;\n};\n</code></pre>\n<blockquote>\n<p>We can use ReturnType helper and typeof</p>\n</blockquote>\n<pre><code>type MyFuncReturn = ReturnType&#x3C;typeof myFunc>;\n</code></pre>\n<p><strong>Arguments type of function</strong></p>\n<blockquote>\n<p>How can we say to TS to take the type from arguments of a function?</p>\n</blockquote>\n<pre><code>function sum(a: number, b: string): string {\n  return a + b;\n}\n</code></pre>\n<blockquote>\n<p>We want a type called SumParams which will be [a: number, b: string]. We will use helper Parameters for if and it will return us a tuple.</p>\n</blockquote>\n<pre><code>type SumParams = Parameters&#x3C;typeof sum>;\n</code></pre>\n<blockquote>\n<p>type FirstParam will be number</p>\n</blockquote>\n<pre><code>type FirstParam = SumParams[0];\n</code></pre>\n<blockquote>\n<p>type SecondParam will be string</p>\n</blockquote>\n<pre><code>type SecondParam = SumParams[1];\n</code></pre>\n<blockquote>\n<p>This is useful to type stuff which is not in my control, for example from 3rd party libraries</p>\n</blockquote>\n<p><strong>Awaited</strong></p>\n<blockquote>\n<p>What if we have an asynch function which returns a promise, but we want to extract a type from it without the Promise.</p>\n</blockquote>\n<pre><code>type A = Promise&#x3C;string>;\n</code></pre>\n<blockquote>\n<p>Awaited helps us to unwrap the promise</p>\n</blockquote>\n<pre><code>type B = Awaited&#x3C;A> // string\n</code></pre>\n<p><strong>Extracting keys from an object</strong></p>\n<blockquote>\n<p>Imagine we have an object like this:</p>\n</blockquote>\n<pre><code>const testingFrameworks = {\n  vitest: {\n    label: \"Vitest\",\n  },\n  jest: {\n    label: \"Jest\",\n  },\n  mocha: {\n    label: \"Mocha\",\n  },\n};\n</code></pre>\n<blockquote>\n<p>And we want to extract a union type of its keys: \"vitest\" | \"jest\" | \"mocha\"</p>\n</blockquote>\n<blockquote>\n<p>We will use keyof typeof for this:</p>\n</blockquote>\n<pre><code>type TestingFramework = keyof typeof testingFrameworks;\n</code></pre>\n<p><strong>Union, Discriminated union and Enum</strong></p>\n<blockquote>\n<p>What is difference between Union, Discriminated union and Enum</p>\n</blockquote>\n<blockquote>\n<p>A is a discriminated union, with 'type' as the discriminator. Discriminated unions have common properties which are used to differentiate between members of the union. In this case, type is the discriminator.</p>\n</blockquote>\n<pre><code>type A =\n  | {\n      type: \"a\";\n      a: string;\n    }\n  | {\n      type: \"b\";\n      b: string;\n    }\n  | {\n      type: \"c\";\n      c: string;\n    };\n</code></pre>\n<blockquote>\n<p>B is a union, but not a discriminated union.</p>\n</blockquote>\n<pre><code>type B = \"a\" | \"b\" | \"c\";\n</code></pre>\n<blockquote>\n<p>C is an enum.</p>\n</blockquote>\n<pre><code>enum C {\n  A = \"a\",\n  B = \"b\",\n  C = \"c\",\n}\n</code></pre>\n<p><strong>Extract</strong></p>\n<blockquote>\n<p>Now how can we extract one piece of info from discriminated union? Imagine we have a disc. union of type A:</p>\n</blockquote>\n<pre><code>type A =\n  | {\n      type: \"a\";\n      a: string;\n    }\n  | {\n      type: \"b\";\n      b: string;\n    }\n  | {\n      type: \"c\";\n      c: string;\n    };\n</code></pre>\n<blockquote>\n<p>and we want to extract such a type for \"a\":</p>\n</blockquote>\n<pre><code>type Extracted = Extract&#x3C;A, { type: 'a' }>\n</code></pre>\n<blockquote>\n<p>Extract is a type helper and super useful. Another example:</p>\n</blockquote>\n<pre><code>export type Event =\n  | {\n      type: \"click\";\n      event: MouseEvent;\n    }\n  | {\n      type: \"focus\";\n      event: FocusEvent;\n    }\n  | {\n      type: \"keydown\";\n      event: KeyboardEvent;\n    };\n\ntype ClickEvent = Extract&#x3C;Event, { type: \"click\" }>;\n</code></pre>\n<blockquote>\n<p>We can also grab event, or any other property:</p>\n</blockquote>\n<pre><code>type FocussEvent = Extract&#x3C;Event, { event: KeyboardEvent }>\n</code></pre>\n<blockquote>\n<p>It also work not only on objects but also on unions, etc</p>\n</blockquote>\n<pre><code>type Fruit = \"apple\" | \"banana\" | \"orange\"\ntype Exotic = Extract&#x3C;Fruit, \"banana\" | \"orange\">\n</code></pre>\n<p><strong><em>Exclude</em></strong></p>\n<blockquote>\n<p>It is reverse of Extract. It is useful for discriminated unions. It specifies which property you dont want:</p>\n</blockquote>\n<pre><code>export type Event =\n  | {\n      type: \"click\";\n      event: MouseEvent;\n    }\n  | {\n      type: \"focus\";\n      event: FocusEvent;\n    }\n  | {\n      type: \"keydown\";\n      event: KeyboardEvent;\n    };\n\ntype NonKeyDownEvents = Exclude&#x3C;Event, { type: \"keydown\" }>;\n</code></pre>\n<p><strong>Indexed access type - Object values of keys</strong></p>\n<blockquote>\n<p>What if I have an object like this:</p>\n</blockquote>\n<pre><code>const fakeDataDefaults = {\n  String: \"Default string\",\n  Int: 1,\n  Float: 1.14,\n  Boolean: true,\n  ID: \"id\",\n};\n</code></pre>\n<blockquote>\n<p>And I want to extract the type for a specific key?</p>\n</blockquote>\n<pre><code>type StringType = typeof fakeDataDefaults[\"String\"];\ntype IntType = typeof fakeDataDefaults[\"Int\"];\ntype FloatType = typeof fakeDataDefaults[\"Float\"];\ntype BooleanType = typeof fakeDataDefaults[\"Boolean\"];\ntype IDType = typeof fakeDataDefaults[\"ID\"];\n</code></pre>\n<blockquote>\n<p>Or alternatively:</p>\n</blockquote>\n<pre><code>type FakeDataDefaults = typeof fakeDataDefaults;\n\ntype StringType = FakeDataDefaults[\"String\"];\ntype IntType = FakeDataDefaults[\"Int\"];\ntype FloatType = FakeDataDefaults[\"Float\"];\ntype BooleanType = FakeDataDefaults[\"Boolean\"];\ntype IDType = FakeDataDefaults[\"ID\"];\n</code></pre>\n<blockquote>\n<p>We can even access object inside objecz on this way:</p>\n</blockquote>\n<pre><code>const fakeData = {\n  String: \"Default string\",\n  Int: 1,\n  Float: 1.14,\n  Boolean: true,\n  ID: {\n    job: \"driver\"\n  },\n};\n\ntype Job = typeof fakeData[\"ID\"][\"job\"]\n</code></pre>\n<p><strong>Accessing prop on discriminated union</strong></p>\n<blockquote>\n<p>If I have an object like this::</p>\n</blockquote>\n<pre><code>type Event =\n  | {\n      type: \"click\";\n      event: MouseEvent;\n    }\n  | {\n      type: \"focus\";\n      event: FocusEvent;\n    }\n  | {\n      type: \"keydown\";\n      event: KeyboardEvent;\n    };\n</code></pre>\n<blockquote>\n<p>and I want to extract a type from it of: \"click\" | \"focus\" | \"keydown\"?</p>\n</blockquote>\n<pre><code>type EventType = Event[\"type\"];\n</code></pre>\n<blockquote>\n<p>If you access a key on a union, you are accessing all permutations of that key.</p>\n</blockquote>\n<blockquote>\n<p>It would not work if one of the elements in the union would miss \"type\". It works well in discriminated unions using discriminators.</p>\n</blockquote>\n<p><strong>As const annotation</strong></p>\n<blockquote>\n<p>Imagine we enum like this:</p>\n</blockquote>\n<pre><code>const programModeEnumMap = {\n  GROUP: \"group\",\n  ANNOUNCEMENT: \"announcement\",\n  ONE_ON_ONE: \"1on1\",\n  SELF_DIRECTED: \"selfDirected\",\n  PLANNED_ONE_ON_ONE: \"planned1on1\",\n  PLANNED_SELF_DIRECTED: \"plannedSelfDirected\",\n};\n</code></pre>\n<blockquote>\n<p>We want to access the type on GROUP key:</p>\n</blockquote>\n<pre><code>type GroupProgram = typeof programModeEnumMap[\"GROUP\"]\n</code></pre>\n<blockquote>\n<p>But this resolves to string and not \"group\". Why? Because this enum can be altered. For example lik ethis:</p>\n</blockquote>\n<pre><code>programModeEnumMap.GROUP = \"party\"\n</code></pre>\n<blockquote>\n<p>This is mutable. So it must be typed as string.</p>\n</blockquote>\n<blockquote>\n<p>How can we make the programModeEnumMap to resolve to literal values instead of generic values?</p>\n</blockquote>\n<pre><code>const programModeEnumMap = {\n  GROUP: \"group\",\n  ANNOUNCEMENT: \"announcement\",\n  ONE_ON_ONE: \"1on1\",\n  SELF_DIRECTED: \"selfDirected\",\n  PLANNED_ONE_ON_ONE: \"planned1on1\",\n  PLANNED_SELF_DIRECTED: \"plannedSelfDirected\",\n} as const;\n</code></pre>\n<blockquote>\n<p>As const freezes values and makes them resolve to their literal types. It also adds readonly annotation to the enum as well. This means it turns it into immutable. Its values cannot be changed</p>\n</blockquote>\n<blockquote>\n<p>Same is true just for arrays. They are infered as array of numbers for example.</p>\n</blockquote>\n<pre><code>const myArr = [1,2,3]\ntype MyArr = typeof myArr // Array&#x3C;number>\n</code></pre>\n<blockquote>\n<p>Why? Because I can do:</p>\n</blockquote>\n<pre><code>myArr[0]\nmyArr.push(123)\n</code></pre>\n<blockquote>\n<p>But if I add as const to the array, I wont be able to modify the array</p>\n</blockquote>\n<pre><code>const myArr = [1, 2, 3] as const;\n</code></pre>\n<blockquote>\n<p>This array will be readonly and its type will be [1, 2, 3]</p>\n</blockquote>\n<blockquote>\n<p>Another way how to freeze an object is Object.freeze():</p>\n</blockquote>\n<pre><code>const programModeEnumMap = Object.freeze({\n  GROUP: \"group\",\n  ANNOUNCEMENT: \"announcement\",\n  ONE_ON_ONE: \"1on1\",\n  SELF_DIRECTED: \"selfDirected\",\n  PLANNED_ONE_ON_ONE: \"planned1on1\",\n  PLANNED_SELF_DIRECTED: \"plannedSelfDirected\",\n});\n</code></pre>\n<blockquote>\n<p>Object.freeze only works on the first level of object -> it does not go deeper. As const goes all the way down.</p>\n</blockquote>\n<p><strong>Indexed Access with Union</strong></p>\n<blockquote>\n<p>Imagine we have an object like this:</p>\n</blockquote>\n<pre><code>const programModeEnumMap = {\n  GROUP: \"group\",\n  ANNOUNCEMENT: \"announcement\",\n  ONE_ON_ONE: \"1on1\",\n  SELF_DIRECTED: \"selfDirected\",\n  PLANNED_ONE_ON_ONE: \"planned1on1\",\n  PLANNED_SELF_DIRECTED: \"plannedSelfDirected\",\n}\n</code></pre>\n<blockquote>\n<p>And we want to create a union of \"1on1\" | \"selfDirected\" | \"planned1on1\"</p>\n</blockquote>\n<blockquote>\n<p>One lame way to do it:</p>\n</blockquote>\n<pre><code>type Program = typeof programModeEnumMap;\nexport type IndividualProgram =\n  | Program[\"ONE_ON_ONE\"]\n  | Program[\"SELF_DIRECTED\"]\n  | Program[\"PLANNED_ONE_ON_ONE\"];\n</code></pre>\n<blockquote>\n<p>Better way is like this:</p>\n</blockquote>\n<pre><code>type Program = typeof programModeEnumMap;\nexport type IndividualProgram = Program[\"ONE_ON_ONE\" | \"SELF_DIRECTED\" | \"PLANNED_ONE_ON_ONE\"]\n</code></pre>\n<blockquote>\n<p>Notice that we can pass a union to the indexed access :)</p>\n</blockquote>\n<p><strong>Accessing types of object values</strong></p>\n<blockquote>\n<p>Imagine we have an object like this:</p>\n</blockquote>\n<pre><code>const frontendToBackendEnumMap = {\n  singleModule: \"SINGLE_MODULE\",\n  multiModule: \"MULTI_MODULE\",\n  sharedModule: \"SHARED_MODULE\",\n} as const;\n</code></pre>\n<blockquote>\n<p>And we want to infer type from the values as a union: \"SINGLE<em>MODULE\" | \"MULTI</em>MODULE\" | \"SHARED_MODULE\"</p>\n</blockquote>\n<blockquote>\n<p>We can do it like this:</p>\n</blockquote>\n<pre><code>type BackendModuleEnum =\n  typeof frontendToBackendEnumMap[keyof typeof frontendToBackendEnumMap];\n</code></pre>\n<blockquote>\n<p>We can make it nicer:</p>\n</blockquote>\n<pre><code>type Obj = typeof frontendToBackendEnumMap\ntype BackendModuleEnum = Obj[keyof Obj]\n</code></pre>\n<blockquote>\n<p>We coud achieve them same if we do this:</p>\n</blockquote>\n<pre><code>type   BackendModuleEnum = Obj[\"SINGLE_MODULE\" | \"MULTI_MODULE\" | \"SHARED_MODULE\"]\n</code></pre>\n<blockquote>\n<p>But in this case the type will not be up-to-date if anything changes</p>\n</blockquote>\n<p><strong>Creating union out of array</strong></p>\n<blockquote>\n<p>Imagine we have an array:</p>\n</blockquote>\n<pre><code>const fruits = [\"apple\", \"banana\", \"orange\"] as const;\n</code></pre>\n<blockquote>\n<p>And we want to get from there a union of \"apple\" | \"banana\":</p>\n</blockquote>\n<pre><code>type AppleOrBanana = typeof fruits[0 | 1];\n</code></pre>\n<blockquote>\n<p>What if we want union of all fruits? \"apple\" | \"banana\" | \"orange\"</p>\n</blockquote>\n<blockquote>\n<p>We can do it in a lame way like this:</p>\n</blockquote>\n<pre><code>type Fruit = typeof fruits[0 | 1 | 2];\n</code></pre>\n<blockquote>\n<p>More elegant though is:</p>\n</blockquote>\n<pre><code>type Fruit = typeof fruits[number];\n</code></pre>\n<blockquote>\n<p>The word number lets you access any member of the array, no matter how long it is</p>\n</blockquote>\n<p><strong>Template literals</strong></p>\n<blockquote>\n<p>Imagine we have a function which takes in an argument called route of a type Route:</p>\n</blockquote>\n<pre><code>export const goToRoute = (route: Route) => {};\n</code></pre>\n<blockquote>\n<p>We want to type Route to accept any string which starts with a slash:</p>\n</blockquote>\n<pre><code>goToRoute(\"/users\");\ngoToRoute(\"/\");\ngoToRoute(\"/admin/users\");\n</code></pre>\n<blockquote>\n<p>We can use template literals for that which are denoted by a backtick:</p>\n</blockquote>\n<pre><code>type Route = `/${string}`;\n</code></pre>\n<blockquote>\n<p>Or similarly</p>\n</blockquote>\n<pre><code>type MyString = string\ntype Route = `/${MyString}`;\n</code></pre>\n<blockquote>\n<p>Syntax is similar to Javascript template literal, except we can also pass in types</p>\n</blockquote>\n<blockquote>\n<p>Imagine you have these two types:</p>\n</blockquote>\n<pre><code>type BreadType = \"rye\" | \"brown\" | \"white\";\n\ntype Filling = \"cheese\" | \"ham\" | \"salami\";\n</code></pre>\n<blockquote>\n<p>And you want to create a type of them which will be like this:</p>\n</blockquote>\n<pre><code>type Sandwich =\n      | \"rye sandwich with cheese\"\n      | \"rye sandwich with ham\"\n      | \"rye sandwich with salami\"\n      | \"brown sandwich with cheese\"\n      | \"brown sandwich with ham\"\n      | \"brown sandwich with salami\"\n      | \"white sandwich with cheese\"\n      | \"white sandwich with ham\"\n      | \"white sandwich with salami\"\n</code></pre>\n<blockquote>\n<p>We can do it simply as this:</p>\n</blockquote>\n<pre><code>type Sandwich = `${BreadType} sandwich with ${Filling}`;\n</code></pre>\n<blockquote>\n<p>Now imagine that we have some type Routes:</p>\n</blockquote>\n<pre><code>type Routes = \"/users\" | \"/users/:id\" | \"/posts\" | \"/posts/:id\";\n</code></pre>\n<blockquote>\n<p>We want to create a type DynamicRoutes from Routes type, but only those which contain <code>:</code></p>\n</blockquote>\n<pre><code>type DynamicRoutes =  \"/users/:id\" | \"/posts/:id\";\n</code></pre>\n<blockquote>\n<p>How to do it? We can use Extract helper function which takes 2 parameters: first the type from which we are extracting and second parameter type which will narrow it down</p>\n</blockquote>\n<pre><code>type Routes = \"/users\" | \"/users/:id\" | \"/posts\" | \"/posts/:id\";\n\ntype WithDots = `${string}:${string}`;\ntype DynamicRoutes = Extract&#x3C;Routes, WithDots>;\n</code></pre>\n<blockquote>\n<p>Alternatively:</p>\n</blockquote>\n<pre><code>type DynamicRoutes = Extract&#x3C;Routes, `${string}:${string}`>;\n</code></pre>\n<blockquote>\n<p>We can think of template literals almost like a regEx for Typescript :)</p>\n</blockquote>\n<blockquote>\n<p>Template literals are powerful for string manipulations</p>\n</blockquote>\n<blockquote>\n<p>Now lets talk about converting a template literal into keys in an object.</p>\n</blockquote>\n<blockquote>\n<p>Imagine template literal type defined as this:</p>\n</blockquote>\n<pre><code>type TemplateLiteralKey = `${\"user\" | \"post\" | \"comment\"}${\"Id\" | \"Name\"}`;\n</code></pre>\n<blockquote>\n<p>Resulting type is:</p>\n</blockquote>\n<pre><code>userId | userName | postId | postName | commentId | commentName\n</code></pre>\n<blockquote>\n<p>What if we now want to create an object where we take those as keys?</p>\n</blockquote>\n<pre><code>type ObjectOfKeys =  {\n        userId: string;\n        userName: string;\n        postId: string;\n        postName: string;\n        commentId: string;\n        commentName: string;\n}\n</code></pre>\n<blockquote>\n<p>Answer:</p>\n</blockquote>\n<pre><code>type ObjectOfKeys = {\n  [key in TemplateLiteralKey]: string;\n};\n</code></pre>\n<blockquote>\n<p>Alternatively use Record:</p>\n</blockquote>\n<pre><code>type ObjectOfKeys = Record&#x3C;TemplateLiteralKey, string>;\n</code></pre>\n<p><strong>Record</strong></p>\n<blockquote>\n<p>Record allows us to create an object based on the type of key and type of value.</p>\n</blockquote>\n<blockquote>\n<p>Official documentation says: A Record&#x3C;K, T> is an object type whose property keys are K and whose property values are T. That is, keyof Record&#x3C;K, T> is equivalent to K, and Record&#x3C;K, T>[K] is (basically) equivalent to T.</p>\n</blockquote>\n<pre><code>type Record&#x3C;K extends string, T> = {\n    [P in K]: T;\n}\n</code></pre>\n<p><strong>TS-TOOLBELT</strong></p>\n<blockquote>\n<p>TS-TOOLBELT is a small library which contains for example a Split function which allows you to split a string based on a character on a type level.</p>\n</blockquote>\n<blockquote>\n<p>Here is documentation: <a href=\"https://millsp.github.io/ts-toolbelt/modules/string_split.html\">https://millsp.github.io/ts-toolbelt/modules/string_split.html</a></p>\n</blockquote>\n<blockquote>\n<p>This is what you import:</p>\n</blockquote>\n<pre><code>import { S } from \"ts-toolbelt\";\n</code></pre>\n<blockquote>\n<p>Imagine you have this string</p>\n</blockquote>\n<pre><code>type Path = \"Users/John/Documents/notes.txt\";\n</code></pre>\n<blockquote>\n<p>And we want to split it by slash /</p>\n</blockquote>\n<blockquote>\n<p>Resulting type should be an array of its elements:</p>\n</blockquote>\n<pre><code>type Result =  [\"Users\", \"John\", \"Documents\", \"notes.txt\"]\n</code></pre>\n<blockquote>\n<p>How to do it? Here is how:</p>\n</blockquote>\n<pre><code>import { S } from \"ts-toolbelt\";\n\ntype Path = \"Users/John/Documents/notes.txt\";\n\ntype SplitPath = S.Split&#x3C;Path, \"/\">;\n</code></pre>\n<p><strong>UPPERCASE</strong></p>\n<blockquote>\n<p>What if we have a string literal type and we want to make it uppercase?</p>\n</blockquote>\n<pre><code>type Greeting = \"Hello, world\"\n</code></pre>\n<blockquote>\n<p>We can use utility function called Uppercase:</p>\n</blockquote>\n<pre><code>type ShoutyGreeting = Uppercase&#x3C;Greeting>\n</code></pre>\n<blockquote>\n<p>It will equal to:</p>\n</blockquote>\n<pre><code>type ShoutyGreeting = \"HELLO, WORLD\"\n</code></pre>\n<blockquote>\n<p>Another example. Imagine we have such type:</p>\n</blockquote>\n<pre><code>type Event = `log_in` | \"log_out\" | \"sign_up\";\n</code></pre>\n<blockquote>\n<p>And we want ot create an object of it that will look like this:</p>\n</blockquote>\n<pre><code>type ObjectOfKeys = {\n        LOG_IN: string;\n        LOG_OUT: string;\n        SIGN_UP: string;\n      }\n</code></pre>\n<blockquote>\n<p>How to do it? Here find the solutio:</p>\n</blockquote>\n<pre><code>type ObjectOfKeys = Record&#x3C;Uppercase&#x3C;Event>, string>;\n</code></pre>\n<blockquote>\n<p>Similarly, we have Lowercase or Capitalize</p>\n</blockquote>\n<p><strong>Generics - type functions / type helpers</strong></p>\n<blockquote>\n<p>How can I tell to typescript that Whatever type I pass in, I want that to be returned?</p>\n</blockquote>\n<pre><code>type ReturnWhatIPassIn&#x3C;T> = T;\n</code></pre>\n<blockquote>\n<p>ReturnWhatIPassIn creates a variable called T but it can have any name.</p>\n</blockquote>\n<blockquote>\n<p>When I pass in \"miau\", it will return \"miau\"</p>\n</blockquote>\n<blockquote>\n<p>If I pass in true, it will return true</p>\n</blockquote>\n<pre><code>type Miau = ReturnWhatIPassIn&#x3C;\"miau\">\ntype Twelve = ReturnWhatIPassIn&#x3C;12>\ntype False = ReturnWhatIPassIn&#x3C;false>\n</code></pre>\n<blockquote>\n<p>This allows us to create functions which return other types</p>\n</blockquote>\n<pre><code>type ReturnWhatIPassIn&#x3C;T> = T;\n</code></pre>\n<blockquote>\n<p><code>ReturnWhatIPassIn</code> is name of function</p>\n</blockquote>\n<blockquote>\n<p><code>&#x3C;T></code> is agument to the function</p>\n</blockquote>\n<blockquote>\n<p><code>T</code> is what the function returns</p>\n</blockquote>\n<blockquote>\n<p><code>type Miau = string</code> is a static type</p>\n</blockquote>\n<blockquote>\n<p>If I add <code>&#x3C;T></code> to the type, I convert it to a function: <code>type Miau&#x3C;T> = T</code></p>\n</blockquote>\n<blockquote>\n<p>If we remove <code>&#x3C;T></code> from <code>ReturnWhatIPassIn</code> it would no longer be a function, it would be a static value:</p>\n</blockquote>\n<pre><code>type ReturnWhatIPassIn = 12\n</code></pre>\n<blockquote>\n<p>We can add as many arguments to the function as I want:</p>\n</blockquote>\n<pre><code>type ReturnWhatIPassIn&#x3C;T, K, U> = T;\n</code></pre>\n<blockquote>\n<p>I can give it default values</p>\n</blockquote>\n<blockquote>\n<p>Imagine this example where we want to have a generic which will take the value and add / to its front:</p>\n</blockquote>\n<pre><code>type AddRoutePrefix&#x3C;TRoute> = `/${TRoute}`;\n\nAddRoutePrefix&#x3C;\"about\"> will be \"/about\"\nAddRoutePrefix&#x3C;\"\"> will be \"/\"\nAddRoutePrefix&#x3C;\"about/team\"> will be \"/about/team\"\n</code></pre>\n<blockquote>\n<p>There is a problem that this will also work with numbers and booleans and TS will not complain:</p>\n</blockquote>\n<pre><code>AddRoutePrefix&#x3C;boolean>\nAddRoutePrefix&#x3C;number>\n</code></pre>\n<blockquote>\n<p>How can we limit this only to strings?</p>\n</blockquote>\n<pre><code>type AddRoutePrefix&#x3C;TRoute extends string> = `/${TRoute}`;\n</code></pre>\n<blockquote>\n<p>The syntax extends is like gving a type to the Type Parameter. We can imagine it as if it was really a function:</p>\n</blockquote>\n<pre><code>const addRoutePrefix = (route: string) => {}\n</code></pre>\n<blockquote>\n<p>What if our Type Helper should work with more arguments?</p>\n</blockquote>\n<pre><code>type CreateDataShape&#x3C;T, U> = {\n  data: T;\n  error: U;\n};\n</code></pre>\n<blockquote>\n<p>Now imagine that we not always want to pass in the U and if we dont pass it, then we want it to be undefined.</p>\n</blockquote>\n<pre><code>type CreateDataShape&#x3C;T, U = undefined> = {\n  data: T;\n  error: U;\n};\n</code></pre>\n<blockquote>\n<p>Then we can use this in 2 different ways:</p>\n</blockquote>\n<pre><code>type MyNewType = CreateDataShape&#x3C;string>\ntype MyNewType = CreateDataShape&#x3C;string, number>\n</code></pre>\n<blockquote>\n<p>What if I know that I will always pass a function to my type?</p>\n</blockquote>\n<pre><code>type GetParametersAndReturnType&#x3C;T extends (a: any, b: any) => any> = {\n  params: Parameters&#x3C;T>;\n  returnValue: ReturnType&#x3C;T>;\n};\n</code></pre>\n<blockquote>\n<p>Look at the type above and its usage below:</p>\n</blockquote>\n<pre><code>type MyType1 = GetParametersAndReturnType&#x3C;() => string>\n// { params: []; returnValue: string }\n\ntype MyType2 = GetParametersAndReturnType&#x3C;(s: string) => void>\n// { params: [string]; returnValue: void }\n\ntype MyType3 = GetParametersAndReturnType&#x3C;(n: number, b: boolean) => number>\n// { params: [number, boolean]; returnValue: number }\n</code></pre>\n<blockquote>\n<p>This will work with 2 parameters, but what if we need more?</p>\n</blockquote>\n<pre><code>type GetParametersAndReturnType&#x3C;T extends (...args: any) => any> = {\n  params: Parameters&#x3C;T>;\n  returnValue: ReturnType&#x3C;T>;\n};\n</code></pre>\n<blockquote>\n<p>Not there is a mind blowing type for generics where we want to make sure we can pass in anything EXCEPT for null or undefined</p>\n</blockquote>\n<blockquote>\n<p>We will start with a code like this:</p>\n</blockquote>\n<pre><code>export type Maybe&#x3C;T> = T | null | undefined;\n</code></pre>\n<p>We want that all these tests pass</p>\n<pre><code>type Yes1 = Maybe&#x3C;string>,\ntype Yes2 = Maybe&#x3C;false>,\ntype Yes3 = Maybe&#x3C;0>,\ntype Yes4 = Maybe&#x3C;\"\">,\n</code></pre>\n<blockquote>\n<p>But these test should fail:</p>\n</blockquote>\n<pre><code>type No1 = Maybe&#x3C;null>,\ntype No2 = Maybe&#x3C;undefined>,\n</code></pre>\n<blockquote>\n<p>And we want to narrow down T to be anything except for null or undefined:</p>\n</blockquote>\n<pre><code>export type Maybe&#x3C;T extends string | number | boolean> = T | null | undefined;\n</code></pre>\n<blockquote>\n<p>But another mind-blowing way to do it is here:</p>\n</blockquote>\n<pre><code>export type Maybe&#x3C;T extends {}> = T | null | undefined;\n</code></pre>\n<blockquote>\n<p><code>{}</code> in typescript has a very special meaning. It represents anything that is not null or undefined. It is different from truthy values, cause we can pass there false or 0</p>\n</blockquote>\n<blockquote>\n<p>Actually if we type something as an empty object, we can assign a string, or number to it</p>\n</blockquote>\n<pre><code>const whatever: {} = \"abc\"\nconst whatever: {} = 123\nconst whatever: {} = false\nconst whatever: {} = 0\nconst whatever: {} = true\nconst whatever: {} = {}\nconst whatever: {} = []\n</code></pre>\n<blockquote>\n<p>Why is it? Everything in Javascript is an object - array, string with various methods, etc.</p>\n</blockquote>\n<blockquote>\n<p>Moreover, Typescript does structural comparisons when checking if something is comparable. If I need a type: { name: string }, it does not care that I pass { name: string, surname: string, age: number }. It only cares about the name being present and all additional properties are ignored. So if I have a type of empty object {}, I can pass any property in there.</p>\n</blockquote>\n<blockquote>\n<p>null and undefined are not objects. whereas false is still an object, 0 is an object</p>\n</blockquote>\n<blockquote>\n<p>Now how to declare a type which is a non-empty array?</p>\n</blockquote>\n<blockquote>\n<p>If we do this:</p>\n</blockquote>\n<pre><code>type NonEmpty&#x3C;T> = Array&#x3C;T>\n</code></pre>\n<blockquote>\n<p>then we actually can pass empty array</p>\n</blockquote>\n<blockquote>\n<p>We could use tuples for that:</p>\n</blockquote>\n<pre><code>type NonEmpty&#x3C;T> = [T, T, T]\n</code></pre>\n<blockquote>\n<p>but then we would need to know exactly the length of that array, but if we want to be more flexible and to allow for any length, then it wont work.</p>\n</blockquote>\n<blockquote>\n<p>A neat trick is to us following syntax with rest parameter:</p>\n</blockquote>\n<pre><code>type NonEmpty&#x3C;T> = [ T, ...T[]]\n</code></pre>\n<blockquote>\n<p>Or similarly:</p>\n</blockquote>\n<pre><code>type NonEmpty&#x3C;T> = [ T, ...Array&#x3C;T>]\n</code></pre>\n<blockquote>\n<p>This syntax means that I need to have at least one element in the array and then as many as I like, even 0</p>\n</blockquote>\n<blockquote>\n<p>If we want an array that needs to have at least 2 parameters:</p>\n</blockquote>\n<pre><code>type NonEmpty&#x3C;T> = [ T, T, ...Array&#x3C;T>]\n</code></pre>\n<p><strong>Conditional types</strong></p>\n<blockquote>\n<p>Now how can we conditionally render a type?</p>\n</blockquote>\n<blockquote>\n<p>Imagine if I pass \"hello\" to my type, I want to return \"goodbye\" and if I pass \"goodbye\", I want to return \"hello\"</p>\n</blockquote>\n<pre><code>type YouSayGoodbyeAndISayHello&#x3C;T> = T extends \"hello\" ? \"goodbye\" : \"hello\";\n\ntype MyType = YouSayGoodbyeAndISayHello&#x3C;\"hello\"> // \"goodbye\"\ntype MyType = YouSayGoodbyeAndISayHello&#x3C;\"goodbye\"> // \"hello\"\n</code></pre>\n<blockquote>\n<p>In this context <code>T extends \"hello\"</code> is actually a logical check. Does T extend \"hello\"?</p>\n</blockquote>\n<blockquote>\n<p>This conditional type is mega powerful and turns typescript from just some static type checks to a its own language</p>\n</blockquote>\n<blockquote>\n<p>Ternary statements can be nested :)</p>\n</blockquote>\n<p><strong>Infer</strong></p>\n<blockquote>\n<p><code>infer</code> keyword is often being used in conditional types</p>\n</blockquote>\n<blockquote>\n<p>Imagine we want to create a type that will accept { data: \"ABC\" } and it will return \"ABC\"</p>\n</blockquote>\n<blockquote>\n<p>If it accepts { data: { name: \"DEF\"} }, it will return { name: \"DEF\"}</p>\n</blockquote>\n<blockquote>\n<p>We can do it like this:</p>\n</blockquote>\n<pre><code>type GetDataValue&#x3C;T> = T extends { data: infer E } ? E : never;\n\ntype No = GetDataValue&#x3C;string> // returns never cause we didnt pass object with data\ntype Yes1 = GetDataValue&#x3C;{ data: \"hello\" }> // returns \"hello\"\ntype Yes2 = GetDataValue&#x3C;{ data: { name: \"hello\" } }> // returns { name: \"hello\" }\ntype Yes3 = GetDataValue&#x3C;{ data: { name: \"hello\"; age: 20 } }> // returns { name: \"hello\"; age: 20 }\n</code></pre>\n<blockquote>\n<p>how does the infer keyrowd work? Whatever is passed into the data key in an object, the TS will infer its type and save it to a variable called E (can be any name). We can then use that variable later to say what the function should return in case this condition is true!</p>\n</blockquote>\n<blockquote>\n<p>Notice that the E will only be defined for the positive branch and not in the else case. Because in else case, E is not declared. SO we cant do this:</p>\n</blockquote>\n<pre><code>type GetDataValue&#x3C;T> = T extends { data: infer E } ? E : E; // ERROR E is not declared\n</code></pre>\n<blockquote>\n<p>This whole infer allows us to declare a new type variable inside of the conditional check.</p>\n</blockquote>\n<blockquote>\n<p>Another way to do this is exercise is:</p>\n</blockquote>\n<pre><code>type GetDataValue&#x3C;T> = T extends { data: any } ? T[\"data\"] : never;\n</code></pre>\n<p><strong>Template literals with infer</strong></p>\n<blockquote>\n<p>Imagine we have type like this:</p>\n</blockquote>\n<pre><code>type Names = [\n  \"Matt Pocock\",\n  \"Jimi Hendrix\",\n  \"Eric Clapton\",\n  \"John Mayer\",\n  \"BB King\",\n];\n</code></pre>\n<blockquote>\n<p>and we want to infer another type from it which will be Pocock, Handrix, Claptop, Mayer</p>\n</blockquote>\n<pre><code>type GetSurname&#x3C;T> = unknow\n type New1 = GetSurname&#x3C;Names[0]> // returns \"Pocock\"\n type New2 = GetSurname&#x3C;Names[1]> // returns \"Hendrix\"\n type New3 = GetSurname&#x3C;Names[2]> // returns \"Clapton\"\n type New4 = GetSurname&#x3C;Names[3]> // returns \"Mayer\"\n type New5 = GetSurname&#x3C;Names[4]> // returns \"King\"\n</code></pre>\n<blockquote>\n<p>How ot declare the GetSurname type?</p>\n</blockquote>\n<blockquote>\n<p>One way is using S and spliting it:</p>\n</blockquote>\n<pre><code>import { S } from \"ts-toolbelt\";\ntype GetSurname&#x3C;T extends string> = S.Split&#x3C;T, \" \">[1];\n</code></pre>\n<blockquote>\n<p>But we can also use template literal and word infer:</p>\n</blockquote>\n<pre><code>type GetSurname&#x3C;T> = T extends `${infer First} ${infer Last}` ? Last : never;\n</code></pre>\n<p><strong>Mapped types</strong></p>\n<blockquote>\n<p>Imagine we have a union type:</p>\n</blockquote>\n<pre><code>type Route = \"/\" | \"/about\" | \"/admin\" | \"/admin/users\";\n</code></pre>\n<blockquote>\n<p>And we want to create a type for an object where both keys and values will be the members of the union:</p>\n</blockquote>\n<pre><code>type Result = {\n        \"/\": \"/\";\n        \"/about\": \"/about\";\n        \"/admin\": \"/admin\";\n        \"/admin/users\": \"/admin/users\";\n}\n</code></pre>\n<blockquote>\n<p>In order to do this we can use mapped types which iterated through each member of a union, defines a variable, for example Key and then allows us to use this variable:</p>\n</blockquote>\n<pre><code>type RoutesObject = {\n  [Key in Route]: Key;\n};\n</code></pre>\n<blockquote>\n<p>Variable name is anything we want</p>\n</blockquote>\n<pre><code>type RoutesObject = {\n  [R in Route]: R;\n};\n</code></pre>\n<blockquote>\n<p>What <code>in</code> basically does is for every member of a union, extract R and add it as a key and value</p>\n</blockquote>\n<blockquote>\n<p>We can also use it like this:</p>\n</blockquote>\n<pre><code>type RoutesObject = {\n  [Key in \"hi\" | \"there\"]: Key;\n};\n</code></pre>\n<blockquote>\n<p>It would resolve into an object</p>\n</blockquote>\n<pre><code>{\n  hi: \"hi\",\n  there: \"there\",\n}\n</code></pre>\n<blockquote>\n<p>Values also dont need to be same as keys:</p>\n</blockquote>\n<pre><code>type RoutesObject = {\n  [Key in \"hi\" | \"there\"]: string;\n};\n</code></pre>\n<blockquote>\n<p>Mapped types also work with objects. Imagine we have an object type like this:</p>\n</blockquote>\n<pre><code>interface Attributes {\n  firstName: string;\n  lastName: string;\n  age: number;\n}\n</code></pre>\n<blockquote>\n<p>And we want to extract from it a type that will look like this:</p>\n</blockquote>\n<pre><code>{\n  firstName: () => string;\n  lastName: () => string;\n  age: () => number;\n}\n</code></pre>\n<blockquote>\n<p>We can do it like this:</p>\n</blockquote>\n<pre><code>type AttributeGetters = {\n  [K in keyof Attributes]: () => Attributes[K];\n};\n</code></pre>\n<blockquote>\n<p>Keyof Attributes also creates a union of all the keys in Attribute type</p>\n</blockquote>\n<blockquote>\n<p>We can even create a same type as Attributes using mapped type:</p>\n</blockquote>\n<pre><code>type MyNewAttribute = {\n  [K in keyof Attributes]: Attributes[K];\n};\n</code></pre>\n<blockquote>\n<p>MyNewAttribute is now equivalent type as Attribute. Why would we want to do that? If we needed a new type where all keys are optional or readonly:</p>\n</blockquote>\n<pre><code>type MyNewAttribute = {\n  [K in keyof Attributes]?: Attributes[K];\n};\n\ntype MyNewAttribute = {\n  readonly [K in keyof Attributes]: Attributes[K];\n};\n</code></pre>\n<blockquote>\n<p>now what if we want to rename the keys of the new object type?</p>\n</blockquote>\n<pre><code>type NowThis = {\n        getFirstName: () => string;\n        getLastName: () => string;\n        getAge: () => number;\n }\n</code></pre>\n<blockquote>\n<p>We can use as property which allows us to use template literals</p>\n</blockquote>\n<pre><code>type AttributeGetters = {\n  [K in keyof Attributes as `get${Capitalize&#x3C;K>}`]: () => Attributes[K];\n};\n</code></pre>\n<blockquote>\n<p>This <code>as</code> works as a remapper</p>\n</blockquote>\n<blockquote>\n<p>Now if we have an object type like this</p>\n</blockquote>\n<pre><code>interface Attributes {\n  greet1: [ \"hi\", \"there\" ];\n  greet2: [ \"hello\", \"you\" ];\n}\n</code></pre>\n<blockquote>\n<p>And we wanted to extract a type that would be</p>\n</blockquote>\n<pre><code>type GreetOnly = {\n  greet1: \"hi\";\n  greet2: \"hello\";\n}\n</code></pre>\n<blockquote>\n<p>We can do it like this</p>\n</blockquote>\n<pre><code>type NewType = {\n  [K in keyof Attributes]: Attributes[K][0]\n}\n</code></pre>\n<blockquote>\n<p>Now imagine we have a type like this:</p>\n</blockquote>\n<pre><code>interface Example {\n  name: string;\n  age: number;\n  id: string;\n  organisationId: string;\n  groupId: string;\n}\n</code></pre>\n<blockquote>\n<p>And we want to extract a type from it which has such keys, which contain <code>id</code> in it. Resulting type should look like this:</p>\n</blockquote>\n<pre><code>type Result: {\n        id: string;\n        organisationId: string;\n        groupId: string;\n}\n</code></pre>\n<blockquote>\n<p>We will need conditional type, remapping and a generic</p>\n</blockquote>\n<pre><code>type OnlyIdKeys&#x3C;T> = {\n  [K in keyof T as `${K extends \"id\" | \"organisationId\" | \"groupId\"\n    ? K\n    : never}`]: T[K];\n};\n</code></pre>\n<blockquote>\n<p>Then we use this type like this:</p>\n</blockquote>\n<pre><code>type Result = OnlyIdKeys&#x3C;Example>;\n</code></pre>\n<blockquote>\n<p>Another even more generic and elegant way is to use template literals to search for an anything that contains id in it (WOW)</p>\n</blockquote>\n<pre><code>type OnlyIdKeys&#x3C;T> = {\n  [K in keyof T as K extends `${string}${\"id\" | \"Id\"}${string}`\n    ? K\n    : never]: T[K];\n};\n</code></pre>\n<blockquote>\n<p>Now assume we have a discriminated union like this:</p>\n</blockquote>\n<pre><code>type Route =\n  | {\n      route: \"/\";\n      search: {\n        page: string;\n        perPage: string;\n      };\n    }\n  | { route: \"/about\"; search: {} }\n  | { route: \"/admin\"; search: {} }\n  | { route: \"/admin/users\"; search: {} };\n</code></pre>\n<blockquote>\n<p>and we want to extract a type of it, which will look like this:</p>\n</blockquote>\n<pre><code>type Interesting = {\n        \"/\": {\n          page: string;\n          perPage: string;\n        };\n        \"/about\": {};\n        \"/admin\": {};\n        \"/admin/users\": {};\n      }\n</code></pre>\n<blockquote>\n<p>How can we do it? Tip: We will need mapped type, indexed access aaaaand an Extract.</p>\n</blockquote>\n<pre><code>type RoutesObject = {\n  [K in Route[\"route\"]]: Extract&#x3C;Route, { route: K }>[\"search\"];\n};\n</code></pre>\n<blockquote>\n<p>And a super elegant way to do it is:</p>\n</blockquote>\n<pre><code>type RoutesObject = {\n  [K in Route as Route[\"route\"]]: Route[\"search\"];\n};\n</code></pre>\n<blockquote>\n<p>We keep K as a Route and then we have access to the entire object including route and search. The key is then remapped to be Route[\"route\"] and value to Route[\"search\"]. Wow</p>\n</blockquote>\n<p><strong>Object to union</strong></p>\n<blockquote>\n<p>What if we have an object like this?</p>\n</blockquote>\n<pre><code>interface Values {\n  email: string;\n  firstName: string;\n  lastName: string;\n}\n</code></pre>\n<blockquote>\n<p>And from this we want to create a union o tuples:</p>\n</blockquote>\n<pre><code>type UN = [\"email\", string] | [\"firstName\", string] | [\"lastName\", string]\n</code></pre>\n<blockquote>\n<p>First we will create an intermediary type which looks like this:</p>\n</blockquote>\n<pre><code>type F = {\n  [K in keyof Values]: [K, Values[K]];\n};\n</code></pre>\n<blockquote>\n<p>Which will then look like this:</p>\n</blockquote>\n<pre><code>type F = {\n  email: [\"email\", string];\n  firstName: [\"firstName\", string];\n  lastName: [\"lastName\", string];\n}\n</code></pre>\n<blockquote>\n<p>And then the only thing we need to do it so simply extract value of object to a union type, which we did before:</p>\n</blockquote>\n<pre><code>type ImUnion = F[keyof F]\n</code></pre>\n<blockquote>\n<p>So the whole magic looks like this:</p>\n</blockquote>\n<pre><code>interface Values {\n  email: string;\n  firstName: string;\n  lastName: string;\n}\n\ntype F = {\n  [K in keyof Values]: [K, Values[K]];\n};\n\ntype ValuesAsUnionOfTuples = F[keyof F];\n</code></pre>\n<blockquote>\n<p>And to even make it nicer:</p>\n</blockquote>\n<pre><code>type ValuesAsUnionOfTuples = {\n  [K in keyof Values]: [K, Values[K]];\n}[keyof Values];\n</code></pre>\n<blockquote>\n<p>Similarly if we have such an object:</p>\n</blockquote>\n<pre><code>interface FruitMap {\n  apple: \"red\";\n  banana: \"yellow\";\n  orange: \"orange\";\n}\n</code></pre>\n<blockquote>\n<p>And we want a union type of it like this:</p>\n</blockquote>\n<pre><code>type MyBreakfast: \"apple:red\" | \"banana:yellow\" | \"orange:orange\"\n</code></pre>\n<blockquote>\n<p>We can do it like this:</p>\n</blockquote>\n<pre><code>type TransformedFruit = {\n  [K in keyof FruitMap]: `${K}:${FruitMap[K]}`;\n}[keyof FruitMap];\n</code></pre>\n<p><strong>Array to union / Tuple to union type</strong></p>\n<blockquote>\n<p>Imagine I have an array type like this:</p>\n</blockquote>\n<pre><code>type X = [ \"user\", \"id\", \"name\"]\n</code></pre>\n<blockquote>\n<p>What if I want a union type of it?</p>\n</blockquote>\n<pre><code>type Y = X[number] // \"user\" | \"id\" | \"name\"\n</code></pre>\n<p><strong>Generics in functions</strong></p>\n<blockquote>\n<p>How to type a function with generics to return what is passed in?</p>\n</blockquote>\n<pre><code>const returnWhatIPassIn = &#x3C;E>(t: E) => {\n  return t;\n};\n</code></pre>\n<blockquote>\n<p>We add <code>&#x3C;T></code> in front of the parameters parentheses. And we are creating a type helper out of this function</p>\n</blockquote>\n<blockquote>\n<p>The function then receives T and also returns T</p>\n</blockquote>\n<blockquote>\n<p>It is equivalent to creating such a type:</p>\n</blockquote>\n<pre><code>type ReturnWhatIPassIn&#x3C;T> = T\ntype One = ReturnWhatIPassIn&#x3C;1> // returns 1\ntype Two = ReturnWhatIPassIn&#x3C;2> // returns 2\n</code></pre>\n<blockquote>\n<p>We could also anotate the return type explicitely. But TS infers it correctly:</p>\n</blockquote>\n<pre><code>const returnWhatIPassIn = &#x3C;E>(t: E):E => {\n  return t;\n};\n</code></pre>\n<blockquote>\n<p>We can also restrict T to only accept strings, but still be inferred as what literal value what is passed in and not as a generic string</p>\n</blockquote>\n<pre><code>export const returnWhatIPassIn = &#x3C;T extends string>(t: T) => t;\n</code></pre>\n<blockquote>\n<p>What if we want to pass in 2 parameters?</p>\n</blockquote>\n<pre><code>const returnBothOfWhatIPassIn = &#x3C;T, U>(a: T, b: U) => {\n  return {\n    a,\n    b,\n  };\n};\n</code></pre>\n<blockquote>\n<p>Above syntax is same as</p>\n</blockquote>\n<pre><code>type Result&#x3C;A, B> = {\n  a: A,\n  b: B\n}\n</code></pre>\n<blockquote>\n<p>T will be infered as string and U as a number if we pass in values like this:</p>\n</blockquote>\n<pre><code>const result = returnBothOfWhatIPassIn(\"a\", 1);\n</code></pre>\n<blockquote>\n<p>If we want them to be literal, we can extend each</p>\n</blockquote>\n<pre><code>const returnBothOfWhatIPassIn = &#x3C;T extends string, U extends number>(a: T, b: U) => {\n  return {\n    a,\n    b,\n  };\n};\n</code></pre>\n<blockquote>\n<p>This is pretty important charcteristics of generics and how we can use literal values</p>\n</blockquote>\n<blockquote>\n<p>Similar example. What if we have a function like this which receives array of statuses and returns them? We dont want however the return type to be array of strings, we want it to be array of individual status (their literal values).</p>\n</blockquote>\n<pre><code>const makeStatus = &#x3C;TStatuses extends string[]>(\n  statuses: TStatuses\n) => {\n  return statuses;\n};\n\nconst statuses = makeStatus([\"INFO\", \"DEBUG\", \"ERROR\", \"WARNING\"]);\n</code></pre>\n<blockquote>\n<p>Solution:</p>\n</blockquote>\n<pre><code>const makeStatus = &#x3C;TStatuses extends string>(\n  statuses: Array&#x3C;TStatuses>\n): Array&#x3C;TStatuses> => {\n  return statuses;\n};\n\nconst statuses = makeStatus([\"INFO\", \"DEBUG\", \"ERROR\", \"WARNING\"]);\n</code></pre>\n<blockquote>\n<p>Important is that we can make in braces &#x3C;> whatever we want, it can be array of something or the something.</p>\n</blockquote>\n<p><strong>Generics and components</strong></p>\n<blockquote>\n<p>Imagine we have a component like this</p>\n</blockquote>\n<pre><code>export class Component{\n  private props: unknown;\n\n  constructor(props: unknown) {\n    this.props = props;\n  }\n\n  getProps = () => this.props;\n}\n\nconst component = new Component({ a: 1, b: 2, c: 3 });\n</code></pre>\n<blockquote>\n<p>And we want to make sure that whatever props we pass in, we will also infer the type from them</p>\n</blockquote>\n<blockquote>\n<p>Solution looks like this</p>\n</blockquote>\n<pre><code>export class Component&#x3C;TProps> {\n  private props: TProps;\n\n  constructor(props: TProps) {\n    this.props = props;\n  }\n\n  getProps = () => this.props;\n}\n\nconst component = new Component({ a: 1, b: 2, c: 3 });\n</code></pre>\n<blockquote>\n<p>Now what if we want our clone function to infer the props of the object we are passing in?</p>\n</blockquote>\n<pre><code>export class Component&#x3C;TProps> {\n  private props: TProps;\n  constructor(props: TProps) {\n    this.props = props;\n  }\n  getProps = () => this.props;\n}\n\nconst cloneComponent = (component) => {\n  return new Component(component.getProps());\n};\n</code></pre>\n<blockquote>\n<p>Solution</p>\n</blockquote>\n<pre><code>export class Component&#x3C;TProps> {\n  private props: TProps;\n  constructor(props: TProps) {\n    this.props = props;\n  }\n  getProps = () => this.props;\n}\n\nconst cloneComponent = &#x3C;TProps>(component: Component&#x3C;TProps>) => {\n  return new Component(component.getProps());\n};\n</code></pre>\n<p><strong>How to create generics with Sets</strong></p>\n<blockquote>\n<p>Set is just an array with unique values.</p>\n</blockquote>\n<blockquote>\n<p>Imagine we have a set like this:</p>\n</blockquote>\n<pre><code>export const createSet = ()=> {\n  return new Set();\n};\nconst stringSet = createSet&#x3C;string>();\nconst numberSet = createSet&#x3C;number>();\nconst unknownSet = createSet();\n</code></pre>\n<blockquote>\n<p>And we want this to be infered as set of strings for the first one, set of number for seconds one and set of unknown for third one. Here is how:</p>\n</blockquote>\n<pre><code>export const createSet = &#x3C;T>(): Set&#x3C;T> => {\n  return new Set();\n};\nconst stringSet = createSet&#x3C;string>();\nconst numberSet = createSet&#x3C;number>();\nconst unknownSet = createSet();\n</code></pre>\n<blockquote>\n<p>Another way ho to do it:</p>\n</blockquote>\n<pre><code>export const createSet = &#x3C;T>() => {\n  return new Set&#x3C;T>();\n};\nconst stringSet = createSet&#x3C;string>();\nconst numberSet = createSet&#x3C;number>();\nconst unknownSet = createSet();\n</code></pre>\n<blockquote>\n<p>We can create sets like this</p>\n</blockquote>\n<pre><code>contt mySet = new Set&#x3C;number>()\nmySet.add(123) // works\nmySet.add(\"hi\") // error\n</code></pre>\n<blockquote>\n<p>In above problem, how to set a default type if we dont pass anything? TS would infer unknown, but what if we want it to be string?</p>\n</blockquote>\n<pre><code>export const createSet = &#x3C;T = string>() => {\n  return new Set&#x3C;T>();\n};\nconst numberSet = createSet&#x3C;number>();\nconst stringSet = createSet&#x3C;string>();\nconst otherStringSet = createSet();\n</code></pre>\n<p><strong>Typing asynchronous functions with generics</strong></p>\n<blockquote>\n<p>How to type in a fetch function which should receive a type?</p>\n</blockquote>\n<pre><code>const fetchData = async &#x3C;T>(url: string): Promise&#x3C;T> => {\n  const data = await fetch(url).then((response) => response.json());\n  return data;\n};\n</code></pre>\n<blockquote>\n<p>Then when we call it we should prove its type:</p>\n</blockquote>\n<pre><code>async () => {\n  const data = await fetchData&#x3C;{ name: string }>(\n    \"https://swapi.dev/api/people/1\"\n  );\n</code></pre>\n<blockquote>\n<p>We could also do it like this:</p>\n</blockquote>\n<pre><code>const fetchData = async &#x3C;T>(url: string) => {\n  const data = await fetch(url).then((response) => response.json());\n  return data as T;\n};\n</code></pre>\n<blockquote>\n<p>But there is a better way:</p>\n</blockquote>\n<pre><code>const fetchData = async &#x3C;T>(url: string) => {\n  const data: T = await fetch(url).then((response) => response.json());\n  return data;\n};\n</code></pre>\n<blockquote>\n<p>Or even:</p>\n</blockquote>\n<pre><code>const fetchData = async &#x3C;T>(url: string) => {\n  const data: T = await fetch(url).then((response): Promise&#x3C;T> => response.json());\n  return data;\n};\n</code></pre>\n<blockquote>\n<p>Goal is to not let any sneaky any leave this line of code</p>\n</blockquote>\n<p><strong>Function overloading</strong></p>\n<blockquote>\n<p>Based on an amazing article from Dmitri Pavlutin:\n<a href=\"https://dmitripavlutin.com/typescript-function-overloading/#:~:text=Function%20overloading%20in%20TypeScript%20lets,the%20function%20should%20be%20invoked\">https://dmitripavlutin.com/typescript-function-overloading/#:~:text=Function%20overloading%20in%20TypeScript%20lets,the%20function%20should%20be%20invoked</a></p>\n</blockquote>\n<blockquote>\n<p>Most of the functions accept a fixed set of arguments. But some functions can accept a variable number of arguments, arguments of different types, and could even return different types depending on how you invoke the function. To annotate such function TypeScript offers the function overloading feature. Let's see how function overloading works.</p>\n</blockquote>\n<blockquote>\n<p>Let's consider a function that returns a welcome message to a particular person:</p>\n</blockquote>\n<pre><code>function greet(person: string): string {\n  return `Hello, ${person}!`;\n}\n</code></pre>\n<blockquote>\n<p>The function above accepts 1 argument of type string: the name of the person. Invoking the function is pretty simple:</p>\n</blockquote>\n<pre><code>greet('World'); // 'Hello, World!'\n</code></pre>\n<blockquote>\n<p>What if you'd like to make the greet() function more flexible? For example, make it additionally accept a list of persons to greet. Such a function would accept a string or an array of strings as an argument, as well as return a string or an array of strings.</p>\n</blockquote>\n<blockquote>\n<p>How to annotate such a function? There are 2 approaches.</p>\n</blockquote>\n<blockquote>\n<p>The first approach is straightforward and involves modifying the function signature directly by updating the parameter and return types.</p>\n</blockquote>\n<blockquote>\n<p>Here's how greet() looks after updating the parameter and return types:</p>\n</blockquote>\n<pre><code>function greet(person: string | string[]): string | string[] {\n  if (typeof person === 'string') {\n    return `Hello, ${person}!`;\n  } else if (Array.isArray(person)) {\n    return person.map(name => `Hello, ${name}!`);\n  }\n  throw new Error('Unable to greet');\n}\n</code></pre>\n<blockquote>\n<p>Now you can invoke greet() in 2 ways:</p>\n</blockquote>\n<pre><code>greet('World');          // 'Hello, World!'\ngreet(['Jane', 'Joe']); // ['Hello, Jane!', 'Hello, Joe!']\n</code></pre>\n<blockquote>\n<p>Updating the function signature directly to support the multiple ways of invocation is the usual and a good approach. However, there are situations when you might want to take an alternative approach and define separately all the ways your function can be invoked. This approach is called function overloading.</p>\n</blockquote>\n<blockquote>\n<p>The second approach is to use the <code>function overloading</code> feature. I recommend it when the function signature is relatively complex and has multiple types involved.</p>\n</blockquote>\n<blockquote>\n<p>Putting the function overloading in practice requires defining the so-called overload signatures and an implementation signature.</p>\n</blockquote>\n<blockquote>\n<p>The overload signature defines the parameter and return types of the function, and doesn't have a body. A function can have multiple overload signatures: corresponding to the different ways you can invoke the function.</p>\n</blockquote>\n<blockquote>\n<p>The implementation signature, on the other side, also has the parameter types and return type, but also a body that implements the function. There can be only one implementation signature.</p>\n</blockquote>\n<blockquote>\n<p>Let's transform the function greet() to use the function overloading:</p>\n</blockquote>\n<pre><code>// Overload signatures\nfunction greet(person: string): string;\nfunction greet(persons: string[]): string[];\n\n// Implementation signature\nfunction greet(person: unknown): unknown {\n  if (typeof person === 'string') {\n    return `Hello, ${person}!`;\n  } else if (Array.isArray(person)) {\n    return person.map(name => `Hello, ${name}!`);\n  }\n  throw new Error('Unable to greet');\n}\n</code></pre>\n<blockquote>\n<p>The greet() function has 2 overload signatures and one implementation signature.</p>\n</blockquote>\n<blockquote>\n<p>Each overload signature describes one way the function can be invoked. In the case of greet() function, you can call it 2 ways: with a string argument, or with an array of strings argument.</p>\n</blockquote>\n<blockquote>\n<p>The implementation signature function greet(person: unknown): unknown { ... } contains the proper logic how the function works.</p>\n</blockquote>\n<blockquote>\n<p>Now, as before, you can invoke greet() with the arguments of type string or array of strings:</p>\n</blockquote>\n<pre><code>greet('World');          // 'Hello, World!'\ngreet(['Jane', 'Joe']);  // ['Hello, Jane!', 'Hello, Joe!']\n</code></pre>\n<blockquote>\n<p>You should think carefully, because function overloads are at their best when you have a different return type based on something that you pass in. If you just have the same return type, no matter what happens, it's always going to return a string, then you should probably be using a union to express these parameters instead.</p>\n</blockquote>\n<p><strong>Casting</strong></p>\n<blockquote>\n<p>When we think we know better what this type is we can use <code>as</code> keyword which will say to typescript - I know what the type is so use it as I say. TYpescript will be: OK, Master.</p>\n</blockquote>\n<pre><code>sendEmail(\"abc\" as EmailAddress)\n</code></pre>\n<blockquote>\n<p>In general this is not a good idea in Typescript</p>\n</blockquote>\n<p><strong>Type aliases</strong></p>\n<blockquote>\n<p>When we create our own types with some random name:</p>\n</blockquote>\n<pre><code>type RandomWord = string\n</code></pre>\n<blockquote>\n<p>RandomWord is a type alias</p>\n</blockquote>\n<p><strong>Branded types</strong></p>\n<blockquote>\n<p>Also known as nominal types. These types are really interesting, because they let you specify logic on the type level.</p>\n</blockquote>\n<blockquote>\n<p>Imagine that throughout your application you will deal with emails. But to defined them as a string is too broad. You want to make sure they follow a pattern of an email address. We will use branded types for that</p>\n</blockquote>\n<blockquote>\n<p>Branded types allows us to create a type to which within normal rules of Typescript no value would be possible to bed assigned to them. They are so called illegal types.</p>\n</blockquote>\n<blockquote>\n<p>Example of illegal type is intersection between string and number:</p>\n</blockquote>\n<pre><code>type Illegal = string &#x26; number\n</code></pre>\n<blockquote>\n<p>This will result in never type because you cant have something that is both string and number. We cannotassign anything to never types.</p>\n</blockquote>\n<blockquote>\n<p>Branded type is created as a base type and then intersection with object, where we label the Brand as for example Email:</p>\n</blockquote>\n<pre><code>type Mail = string &#x26; { __brand: \"Email\" }\n</code></pre>\n<blockquote>\n<p>String cannot be intersected with an object but notice that this is now not typed as never! Assigning value to this type will now not be possible.</p>\n</blockquote>\n<pre><code>const a: Mail = \"abc\" //ERROR\n</code></pre>\n<blockquote>\n<p>What we are missing still is a rule which will detect if it is a valid email address, like contains @, etc.</p>\n</blockquote>\n<pre><code>const isEmail = (email: string): email is Mail => {\n  return email.includes(\"@gmail.com\")\n}\n</code></pre>\n<blockquote>\n<p>Notice that the output of the <code>email is Mail</code>. This is also called casting where we say to the typescript that we know better than Typescript what the return type is going to be. Such a statement now means that if the isEmail returns true, then we can safely assume that email is of a type Mail. Else it cannot be assumed it is of type Mail and it will only be a string</p>\n</blockquote>\n<blockquote>\n<p>We can then use our function like this:</p>\n</blockquote>\n<pre><code>type Mail = string &#x26; { __brand: \"Email\" }\n\nconst isEmail = (email: string): email is Mail => {\n  return email.includes(\"@gmail.com\")\n}\n\nconst sendWelcomeEmail = (email: Mail) => {\n  //\n}\n\nconst signUp = (email: string) => {\n  if (isEmail){\n     sendWelcomeEmail(email) // email will be correctly typed as Mail\n  }\n}\n</code></pre>\n<blockquote>\n<p>Another way to approach this topic is to use assert and then throw error if the condition for email address is not met:</p>\n</blockquote>\n<pre><code>type Mail = string &#x26; { __brand: \"Email\" }\n\nconst asserEmail = (email: string): asserts email is Mail => {\n  if (!email.includes(\"@gmail.com\")){\n    throw new Error(`Invalid argument: [${email}] is not a valid email`)\n  }\n}\n\nconst sendWelcomeEmail = (email: Mail) => {\n  //\n}\n\nconst signUp = (email: string) => {\n  assertEmail(email);\n  sendWelcomeEmail(email) // email will be correctly typed as Mail, cause we reached so far here without error\n}\n</code></pre>\n<p><strong>Global scope</strong></p>\n<blockquote>\n<p>howto declare and type in global scope</p>\n</blockquote>\n<pre><code>declare global {\n  function myFunc(): boolean;\n  var myVar: number;\n}\n\nglobalThis.myFunc = () => true;\nglobalThis.myVar = 1;\n</code></pre>\n<blockquote>\n<p>noteice that in global scope we can only declare and type. We cannot write the implementation or assignment</p>\n</blockquote>\n<blockquote>\n<p>Only vars work in global scope. No const or let.</p>\n</blockquote>\n<blockquote>\n<p>Cool thing about global scope is that it support ambient merging. I can declare a global in one file and the same global in other file and the result will be a merged global from both files:</p>\n</blockquote>\n<blockquote>\n<p>File 1</p>\n</blockquote>\n<pre><code>declare global {\n  interface DispatchableEvent {\n    LOG_IN: {\n      username: string;\n      password: string;\n    };\n  }\n}\n</code></pre>\n<blockquote>\n<p>File 2</p>\n</blockquote>\n<pre><code>declare global {\n  interface DispatchableEvent {\n    LOG_OUT: {};\n    UPDATE_USERNAME: {\n      username: string;\n    };\n  }\n}\n</code></pre>\n<blockquote>\n<p>Result:</p>\n</blockquote>\n<pre><code>interface DispatchableEvent {\n    LOG_IN: {\n      username: string;\n      password: string;\n    };\n    LOG_OUT: {};\n    UPDATE_USERNAME: {\n      username: string;\n    };\n  }\n</code></pre>\n<blockquote>\n<p>It's a combination of declaration merging and declaring global. Having this global interface that you can append to gives you a really nice solution for certain problems.</p>\n</blockquote>\n<blockquote>\n<p>With multiple files we're really solving the problem of colocation. We want a pattern that we can just copy and paste over several files in our application and make sure that we're declaring the types really close to where the implementation is. Of course, we could just declare this in a single interface and just import that to all the places that we need it. Then, of course, it's not colocated. Whereas when they're colocated together, even though you're putting it inside a global scope, it means that if you delete this entire file, then log out just disappears from the ether and it doesn't matter anymore. Weirdly, by using a global here, we're able to get a more modular approach to our types.</p>\n</blockquote>\n<p><strong>Process.env</strong></p>\n<blockquote>\n<p>In Node.js, process.env is a <code>global variable</code> injected during runtime. It is a view of the state of the system environment variables.</p>\n</blockquote>\n<p><strong>Type predicates</strong></p>\n<blockquote>\n<p>sometimes you want more direct control over how types change throughout your code.</p>\n</blockquote>\n<blockquote>\n<p>To define a user-defined type guard, we simply need to define a function whose return type is a type predicate:</p>\n</blockquote>\n<pre><code>function isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n</code></pre>\n<blockquote>\n<p><code>pet is Fish</code> is our type predicate in this example. A predicate takes the form <code>parameterName is Type</code>, where parameterName must be the name of a parameter from the current function signature.</p>\n</blockquote>\n<blockquote>\n<p>Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.</p>\n</blockquote>\n<blockquote>\n<p>Please note that we can need to return the Fish in this case.</p>\n</blockquote>\n<blockquote>\n<p>If we have a function which does not return anything (is void) and maybe only throws error,it would not be enough to use the predicate. We will need to use <code>asserts</code> keyword</p>\n</blockquote>\n<pre><code>interface User {\n  id: string;\n  name: string;\n}\n\ninterface AdminUser extends User {\n  role: \"admin\";\n  organisations: string[];\n}\n\ninterface NormalUser extends User {\n  role: \"normal\";\n}\n\nfunction assertUserIsAdmin(\n  user: NormalUser | AdminUser\n): asserts user is AdminUser {\n  if (user.role !== \"admin\") {\n    throw new Error(\"Not an admin user\");\n  }\n}\n</code></pre>\n<blockquote>\n<p>please note that asserts only works with function declaration and not with arrow functions. workaround is always to use function declaration or such a workaround:</p>\n</blockquote>\n<pre><code>const assertUserIsAdmin: (\n  user: NormalUser | AdminUser\n) => asserts user is AdminUser = (user) => {\n  if (user.role !== \"admin\") {\n    throw new Error(\"Not an admin user\");\n  }\n};\n</code></pre>\n<blockquote>\n<p>as per this comment: <a href=\"https://github.com/microsoft/TypeScript/issues/34523#issuecomment-700491122\">https://github.com/microsoft/TypeScript/issues/34523#issuecomment-700491122</a></p>\n</blockquote>\n<p><strong>CHATGPT</strong></p>\n<blockquote>\n<p>My very first chat with CHATGPT and it already solved my problem:</p>\n</blockquote>\n<blockquote>\n<p>Q: How do I use predicates with generics in typescript</p>\n</blockquote>\n<blockquote>\n<p>A: In TypeScript, you can use generics to create reusable components that work with different types. Predicates can be used to narrow down the type of a generic parameter based on some condition. Here is an example of how to use predicates with generics in TypeScript:</p>\n</blockquote>\n<pre><code>type FilterFunction&#x3C;T> = (item: T) => boolean;\n\nfunction filter&#x3C;T>(items: T[], predicate: FilterFunction&#x3C;T>): T[] {\n  return items.filter(predicate);\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\nconst numbers = [1, 2, 3, \"four\"];\nconst filteredNumbers = filter(numbers, isNumber);\n\nconsole.log(filteredNumbers); // [1, 2, 3]\n</code></pre>\n<blockquote>\n<p>In this example, we define a FilterFunction type that takes a generic parameter T and returns a boolean. We then define a filter function that takes an array of type T and a FilterFunction<T> predicate as arguments. The filter function returns a new array that contains only the items that match the predicate.</p>\n</blockquote>\n<blockquote>\n<p>We also define an isNumber function that takes an unknown value and returns a boolean. This function is used as the predicate in the filter function to filter out non-numeric values from the numbers array.</p>\n</blockquote>\n<blockquote>\n<p>Note that the isNumber function returns a type predicate value is number. This tells TypeScript that if the isNumber function returns true for a value, that value is of type number. This allows TypeScript to narrow down the type of the numbers array from Array&#x3C;number | string> to Array<number>.</p>\n</blockquote>\n<blockquote>\n<p>By using generics and predicates in TypeScript, you can write more reusable and type-safe code.</p>\n</blockquote>\n<blockquote>\n<p>Q: given the above explanation, how would you then turn isNode to a predicate in this piece of code?</p>\n</blockquote>\n<pre><code>interface DOMNodeExtractorConfig&#x3C;T, Result> {\n  isNode: (node: unknown) => boolean;\n  transform: (node: T) => Result;\n}\n</code></pre>\n<blockquote>\n<p>To turn isNode into a predicate, you need to change its return type to node is T. This tells TypeScript that if isNode returns true for a value, that value is of type T. Here's how you can update the DOMNodeExtractorConfig interface with a predicate type for isNode:</p>\n</blockquote>\n<pre><code>interface DOMNodeExtractorConfig&#x3C;T, Result> {\n  isNode: (node: unknown) => node is T;\n  transform: (node: T) => Result;\n}\n</code></pre>\n<blockquote>\n<p>Now, when you use DOMNodeExtractorConfig, TypeScript will know that isNode is a type predicate and can narrow down the type of node accordingly. For example, if T is HTMLDivElement, TypeScript will be able to determine if a value is an HTMLDivElement or not based on the return value of isNode.</p>\n</blockquote>\n<blockquote>\n<p>Here's an example of how you can use DOMNodeExtractorConfig with a predicate for isNode:</p>\n</blockquote>\n<pre><code>function extractNodes&#x3C;T, Result>(config: DOMNodeExtractorConfig&#x3C;T, Result>, nodes: unknown[]): Result[] {\n  return nodes.filter(config.isNode).map(config.transform);\n}\n\nconst divExtractor: DOMNodeExtractorConfig&#x3C;HTMLDivElement, string> = {\n  isNode: (node: unknown): node is HTMLDivElement => node instanceof HTMLDivElement,\n  transform: (div: HTMLDivElement) => div.textContent || \"\",\n};\n\nconst nodes: unknown[] = [document.createElement(\"div\"), document.createElement(\"p\")];\nconst divs = extractNodes(divExtractor, nodes);\n\nconsole.log(divs); // [ &#x3C;div>&#x3C;/div> ]\n</code></pre>\n<blockquote>\n<p>In this example, we define a divExtractor object with a predicate for isNode that checks if a value is an instance of HTMLDivElement. We then call extractNodes with the divExtractor and an array of unknown nodes. extractNodes uses the predicate to filter out non-div nodes and returns an array of transformed HTMLDivElement nodes.</p>\n</blockquote>\n<blockquote>\n<p>By using a predicate for isNode, TypeScript can ensure that only nodes of the correct type are passed to the transform function.</p>\n</blockquote>\n<blockquote>\n<p>Q: wow, you are amazing. thank you!\nA: You're welcome! I'm glad I could help. If you have any more questions, feel free to ask!</p>\n</blockquote>\n<p><strong>Typescript and Classes</strong></p>\n<blockquote>\n<p>We can actually use the name of the class as a type in Typescript. Classes have this funny property where they can actually cross boundaries a little bit and be used as either a type or a runtime value. Pretty cool!</p>\n</blockquote>\n<pre><code>class CustomError extends Error {\n  constructor(message: string, public code: number) {\n    super(message);\n    this.name = \"CustomError\";\n  }\n}\nconst handleCustomError = (error: CustomError) => {\n  console.error(error.code);\n};\n</code></pre>\n<p><strong>Builder patterns</strong></p>\n<blockquote>\n<p>The builder pattern is a design pattern used in software development to simplify the creation of complex objects. In TypeScript, the builder pattern involves creating a builder class that allows you to construct an object step by step.</p>\n</blockquote>\n<blockquote>\n<p>Here's an example to help illustrate how the builder pattern works in TypeScript:</p>\n</blockquote>\n<pre><code>class User {\n  constructor(\n    public readonly firstName: string,\n    public readonly lastName: string,\n    public readonly email: string,\n    public readonly age: number,\n    public readonly address?: string\n  ) {}\n}\n\nclass UserBuilder {\n  private firstName: string = '';\n  private lastName: string = '';\n  private email: string = '';\n  private age: number = 0;\n  private address?: string;\n\n  setFirstName(firstName: string): UserBuilder {\n    this.firstName = firstName;\n    return this;\n  }\n\n  setLastName(lastName: string): UserBuilder {\n    this.lastName = lastName;\n    return this;\n  }\n\n  setEmail(email: string): UserBuilder {\n    this.email = email;\n    return this;\n  }\n\n  setAge(age: number): UserBuilder {\n    this.age = age;\n    return this;\n  }\n\n  setAddress(address: string): UserBuilder {\n    this.address = address;\n    return this;\n  }\n\n  build(): User {\n    return new User(\n      this.firstName,\n      this.lastName,\n      this.email,\n      this.age,\n      this.address\n    );\n  }\n}\n</code></pre>\n<blockquote>\n<p>In the example above, we have a User class that represents a user with basic information such as their first name, last name, email, age, and address. We also have a UserBuilder class that allows us to construct a User object step by step.</p>\n</blockquote>\n<blockquote>\n<p>To create a User object using the builder pattern, you would first create a new UserBuilder object, set its properties using the builder's setXXX methods, and then call the build method to create the User object. Here's an example:</p>\n</blockquote>\n<pre><code>const user = new UserBuilder()\n  .setFirstName('John')\n  .setLastName('Doe')\n  .setEmail('john.doe@example.com')\n  .setAge(30)\n  .setAddress('123 Main St')\n  .build();\n</code></pre>\n<blockquote>\n<p>In the example above, we create a new User object with the UserBuilder class by setting its properties using the builder's setXXX methods and then calling the build method to create the User object.</p>\n</blockquote>\n<blockquote>\n<p>Using the builder pattern can make it easier to construct complex objects with many properties because it allows you to break down the construction process into smaller, more manageable steps.</p>\n</blockquote>\n<p><strong>Definitely typed</strong></p>\n<blockquote>\n<p>Definitely Typed is a repository that contains type definitions for lots and lots of libraries, which aren't built in TypeScript. <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">https://github.com/DefinitelyTyped/DefinitelyTyped</a></p>\n</blockquote>\n<p><strong>Overriding types from external libraries with d.ts file</strong></p>\n<blockquote>\n<p>What if we use a function from external library which is poorly typed and returns a string instead of union of:</p>\n</blockquote>\n<pre><code>export const getAnimatingState = (): string => {\n  if (Math.random() > 0.5) {\n    return \"before-animation\";\n  }\n\n  if (Math.random() > 0.5) {\n    return \"animating\";\n  }\n\n  return \"after-animation\";\n};\n</code></pre>\n<blockquote>\n<p>If we use this function, we will get return of string. Which is very loose:</p>\n</blockquote>\n<pre><code>import { getAnimatingState } from \"external-lib\";\n\nconst animatingState = getAnimatingState();\n</code></pre>\n<blockquote>\n<p>In order to override this, we will need to create a new file with d.ts extension: for example abc.d.ts</p>\n</blockquote>\n<blockquote>\n<p>In this file we will <code>declare module</code> and type our getAnimatingState properly</p>\n</blockquote>\n<pre><code>declare module \"fake-lib\" {\n  export type Mytype = \"before-animation\" | \"animating\" | \"after-animation\";\n  export function getAnimatingState(): Mytype;\n}\n</code></pre>\n<blockquote>\n<p>Then in file where we actually use the function we will import the getAnimatingState from our new d.ts file:</p>\n</blockquote>\n<pre><code>import { getAnimatingState } from \"fake-lib\";\n\nconst animatingState = getAnimatingState();\n</code></pre>\n<blockquote>\n<p>Our function now returns \"before-animation\" | \"animating\" | \"after-animation\" instead of string</p>\n</blockquote>\n<p><strong>Identity functions</strong></p>\n<blockquote>\n<p>identity function takes in a value and returns the same value.</p>\n</blockquote>\n<pre><code>const asConst = &#x3C;T>(t: T) => t;\n</code></pre>\n<blockquote>\n<p>If we call this function with array of object like this:</p>\n</blockquote>\n<pre><code>const fruits = asConst([\n  {\n    name: \"apple\",\n    price: 1,\n  },\n  {\n    name: \"banana\",\n    price: 2,\n  },\n]);\n</code></pre>\n<blockquote>\n<p>The infered return type of asConst function will be Array&#x3C;{name: string, price: number}></p>\n</blockquote>\n<blockquote>\n<p>But we want it to be literal values of it, not just tring or number. We want the concrete thing.</p>\n</blockquote>\n<blockquote>\n<p>How to solve this? We can use an external library ts-toolkit., It exports F and something called Narrow which will help us with the inference:</p>\n</blockquote>\n<pre><code>import { F } from \"ts-toolbelt\";\n\nexport const asConst = &#x3C;T>(t: F.Narrow&#x3C;T>) => t;\n</code></pre>\n<blockquote>\n<p>Now the inferred type will be:</p>\n</blockquote>\n<pre><code>[\n  {\n    name: \"apple\",\n    price: 1,\n  },\n  {\n    name: \"banana\",\n    price: 2,\n  },\n]\n</code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>\n<pre><code></code></pre>","frontmatter":{"title":"TypeScript"},"excerpt":"Photo by Matej from Pexels Intro This article is basically my notes following an amazing Typescript course by Maximilian Schwarzm√ºller and‚Ä¶"}},"pageContext":{"slug":"/TypeScript/"}},"staticQueryHashes":["2199005656","63159454"]}