{"componentChunkName":"component---src-templates-blog-post-js","path":"/Concurrency/","webpackCompilationHash":"227f9fa1248410006df5","result":{"data":{"markdownRemark":{"html":"<p><img src=\"https://i.imgur.com/xdi5UzW.png\" title=\"Photo by Pixabay from Pexels\"></p>\n<p>JavaScript Concurrency: Promise then\nThis course covers concurrency, which means \"two or more events happening at the same time.\" We'll explore a few concurrency models, focusing on those that are used in JavaScript. No experience with concurrency is necessary, but you should know these parts of JavaScript:</p>\n<p>null and undefined.\nVariable definitions with var, let, and const.\nConditionals (if) and ternary conditionals (a ? y : b).\nC-style for loops: for (let i=0; i&#x3C;10; i++) { ... }.\nRegular functions: function f() { ... }.\nArrow functions: const f = () => { ... }.\nPassing functions as arguments to other functions (\"callback functions\").\nThis course is about JavaScript, but we'll start with some Python code as a contrast to JavaScript. The Python example below shows that network code in Python doesn't look special: it looks like a normal series of function calls. The example reads executeprogram.com using the Requests HTTP library, then prints the first line of text.</p>\n<p>(Unlike most code in Execute Program, this example isn't actually executed because it's written in Python, not JavaScript. We'll tell you in the rare cases where code examples aren't executed.)</p>\n<blockquote>\n<p>import requests\nr = requests.get('<a href=\"https://www.executeprogram.com&#x27;\">https://www.executeprogram.com'</a>)\nr.text.split(\"\\n\")[0]\n'<!doctype html>'\nEach line above waits for the previous line to finish. Python calls requests.get after the \"requests\" library has been imported, and r.text is only accessed after requests.get has finished getting the data from the server. The usual term for this is \"blocking IO\": the requests.get function call stops the code's execution until all of the data is retrieved from the server.</p>\n</blockquote>\n<p>With a few exceptions, JavaScript doesn't support blocking IO, so we can't write code that looks simple like the Python code above. Instead, JavaScript provides different, more complex ways to access networks, disks, and other external systems.</p>\n<p>(There are some exceptions where JavaScript code does block. Node is a server-side JavaScript runtime, but it provides optional blocking versions of some of its APIs. And browsers' old XMLHttpRequest API can block, though that behavior is now deprecated. But these are unusual exceptions.)</p>\n<p>If JavaScript code doesn't block, how do we wait for network requests? Modern JavaScript code often solves this problem with promises, which were designed for exactly this purpose.</p>\n<p>To approach promises, we'll temporarily forget about networks and examine some very normal-looking JavaScript code:</p>\n<blockquote>\n<p>let value = 5\nvalue = value * 2\nvalue = value * 3\nvalue = value + 1\nvalue\n31\nWe can rewrite those assignments as small functions. If we immediately call each function, they'll have the same effect as the assignments above.</p>\n</blockquote>\n<blockquote>\n<p>let value = 5\nvalue = (n => n * 2)(value)\nvalue = (n => n * 3)(value)\nvalue = (n => n + 1)(value)\nvalue\n31\nThis is a weird way to write a normal series of data transformations. However, it's also how promises work!</p>\n</blockquote>\n<p>With promises, we write each step as a small (or occasionally large) function. Instead of repeatedly calling the functions ourselves, the promises call them for us. Here's the same example written using promises, followed by an explanation. Make sure to note that each of the small functions here is identical to its equivalent above.</p>\n<blockquote>\n<p>Promise.resolve(5)\n.then(n => n * 2)\n.then(n => n * 3)\n.then(n => n + 1)\n31\nThe Promise.resolve(5) call creates a promise holding the value 5. We call its then method, providing a small callback function, n => n * 2. The callback receives the previous promise's value, 5, as an argument. It returns a new value, 10. That value is wrapped up in a new promise, which allows us to chain the next then call.</p>\n</blockquote>\n<p>The initial Promise.resolve call returns a promise, and each of the then calls also returns a promise. There are a total of four promises constructed in that example. Each has a then method.</p>\n<p>The example's final result is a promise containing the value 31, equivalent to what we'd get by calling Promise.resolve(31). When a code example results in a promise, Execute Program will automatically unwrap it for us. That's why the example above showed a result of 31, rather than showing the complex implementation details of the promise itself.</p>\n<p>(Execute Program does that by attaching its own then callback to the promise. That callback receives 31 as its argument. Once Execute Program has that value, it can show it as the result of the code example.)</p>\n<p>There's nothing special about the number of thens that we've attached; we can chain as few or as many as we like.</p>\n<blockquote>\n<p>Promise.resolve(5)\n.then(n => n * 2)\n.then(n => n * 3)\n.then(n => n + 1)\n.then(n => n + 200)\n231\nThere's also nothing special about numbers; a promise can contain any JavaScript value.</p>\n</blockquote>\n<blockquote>\n<p>Promise.resolve(5)\n.then(n => n * 2)\n.then(n => n.toString())\n'10'\nOur then callbacks can return nothing at all, in which case they'll implicitly return undefined.</p>\n</blockquote>\n<blockquote>\n<p>Promise.resolve(5)\n.then(n => {</p>\n</blockquote>\n<pre><code>/* Do nothing. */\n</code></pre>\n<p>  })\nundefined\nPromise.resolve works in the same way: if we omit its argument, the promise will contain undefined.</p>\n<blockquote>\n<p>Promise.resolve()\nundefined\nHere's a code problem for you to complete:</p>\n</blockquote>\n<p>Add another then call to wrap the promise's string value in an array.</p>\n<blockquote>\n<p>Promise.resolve(5)\n.then(n => n * 2)\n.then(n => n.toString())\n.then(n=> [n])</p>\n</blockquote>\n<p>GOAL:\n['10']\nYOURS:\n['10']\nIf these examples feel contrived, it's because they are! Each would be simpler if we used regular variable assignment instead of promises. However, they've shown us the basic structure of promises: we build a series of callbacks by repeatedly calling then, and each callback sees the previous callback's result.</p>\n<p>In the next lesson, we'll see how promises interact with time. The simple value = (n => n * 2)(value) calls that we started with happened immediately. But promises don't call their then callbacks immediately. Instead, promises schedule code to run in the future, which we can never do with regular variable assignment!</p>\n<p>JavaScript Concurrency: Promises are asynchronous\nHere's a promise that creates an array, pushes a value into it, and returns it. At the end of the example, Execute Program automatically unwraps the promise to find what's inside: the array returned by the callback.</p>\n<blockquote>\n<p>Promise.resolve(5).then(n => {\nconst array = []\narray.push(n)\nreturn array\n})\n[5]\nThe next example looks similar to the one above, but with a small tweak. We create the array outside the promise, then the promise pushes the value into it, then we return the array at the end.</p>\n</blockquote>\n<p>It does something different! The example below gives [].</p>\n<blockquote>\n<p>const array = []</p>\n</blockquote>\n<p>Promise.resolve(5).then(n => {\narray.push(n)\n})</p>\n<p>array\n[]\nThis is our first suggestion that promises are about time. Here's the hidden effect of promises:</p>\n<p>When we attach a then callback, we're asking the browser's JavaScript runtime to run that callback at some time in the future.</p>\n<p>In the example above, that time never came! We created a promise that said \"please call this callback later\", then we immediately returned a value without waiting for the callback.</p>\n<p>(In most situations, the promise's code would eventually run, pushing the 5 onto the array. But Execute Program only shows the result of the code example at the moment when the code finished. Execute Program will only wait for promises when they're directly returned by the last line in the example.)</p>\n<p>To get the array out, we need to ensure that the example returns a promise.</p>\n<p>In this example, remember that the last then in a chain \"wins\": it determines what value the final promise contains. This example's return value is the final promise: the one containing the array. Execute Program automatically unpacks the promise, so the array is the final result of the example.</p>\n<blockquote>\n<p>const array = []</p>\n</blockquote>\n<p>Promise.resolve(5).then(n => {\narray.push(n)\n}).then(() => {\nreturn array\n})\n[5]\nWe can instrument our code to see the exact order of operations in our code. (The verb \"instrument\" means \"attach measurement instruments to\". It's a great way to learn how unfamiliar systems work!)</p>\n<p>In the next example, we store promises in variables, creating new promises by calling the previous ones' then methods. We push strings onto the array at various times. By looking at the order of the strings in the array, we can see which code ran when.</p>\n<p>The \"before\" and \"after\" values are pushed first. Then the two thens run in order.</p>\n<blockquote>\n<p>const array = []\narray.push('before')</p>\n</blockquote>\n<p>const promise1 = Promise.resolve()\nconst promise2 = promise1.then(() => {\narray.push('then1')\n})\nconst promise3 = promise2.then(() => {\narray.push('then2')\nreturn array\n})</p>\n<p>array.push('after')\npromise3\n['before', 'after', 'then1', 'then2']\nLet's break that down. First, the example code runs from top to bottom.</p>\n<p>The first promise is created. Promise.resolve doesn't schedule anything, so nothing else happens.\nThe second promise is created by calling promise1.then. The browser schedules that callback to run at some time in the future. When it runs, it will add \"then1\" to the array.\nThe third promise is created by calling promise2.then. The browser schedules that callback as well. It will eventually add \"then2\" to the array.\nNone of our then callbacks are called yet; they've only been scheduled to run in the future. That's why 'before' and 'after' show up first in the array, before 'then2' or 'then2'.</p>\n<p>Execute Program sees that the example returned a promise, promise3. It attaches yet another then handler to the promise, then stops executing. (It can't do anything else until it finds out what's inside that promise!)</p>\n<p>promise1 was never pending because Promise.resolve never schedules code to run in the future. The other two promises, both created with then, are still pending. Execute Program's promise is also pending.</p>\n<p>Now the JavaScript runtime begins resolving the promises, one by one:</p>\n<p>The first pending callback is promise2's. It pushes 'then1' onto the array and returns undefined.\nThe next pending callback is promise3's. This callback pushes 'then2' onto the array, then returns the array.\nThe next pending callback is Execute Program's. You can't see the code for this one because it's inside Execute Program itself. It was created by calling then on promise3, so its callback gets array as an argument. The code in that callback renders the example's result to the browser's DOM, which is how you can see it above.\nHere's a code problem for you to complete:</p>\n<p>Modify this code to ensure that 'after' is only pushed into the array after 'then' is pushed. You can do that by putting the final array.push call in a promise chained with then: promise2.then(...). Make sure that your new then callback returns the array so our test code can compare it against the expected value.</p>\n<blockquote>\n<p>const array = []\narray.push('before')</p>\n</blockquote>\n<p>const promise1 = Promise.resolve(5)\nconst promise2 = promise1.then(() => {\narray.push('then')\n})\nconst promise3=promise2.then(()=>{\narray.push('after')\nreturn array\n})</p>\n<p>promise3\nGOAL:\n['before', 'then', 'after']\nYOURS:\n['before', 'then', 'after']\nPromises are a subtle and tricky topic, so there are a lot of details and implications to explore beyond this point. But we've now seen the core idea: promises schedule code to run later, and we can add callback functions that will run after a promise completes.</p>\n<p>Reference:</p>\n<p><a href=\"https://docs.npmjs.com/about-semantic-versioning\">https://docs.npmjs.com/about-semantic-versioning</a>  </p>\n<p>JavaScript Concurrency: Review\nIt's time to review! These examples are all taken from lessons that you've finished. Revisiting them makes sure that you haven't forgotten anything.</p>\n<p>Type in what each expression will evaluate to. For example, for the prompt 1 + 1, you would type 2.</p>\n<p>In this course, some code examples will intentionally cause errors. You can type error if the code will result in an error.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Add another then call to wrap the promise's string value in an array.</p>\n<blockquote>\n<p>Promise.resolve(5)\n.then(n => n * 2)\n.then(n => n.toString())\n.then(n => [n])</p>\n</blockquote>\n<p>GOAL:\n['10']\nYOURS:\n['10'] </p>\n<blockquote>\n<p>Promise.resolve(5)\n.then(n => n * 2)\n.then(n => n.toString())\n'10' </p>\n<p>const array = []</p>\n</blockquote>\n<p>Promise.resolve(5).then(n => {\narray.push(n)\n})</p>\n<p>array\n[] </p>\n<blockquote>\n<p>const array = []\narray.push('before')</p>\n</blockquote>\n<p>const promise1 = Promise.resolve()\nconst promise2 = promise1.then(() => {\narray.push('then1')\n})\nconst promise3 = promise2.then(() => {\narray.push('then2')\nreturn array\n})</p>\n<p>array.push('after')\npromise3\n['before', 'after', 'then1', 'then2']\nHere's a code problem for you to complete:</p>\n<p>Modify this code to ensure that 'after' is only pushed into the array after 'then' is pushed. You can do that by putting the final array.push call in a promise chained with then: promise2.then(...). Make sure that your new then callback returns the array so our test code can compare it against the expected value.</p>\n<blockquote>\n<p>const array = []\narray.push('before')</p>\n</blockquote>\n<p>const promise1 = Promise.resolve(5)\nconst promise2 = promise1.then(() => {\narray.push('then')\n})\nconst promise3= promise2.then(()=>{array.push('after')\nreturn array})</p>\n<p>promise3</p>\n<p>GOAL:\n['before', 'then', 'after']\nYOURS:\n['before', 'then', 'after']\nJavaScript Concurrency: Promise constructor\nSo far, we've only created initial promises with Promise.resolve. Then we've attached thens to the promises.</p>\n<blockquote>\n<p>Promise.resolve(5).then(n => n + 1)\n6\nWe can simplify that by using the new Promise constructor instead.</p>\n</blockquote>\n<p>The constructor takes a callback as an argument, but it's different from the then callbacks that we've seen. A then callback gets the promise's value as its argument. When doing new Promise, there is no existing value.</p>\n<p>Instead, our callback will get another function as an argument: resolve. Calling resolve with a value will put a value inside the promise, \"fulfilling\" it.</p>\n<blockquote>\n<p>new Promise(resolve => resolve(5))\n5\nOnce we have a promise, we can always call then on it.</p>\n</blockquote>\n<blockquote>\n<p>new Promise(resolve => resolve(5)).then(n => n * 2)\n10\nYou might wonder: when we do new Promise(...), passing a callback to the constructor, is our callback called immediately? Or is it scheduled for execution later, like then callbacks are? We can find out by instrumenting the promise using our array push trick.</p>\n</blockquote>\n<p>If the callback is called immediately, we should see a result of ['before', 'resolving', 'after']. If the callback is scheduled, we should see ['before', 'after', 'resolving']. Take a guess at which one it is.</p>\n<blockquote>\n<p>const array = []\narray.push('before')</p>\n</blockquote>\n<p>new Promise(resolve => {\narray.push('resolving')\nresolve()\n})</p>\n<p>array.push('after')\nPromise.resolve(array)\n['before', 'resolving', 'after']\nThe constructor's callback is called synchronously! Just to be very sure, we can double-check that by doing a different kind of test: don't return a promise from our example. Then there's nothing for Execute Program to wait for, so no scheduled code will run.</p>\n<p>Our constructor callback will still run because it's not scheduled. It's called immediately, synchronously, before the constructor completes.</p>\n<p>(The next example is the same as the one above, except that it returns the array directly rather than wrapping it in a promise.)</p>\n<blockquote>\n<p>const array = []\narray.push('before')</p>\n</blockquote>\n<p>new Promise(resolve => {\narray.push('resolving')\nresolve()\n})</p>\n<p>array.push('after')\narray\n['before', 'resolving', 'after']\nThe promise constructor can only take a callback function. We can't pass a value to wrap, like new Promise(5); that will cause an error. To directly wrap a value, we can use the familiar Promise.resolve(5) instead.</p>\n<p>(You can type error when a code example will throw an error.)</p>\n<blockquote>\n<p>new Promise(5)\nTypeError: Promise resolver 5 is not a function\nHere's a code problem for you to complete:</p>\n</blockquote>\n<p>Build a new promise with new Promise, putting the value 'it worked' inside it. We've included some code that adds a then to convert the string into upper case.</p>\n<blockquote>\n<p>new Promise(resolve => resolve('it worked'))</p>\n</blockquote>\n<p>.then(string => string.toUpperCase())\nGOAL:\n'IT WORKED'\nYOURS:\n'IT WORKED'\nJavaScript Concurrency: Leaked promises still run\nThere are many ways to implement promises and other similar features. One implementation decision is: if we create a promise but never use its result, does its code run or not? We can find out by adding instrumentation.</p>\n<blockquote>\n<p>const array = []\narray.push('before')</p>\n</blockquote>\n<p>Promise.resolve().then(() => {\narray.push('then')\n})</p>\n<p>array\n['before']\nIt seems like the answer is no: a then isn't called unless we try to use the promise's value. However, that's not true!</p>\n<p>The example above returned an array, which isn't a promise, so Execute Program didn't wait for anything. The promise's code was scheduled, but it didn't get a chance to run. We can let the promise run by creating a second promise and returning it, which will make Execute Program wait.</p>\n<p>In the next example, note that the second promise doesn't reference the first promise in any way. The first promise is \"leaked\": we didn't attach a then to it, and we didn't return it or store it anywhere. However, it still runs and modifies the array!</p>\n<blockquote>\n<p>const array = []\narray.push('before')</p>\n</blockquote>\n<p>Promise.resolve().then(() => {\narray.push('then')\n})</p>\n<p>array.push('after')\nPromise.resolve().then(() => array)\n['before', 'after', 'then']\nHere's what happened when that code executed:</p>\n<p>We push 'before'.\nA promise is created with a callback that will push 'then'. The callback doesn't run yet.\nAnother promise is created with a callback that returns the array. This callback also doesn't run yet.\nExecute Program sees that the example returned a promise, so it attaches another then callback that will render the example's results.\nNo promise callbacks have been called at this point. However, all of them are in a list managed by the JavaScript runtime, waiting to run. The callbacks are stored in the order that they were created: the array.push('then') callback is first, followed by the array callback, followed by Execute Program's \"render the finished example\" callback.</p>\n<p>The JavaScript runtime begins executing those scheduled callbacks in order. The first callback pushes 'then' onto the array, the second callback returns the array, and the third callback (Execute Program's) renders the array as you see it above.</p>\n<p>How does the runtime know that it should start calling the scheduled callbacks rather than doing some other kind of work? That's the secret of JavaScript: there is no other kind of work; everything is done by calling scheduled callbacks! At every point, the runtime chooses the next callback in its internal list and calls it.</p>\n<p>(As you can probably guess, there are some other subtleties in a system as complex as a web browser. For example, the browser also maintains lists of other kinds of events, like mouse and keyboard events from the user. However, thinking about browsers as always blindly calling the next callback will get you pretty far!)</p>\n<p>Let's stress test this a bit. If we create several promises, leaking all of them, will they all run in order?</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Before modifying this code, try running it to see what it does. The array is empty, which means that none of the promises' callbacks was called.</p>\n<p>Wrap the final array in a promise by using Promise.resolve(array). The other five promises are still leaked, but they're also put into the JavaScript runtime's list before your new promise. That means that they'll run before your promise, so each of them will do their push call.</p>\n<blockquote>\n<p>const array = []\nfor (const i of [1, 2, 3, 4, 5]) {\nPromise.resolve().then(() => array.push(i))\n}\nPromise.resolve(array)</p>\n</blockquote>\n<p>GOAL:\n[1, 2, 3, 4, 5]\nYOURS:\n[1, 2, 3, 4, 5]\nIn production systems, it's usually dangerous to leak promises. When we leak a promise, we lose the ability to wait for it, so we're giving up the ability to sequence other actions after it!</p>","frontmatter":{"title":"Concurrency"},"excerpt":"JavaScript Concurrency: Promise then\nThis course covers concurrency, which means \"two or more events happening at the same time.\" We'll…"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Concurrency/"}}}