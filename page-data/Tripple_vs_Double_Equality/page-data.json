{"componentChunkName":"component---src-templates-blog-post-js","path":"/Tripple_vs_Double_Equality/","webpackCompilationHash":"3f66a09056a0d7195aa3","result":{"data":{"markdownRemark":{"html":"<p><img src=\"https://i.imgur.com/hPA457A.jpg\" title=\"Photo by Ivan Bertolazzi from Pexels\"></p>\n<p>WORK IN PROGRESS</p>\n<p>The Problem</p>\n<p>JavaScript has two visually similar, yet very different, ways to test equality. You can test equality with == or ===. Here are the differences:</p>\n<p>Triple Equals</p>\n<p>When using triple equals === in JavaScript, we are testing for strict equality. This means both the type and the value we are comparing have to be the same.\nLets look at a couple examples of strict equality.\nIn this first example we’re comparing the number 5 with the number 5. As expected, true is returned. Both are numbers, and both share the same value of 5.\n5 === 5\n// true\nWith this in mind, we can look at two more examples that will return true:\n'hello world' === 'hello world'\n// true (Both Strings, equal values)\ntrue === true\n// true (Both Booleans, equal values)\nAwesome. Now lets take a look at some examples that will return false:\nIn this example we’ll compare the number 77 to the string value of 77. This means our operands will have the same value, but a different type. This will return false\n77 === '77'\n// false (Number v. String)\nHere are two additional examples:\n'cat' === 'dog'\n// false (Both are Strings, but have different values)\nfalse === 0\n// false (Different type and different value)\nAwesome! Again, the key takeaway for triple (strict) equality is that both the type and the value we are comparing have to be the same.</p>\n<p>Double equals</p>\n<p>When using double equals in JavaScript we are testing for loose equality. Double equals also performs type coercion.\nType coercion means that two values are compared only after attempting to convert them into a common type.\nAn example will illustrate this. Recall earlier when we tested the following with strict equality:\n77 === '77'\n// false (Number v. String)\n77 does not strictly equal '77' because they have different types. However, if we were to test these values with loose equality…\n77 == '77'\n// true\nYou can see we get true. That because of type coercion. JavaScript will actually try to convert our values into a like type. In this case, it succeeds. The string value of '77' can easily be converted into the number value of 77. Since 77 equals 77, we get our answer of true.\nLets look at one more example.\nRecall earlier when we tested with strict equality if false equals 0:\nfalse === 0\n// false (Different type and different value)\nThis is obviously false. However, if we run the same equation with loose equality…\nfalse == 0\n// true\nWe get true? Why is this? It has to do with falsy values in JavaScript. We’ll explore this concept in the next section.</p>\n<p>Falsy Values</p>\n<p>Okay, so why does false == 0 in JavaScript? It’s complex, but it’s because in JavaScript 0 is a falsy value.\nType coercion will actually convert our zero into a false boolean, then false is equal to false.\nThere are only six falsy values in JavaScript you should be aware of:\nfalse — boolean false\n0 — number zero\n“” — empty string\nnull\nundefined\nNaN — Not A Number\nFalsy Value Comparison\nThe following you can consider to be ‘rules’ of falsy values. These are things you should ultimately memorize if you will be working with JavaScript often.\nfalse, 0, and \"\"\nWhen comparing any of our first three falsy values with loose equality, they will always be equal! That’s because these values will all coerce into a false boolean.\nfalse == 0\n// true\n0 == \"\"\n// true\n\"\" == false\n// true</p>\n<ol start=\"2\">\n<li>null and undefined\nWhen comparing null and undefined, they are only equal to themselves and each other:\nnull == null\n// true\nundefined == undefined\n// true\nnull == undefined\n// true\nIf you try to compare null to any other value, it will return false.</li>\n<li>NaN\nLastly, NaN is not equivalent to anything. Even cooler, it’s not even itself!\nNaN == null\n// false\nNaN == undefined\n// false\nNaN == NaN\n// false\n<img src=\"https://i.imgur.com/VsPEaKZ.jpg\" title=\"Photo by Dominika Roseclay from Pexels\"></li>\n</ol>\n<p>Key Takeaways\nAs you’ve seen, type coercion can get a bit crazy in JS. Unless you’re very familiar with JavaScript, loose equality can lead to more headaches than it’s worth. Memorizing the six falsy values and the rules associated with them can go a long way towards understanding loose equality.\nTriple Equals is superior to double equals. Whenever possible, you should use triple equals to test equality. By testing the type and value you can be sure that you are always executing a true equality test.\nReference:</p>\n<p><a href=\"https://codeburst.io/javascript-double-equals-vs-triple-equals-61d4ce5a121a\">https://codeburst.io/javascript-double-equals-vs-triple-equals-61d4ce5a121a</a></p>\n<p><img src=\"https://i.imgur.com/fIyDFmN.jpg\" title=\"Photo by Pixabay from Pexels\"></p>","frontmatter":{"title":"Tripple vs Double Equality"},"excerpt":"WORK IN PROGRESS The Problem JavaScript has two visually similar, yet very different, ways to test equality. You can test equality with…"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Tripple_vs_Double_Equality/"}}}