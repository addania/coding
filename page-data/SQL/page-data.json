{"componentChunkName":"component---src-templates-blog-post-js","path":"/SQL/","webpackCompilationHash":"d2adef5d4b45a9f9f314","result":{"data":{"markdownRemark":{"html":"<p><img src=\"https://i.imgur.com/ETtwNWY.jpg\" title=\"Photo from wallpapersafari.com\"><p style=\"font-size: 12px; text-align: right\"><em>Photo from wallpapersafari.com</em></p></p>\n<blockquote>\n<p>SQL stands for Structured Query Language. SQL is used to communicate with a database. </p>\n</blockquote>\n<blockquote>\n<p>SQL manages data well. In SQL, data is stored in tables made up of columns.</p>\n</blockquote>\n<blockquote>\n<p>You can try running your sql statements online here: <a href=\"https://www.w3schools.com/sql/trysql.asp?filename=trysql_op_in\">https://www.w3schools.com/sql/trysql.asp?filename=trysql_op_in</a></p>\n</blockquote>\n<blockquote>\n<p>Please note that in general: You can't execute a query using Javascript because Javascript can't connect directly with your database, but you can use AJAX. With this technology you'll be able to send a request to a PHP (or other server side language) page where resides the code that can execute a query to your db and get back the result of this query.</p>\n</blockquote>\n<blockquote>\n<p>Creating a table called <code>users</code> which contains columns email and name. Both email and name will be a text field. exec in this case is just a custom JS function</p>\n</blockquote>\n<pre><code class=\"language-SQL\">exec(`CREATE TABLE users (email TEXT, name TEXT)`)\n</code></pre>\n<blockquote>\n<p>In the online tool of w3schools we write those statements without <code>exec(<code></code>)</code></p>\n</blockquote>\n<pre><code>CREATE TABLE users (email TEXT, name TEXT)\n</code></pre>\n<blockquote>\n<p>Now creating a row/data entry in our users table:</p>\n</blockquote>\n<pre><code class=\"language-SQL\">exec(`INSERT INTO users (email, name) VALUES ('adda@example.com', 'Adda')`)\n</code></pre>\n<blockquote>\n<p>Then we can access data from this table with following code:</p>\n</blockquote>\n<pre><code class=\"language-SQL\">exec(`SELECT * FROM users`)\n</code></pre>\n<blockquote>\n<p><code>*</code> means all the columns!!</p>\n</blockquote>\n<blockquote>\n<p>Select always returns an array of objects:</p>\n</blockquote>\n<pre><code>[{email: 'adda@example.com', name: 'Adda'}] \n</code></pre>\n<blockquote>\n<p>Once again: Select returns an array of objects which we are selecting</p>\n</blockquote>\n<blockquote>\n<p>Other SQL methods like create table, insert, delete, alter or begin return empty arrays and alter the table</p>\n</blockquote>\n<pre><code class=\"language-SQL\">exec(`INSERT INTO users (email, name) VALUES ('adda@example.com', 'Adda')`)\n[]\n</code></pre>\n<blockquote>\n<p>SQL keywords like INSERT and SELECT ignore case, so INSERT and InSeRt mean the same thing. Table and column names also ignore case, so users and USErs refer to the same table. However convention is: SQL keywords in UPPERCASE, like CREATE and INSERT and names of tables and columns will be lower<em>snake</em>case, like user_name</p>\n</blockquote>\n<blockquote>\n<p>If we try to insert into or select form a column that doesn't exist, the database system will error.</p>\n</blockquote>\n<blockquote>\n<p>NUmbers are stored as REAL (with decimal) or as INTEGER (without decimal)</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE rectangles (width REAL, height REAL`)\n</code></pre>\n<blockquote>\n<p>There are many more times. Example for Postgress database: <a href=\"https://www.postgresql.org/docs/11/datatype.html\">https://www.postgresql.org/docs/11/datatype.html</a></p>\n</blockquote>\n<blockquote>\n<p>Instead of always selecting all columns with SELECT * we can define columns we only want to see</p>\n</blockquote>\n<pre><code>exec(`SELECT name FROM users`)\n</code></pre>\n<blockquote>\n<p>We can select multiple columns by separating them with comma</p>\n</blockquote>\n<pre><code>exec(`SELECT age, name FROM users`)\n</code></pre>\n<blockquote>\n<p>Now how to select only given rows? We use SELECT * WHERE\nHere is the table:</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE users (email TEXT NOT NULL, name TEXT NOT NULL)`)\nexec(`INSERT INTO users (email, name) VALUES ('betty.j@example.com', 'Betty')`)\nexec(`INSERT INTO users (email, name) VALUES ('betty.k@example.com', 'Betty')`)\nexec(`INSERT INTO users (email, name) VALUES ('cindy@example.com', 'Cindy')`)\n</code></pre>\n<blockquote>\n<p>Here we only select oen row:</p>\n</blockquote>\n<pre><code>exec(`SELECT * FROM users where name = 'Cindy'`)\n[{email: 'cindy@example.com', name: 'Cindy'}]\n</code></pre>\n<blockquote>\n<p>When we use both a WHERE and a SELECT, they can reference different columns.</p>\n</blockquote>\n<pre><code>exec(`SELECT email FROM users WHERE name = 'Cindy'`)\n[{email: 'cindy@example.com'}] \n</code></pre>\n<blockquote>\n<p>You can also use lless than &#x3C; or bigger than > or not equal to != or another way how to write not equal to &#x3C;></p>\n</blockquote>\n<pre><code>exec(`SELECT name FROM cats WHERE age > 4 `)\n</code></pre>\n<blockquote>\n<p>We can also have multiple conditions connected with logical AND or OR:</p>\n</blockquote>\n<pre><code>exec(`\n  SELECT email FROM users\n  WHERE name = 'Betty' AND email = 'betty.j@example.com';\n`)\n</code></pre>\n<blockquote>\n<p>WHERE clauses can call functions. For example, SQLite defines a length function that works on strings.</p>\n</blockquote>\n<pre><code>exec(`SELECT name FROM users WHERE length(name) > 4`)\n</code></pre>\n<blockquote>\n<p>Here are examples of postgress database functions: <a href=\"https://www.postgresql.org/docs/12/functions.html\">https://www.postgresql.org/docs/12/functions.html</a></p>\n</blockquote>\n<blockquote>\n<p>We can also define our own</p>\n</blockquote>\n<blockquote>\n<p>Like most programming languages, SQL supports \"null\", which indicates the absence of a value. For example, a user's login_count might be null if they've never logged in.</p>\n</blockquote>\n<blockquote>\n<p>When a column is allowed to be null, we say that it's \"nullable\". </p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE users (name TEXT, login_count INTEGER)`)\nexec(`INSERT INTO users (name, login_count) VALUES(NULL, NULL)`)\nexec(`SELECT * FROM users`)\n[{login_count: null, name: null}]\n</code></pre>\n<blockquote>\n<p>We'll explicitly mark columns as either NULL or NOT NULL.We can tell the database to disallow null values by adding NOT NULL to a column declaration. Trying to insert a null value into a NOT NULL column is an error.</p>\n</blockquote>\n<blockquote>\n<p>it's best to make columns NOT NULL unless you have a very good reason not to. When you do make a column nullable, it's best to explicitly mark it as NULL by defining it as phone_number TEXT NULL. </p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE cats (name TEST NOT NULL, age INTEGER NULL)`)\n</code></pre>\n<blockquote>\n<p>Updating value for each row for a given column:</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE cats (name TEXT, age INTEGER)`)\nexec(`INSERT INTO cats (name, age) VALUES ('Ms. Fluff', 3)`)\nexec(`INSERT INTO cats (name, age) VALUES ('Keanu', 2)`)\nexec(`UPDATE cats SET name = 'Cat'`)\nexec(`SELECT name FROM cats`)\n[{name: 'Cat'}, {name: 'Cat'}]\n</code></pre>\n<blockquote>\n<p>Changing value only for specific row:</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE cats (name TEXT, age INTEGER)`)\nexec(`INSERT INTO cats (name, age) VALUES ('Ms. Fluff', 3)`)\nexec(`INSERT INTO cats (name, age) VALUES ('Keanu', 2)`)\nexec(`UPDATE cats SET name = 'Mr. Reeves' WHERE name = 'Keanu'`)\nexec(`SELECT name FROM cats`)\n[{name: 'Ms. Fluff'}, {name: 'Mr. Reeves'}] \n</code></pre>\n<blockquote>\n<p>If our UPDATE's WHERE clause matches multiple rows, then all of those rows will be updated. This makes UPDATE potentially dangerous. Be very careful that your UPDATE only affects the rows that you expected it to update!</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE rects (kind TEXT, width REAL, height REAL)`)\nexec(`INSERT INTO rects (kind, width, height) VALUES ('tall', 1.1, 2.7)`)\nexec(`INSERT INTO rects (kind, width, height) VALUES ('tall', 4.4, 4.3)`)\nexec(`INSERT INTO rects (kind, width, height) VALUES ('tall', 0.4, 8.9)`)\nexec(`INSERT INTO rects (kind, width, height) VALUES ('tall', 100, 0.1)`)\nexec(`UPDATE rects SET kind ='wide' WHERE width > height`)\n</code></pre>\n<blockquote>\n<p>It is possible to insert multiple rows. When we insert many rows with separate INSERT statements, we're putting heavy load on the database. The database has to parse each insert statement, execute it safely by acquiring and releasing locks, and store its result on disk. All of those processes happen for every insert. There are many ways to mitigate those costs, but there's one way that reduces them all at once: multi-row inserts. </p>\n</blockquote>\n<blockquote>\n<p>The syntax is straightforward: we write an insert statement as normal, but with multiple rows of data after VALUES. Each one becomes a separate row in the database. Now, the database only has to parse, lock, execute, and store data once. The amount of data stored is the same, but the overhead is much smaller.</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE cats (name TEXT NOT NULL)`)\nexec(`\n  INSERT INTO cats (name) VALUES \n    ('Ms. Fluff'), \n    ('Keanu')\n    \n`)\nexec(`SELECT * FROM cats`)\nGOAL:   \n[{name: 'Ms. Fluff'}, {name: 'Keanu'}]\n</code></pre>\n<pre><code>exec(`CREATE TABLE users (name TEXT NOT NULL)`)\nexec(`\n  INSERT INTO users (name) VALUES\n    ('Amir'),\n    ('Betty'),\n    ('Cindy')\n`)\nexec(`SELECT * FROM users`)\n[{name: 'Amir'}, {name: 'Betty'}, {name: 'Cindy'}]\n</code></pre>\n<blockquote>\n<p>Selecting expressions\nWe can SELECT many kinds of expressions: columns, like we've seen already; but also constants, mathematical expressions, and function calls. For example, if we SELECT 1, we get 1 back. If we SELECT 1 + 1, we get 2 back.</p>\n</blockquote>\n<pre><code>exec(`SELECT 1`)\n[{'1': 1}] \n</code></pre>\n<pre><code>exec(`SELECT 1 + 1`)\n[{'1 + 1': 2}] \n</code></pre>\n<blockquote>\n<p>The output here is the same as ever: an array of objects. But now, there are no column names. Instead, the properties on the \"row\" object are the expressions that we queried.</p>\n</blockquote>\n<pre><code>exec(`SELECT 2 * 3`)\n[{'2 * 3': 6}] \n</code></pre>\n<p>We can also query functions that return values dynamically. For example, the current date is written as DATE('now') in SQLite. This query asks: is the current date after DATE(0), which was January 1, 1970?</p>\n<pre><code>exec(`SELECT DATE('now') > DATE(0)`)\n[{\"DATE('now') > DATE(0)\": 1}] \n</code></pre>\n<blockquote>\n<p>Select the number 17.</p>\n</blockquote>\n<pre><code>exec(`SELECT 17`)\n[{'17': 17}]\n</code></pre>\n<blockquote>\n<p>we can enforce a column to have unique valueswith work UNIQUE.  Inserting a duplicate value into a UNIQUE column is an error.</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE users (email TEXT UNIQUE, name TEXT)`)\nexec(`INSERT INTO users (email, name) VALUES ('amir@example.com', 'Amir')`)\nexec(`SELECT email FROM users`)\n[{email: 'amir@example.com'}] \n</code></pre>\n<pre><code>exec(`CREATE TABLE users (email TEXT UNIQUE, name TEXT)`)\nexec(`INSERT INTO users (email, name) VALUES ('amir@example.com', 'Amir')`)\nexec(`INSERT INTO users (email, name) VALUES ('amir@example.com', 'Amir')`)\nexec(`SELECT * FROM users`)\nError: UNIQUE constraint failed: users.email\n</code></pre>\n<blockquote>\n<p>What if we store email in 2 comuns? as username and domain? How can we mae sure that both usrname and domain need to be unique??</p>\n</blockquote>\n<pre><code>exec(`\n  CREATE TABLE emails (\n    username TEXT,\n    domain TEXT,\n    UNIQUE (username, domain)\n  )\n`)\n</code></pre>\n<blockquote>\n<p>We can UPDATE our new emails table as much as we like. But if we try to update it in a way that results in two rows with the same username and the same domain, that's an error.</p>\n</blockquote>\n<blockquote>\n<p>We can delete data with the DELETE statement. Like UPDATE, it will delete every row by default. You'll want to be very careful with DELETE!</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE users (email TEXT, name TEXT)`)\nexec(`INSERT INTO users (email, name) VALUES ('amir@example.com', 'Amir')`)\nexec(`INSERT INTO users (email, name) VALUES ('betty.j@example.com', 'Betty')`)\nexec(`DELETE FROM users`)\nexec(`SELECT name FROM users`)\n[]\n</code></pre>\n<blockquote>\n<p>We can be more specific what we are deleting:</p>\n</blockquote>\n<pre><code>exec(`DELETE FROM users WHERE name = 'Betty' OR name = 'Amir'`)\n</code></pre>\n<p>Defaults\nNormally, we have to specify all of the columns when inserting a row. But that quickly becomes tedious because many real-world tables have dozens of columns. We can eliminate some of that tedium by defining default values for columns.</p>\n<p>For example, if our users have a login<em>count, then 0 is a good default value. When a user is created, they've never logged in. Defining that default value during table creation saves us from specifying a login</em>count when INSERTing a user.</p>\n<pre><code>exec(`\n  CREATE TABLE users (\n    name TEXT,\n    login_count INTEGER NOT NULL DEFAULT 0\n  );\n`)\nexec(`INSERT INTO users (name) VALUES ('Amir')`)\nexec(`SELECT * FROM users`)\n[{login_count: 0, name: 'Amir'}] \n</code></pre>\n<p>f we specify a value when inserting, it will override the default.</p>\n<pre><code>exec(`\n  CREATE TABLE users (\n    name TEXT,\n    login_count INTEGER NOT NULL DEFAULT 0\n  );\n`)\nexec(`INSERT INTO users (name, login_count) VALUES ('Amir', 1)`)\nexec(`SELECT * FROM users`)\n</code></pre>\n<p>Column aliases\nWe can rename columns when needed using AS. The result object's properties will use our column aliases instead of the original column names. In this example, we rename the age column, but we leave the name alone.</p>\n<pre><code>exec(`CREATE TABLE cats (name TEXT, age INTEGER)`)\nexec(`INSERT INTO cats (name, age) VALUES ('Keanu', 2)`)\nexec(`SELECT name, age AS oldness FROM cats`)\n[{name: 'Keanu', oldness: 2}]\n</code></pre>\n<p>Column aliases become useful in complex queries that involve multiple tables. However, they're also useful for something much simpler: querying mathematical expressions and functions. Now we can clean up the results of those queries!</p>\n<pre><code>exec(`SELECT 1 + 1`)\n[{'1 + 1': 2}] \n</code></pre>\n<pre><code>exec(`SELECT 1 + 1 AS sum`)\n[{sum: 2}]\n</code></pre>\n<pre><code>exec(`CREATE TABLE cats (name TEXT, age INTEGER)`)\nexec(`INSERT INTO cats (name, age) VALUES ('Keanu', 2)`)\nexec(`SELECT name AS cat_name, age AS cat_age from cats`)\n\n[{cat_age: 2, cat_name: 'Keanu'}]\n</code></pre>\n<blockquote>\n<p>In order to differentiate people with same naem we can use ids:</p>\n</blockquote>\n<pre><code>xec(`CREATE TABLE people (id INTEGER NOT NULL, name TEXT NOT NULL)`)\nexec(`INSERT INTO people (id, name) VALUES (1, 'Amir')`)\nexec(`INSERT INTO people (id, name) VALUES (2, 'Amir')`)\nexec(`SELECT * FROM people where ID = 1`)\n[{id: 1, name: 'Amir'}]\n</code></pre>\n<blockquote>\n<p>But doing ids manually is tedious. It's much better to let the database choose IDs for us. In SQLite, we can do that by making the ID column a PRIMARY KEY.In databases, \"key\" means \"a column or set of columns that is always unique\". We've already seen keys in the form of uniqueness constraints. If we put a uniqueness constraint on one column, that makes it a key. If the constraint requires two columns together to be unique, then those two columns together are a key. Database systems themselves don't usually care about keys; they're more useful for humans as a shorthand for \"a set of columns that's always unique\".However, databases do care very much about primary keys. The primary key is a key that we've declared to be special: it's the main (primary) key for the table. In most real-world databases, the primary key is an integer column, often named id. When we tell the database that a column is the primary key, it does several things. First, the primary key column is automatically UNIQUE, so it can never have duplicate values. Second, in most databases, the primary key is also NOT NULL. This isn't true in SQLite, but let's ignore that for a moment. If we create a PRIMARY KEY column, then we won't be allowed to insert duplicates.</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT NOT NULL)`)\nexec(`INSERT INTO people (id, name) VALUES (1, 'Amir')`)\nexec(`SELECT * FROM people`)\n[{id: 1, name: 'Amir'}]\n</code></pre>\n<blockquote>\n<p>always make your primary keys NOT NULL!</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE people (name TEXT PRIMARY KEY NOT NULL)`)\n</code></pre>\n<blockquote>\n<p>Most primary keys are auto-incrementing integer IDs. \"Auto-incrementing\" means that each new ID increases by 1 automatically. When we insert a record, we don't have to specify the ID. The first record inserted will get an ID of 1. After that, the database will always automatically choose the next unused integer. It's kind of like a default value, except it automatically changes with every new record.</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE people (id INTEGER PRIMARY KEY NOT NULL, name TEXT)`)\nexec(`INSERT INTO people (name) VALUES ('Amir')`)\nexec(`INSERT INTO people (name) VALUES ('Betty')`)\nexec(`SELECT * FROM people`)\n[{id: 1, name: 'Amir'}, {id: 2, name: 'Betty'}] \n</code></pre>\n<blockquote>\n<p>One last detail about primary keys. A table can have only one primary key. If we try to create two primary keys in the same table, the database will error.</p>\n</blockquote>\n<blockquote>\n<p>Primary keys in a nutshell:</p>\n</blockquote>\n<p>Each table can only have one primary key.\nPrimary key values must be unique.\nPrimary key values can't be NULL (but SQLite will allow NULL in some situations for backwards compatibility).\nPrimary key columns can have any type, but most are automatically-incrementing integers starting at 1. In SQLite, an INTEGER PRIMARY KEY will automatically increment.\nPrimary keys combine a lot of complicated ideas, but using them is relatively simple. Except in rare situations, your tables should always have an auto-incrementing integer primary key. You never need to include it in your inserts; the database will do it for you. Just by typing INTEGER PRIMARY KEY, you get an easy-to-use, automatically-managed ID column.</p>\n<blockquote>\n<p>Dropping tables and columns\nSometimes an entire table is no longer needed. We could DELETE all data in it, but the table would still exist. Over time, we'd end up with many unused, empty tables in our database. It's better to completely destroy the table.</p>\n</blockquote>\n<blockquote>\n<p>We remove tables by DROPing them. If we DROP a table, trying to access it in any way is an error because it no longer exists.</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE users (email TEXT, name TEXT)`)\nexec(`DROP TABLE users`)\nexec(`SELECT * FROM users`)\nError: no such table: users \n</code></pre>\n<blockquote>\n<p>Drop the cats table.</p>\n</blockquote>\n<pre><code>exec(`CREATE TABLE cats (name TEXT, age INTEGER)`)\nexec(`DROP TABLE cats`)\n\nexec(`\n  INSERT INTO cats (name, age)\n  VALUES ('Ms. Fluff', 3);\n`)\n    \nError: no such table: cats\n</code></pre>\n<blockquote>\n<p>What's the difference between deleting and dropping? Deleting is always about data: it removes rows. Dropping is always about database structure: it removes tables. In most database systems, we can also drop a single column from a table. Later in this course, we'll see examples of dropping other structures as well.</p>\n</blockquote>\n<p>SQL: Bind parameters\nSQL isn't very useful in isolation. In real systems, it will always be combined with a general-purpose language like JavaScript.</p>\n<p>Throughout this course, we've seen query results like [{name: 'Amir'}, {name: 'Betty'}]. Now we'll write JavaScript code to work with those query results.</p>\n<p>The simplest case is: we INSERT some rows, then access parts of them.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (name TEXT);</code>)\nexec(<code>INSERT INTO users (name) VALUES ('Amir');</code>)\nexec(<code>INSERT INTO users (name) VALUES ('Betty');</code>)\n[] </p>\n<p>exec(<code>SELECT * FROM users</code>)\n[{name: 'Amir'}, {name: 'Betty'}] </p>\n<p>const users = exec(<code>SELECT * FROM users</code>)\nconst amir = users[0]\namir.name\n'Amir'\nThe most common type of query is \"find me the record with this ID\". We want to say SELECT * FROM users WHERE id = ?. But what goes in place of the \"?\"?</p>\n</blockquote>\n<p>The answer is that ? is actually the correct thing to put there! A ? tells SQLite \"I (the programmer) will provide a parameter for you to insert here.\" We provide the parameter values as the second value to our exec function.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (id INTEGER NOT NULL, name TEXT);</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (1, 'Amir');</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (2, 'Betty');</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (3, 'Betty');</code>)\n[] </p>\n<p>const users = exec(<code>SELECT name FROM users WHERE id = ?</code>, [1])\nconst amir = users[0]\namir.name\n'Amir'\nWe can use more than one ? if needed. Each one is a different parameter. If we have two ? parameters in our query, we have to provide two values to fill those parameters.</p>\n</blockquote>\n<blockquote>\n<p>exec(\n\"SELECT * FROM users WHERE id = ? AND name = ?\",\n[1, 'Amir']\n)\n[{id: 1, name: 'Amir'}] </p>\n<p>exec(\n\"SELECT * FROM users WHERE id = ? AND name = ?\",\n[2, 'Amir']\n)\n[]\nHere's a code problem for you to complete:</p>\n</blockquote>\n<p>Write a findUser function that finds a user by their ID, returning the result (an array of objects) that comes back from the database. Use a bind parameter (?) to provide the ID to the query. Remember that the ID needs to be passed in an array!</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (id INTEGER NOT NULL, name TEXT);</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (1, 'Amir');</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (2, 'Betty');</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (3, 'Betty');</code>)\nfunction findUser(id) {\nreturn exec(<code>SELECT * FROM users WHERE id= ?</code>, [id])\n}</p>\n</blockquote>\n<p>[findUser(1), findUser(2), findUser(100)]\nGOAL:\n[[{id: 1, name: 'Amir'}], [{id: 2, name: 'Betty'}], []]\nYOURS:\n[[{id: 1, name: 'Amir'}], [{id: 2, name: 'Betty'}], []]\nThat findUser function works, but it's annoying to use. By directly returning what it gets from the database, it always returns the user wrapped in an array. It also returns [] when the user isn't found. A better version would return just the user object, and null when the user doesn't exist.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Write a findUser function that finds a user by their ID. Return the user object itself, not the full query result array. If no user is found, return JavaScript's null. (You can check for whether the query returned no results with if (queryResult.length === 0) { ... }.)</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (id INTEGER NOT NULL, name TEXT);</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (1, 'Amir');</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (2, 'Betty');</code>)\nexec(<code>INSERT INTO users (id, name) VALUES (3, 'Betty');</code>)\nfunction findUser(id) {\nconst queryResult = exec(<code>SELECT * FROM users WHERE id= ?</code>, [id])\nif (queryResult.length === 0) { return null }\nreturn queryResult[0]</p>\n</blockquote>\n<p>}</p>\n<p>[findUser(1), findUser(2), findUser(100)]\nGOAL:\n[{id: 1, name: 'Amir'}, {id: 2, name: 'Betty'}, null]\nYOURS:\n[{id: 1, name: 'Amir'}, {id: 2, name: 'Betty'}, null]\nWhen we do exec(<code>SELECT ... ?</code>, [1, 2]), the 1 and 2 are called \"bind parameters\". The query contains some holes marked with ?, and the parameters get bound to those holes.</p>\n<p>What if we want to reference a bind parameter multiple times in the query? Instead of ?, we can reference ?1, ?2, etc. Parameter numbers start at 1, so ?1 refers to the bind parameter at index 0. Here's an example of ?1 in action:</p>\n<p>To find all cats whose name matches their owner's name, we can compare them in a WHERE.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE cats (name TEXT, owner_name TEXT)</code>)\nexec(<code>INSERT INTO cats (name, owner_name) VALUES ('Amir', 'Ms. Fluff')</code>)\nexec(<code>INSERT INTO cats (name, owner_name) VALUES ('Wilford', 'Wilford')</code>)\nexec(<code>SELECT name FROM cats WHERE name = owner_name</code>)\n[{name: 'Wilford'}]\nIf we only care about one particular matching cat and owner (like Wilford and Wilford), then we can also find them using a bind parameter. We'll pass 'Wilford' in as the bind parameter, then reference it twice with ?1.</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>CREATE TABLE cats (name TEXT, owner_name TEXT)</code>)\nexec(<code>INSERT INTO cats (name, owner_name) VALUES ('Amir', 'Ms. Fluff')</code>)\nexec(<code>INSERT INTO cats (name, owner_name) VALUES ('Wilford', 'Wilford')</code>)\nexec(<code>SELECT name FROM cats WHERE name = ?1 AND owner_name = ?1</code>, ['Wilford'])\n[{name: 'Wilford'}]\nThe syntax for these parameters varies by database. For example, PostgreSQL's bind parameters are referenced with $1, $2, etc.</p>\n</blockquote>\n<p>The query execution function also varies between different databases. In this course, we execute queries with exec(query, bindParameters), which is a function that we (the course authors) defined while writing the course. In Node's PostgreSQL API, the equivalent function is called query. In Python's SQLite API, it's called execute.</p>\n<p>No matter the syntax, all SQL databases support bind parameters in some form. They wouldn't be very useful without it!</p>\n<p>SQL: Comments\nIn SQL, comments begin with --. This is an unusual syntax for comments, although it is shared with some other programming languages, like Ada and Haskell. Anything from the -- until the end of the line gets ignored.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE cats (</p>\n</blockquote>\n<pre><code>name TEXT\n-- owner_name TEXT\n</code></pre>\n<p>  )\n<code>) exec(</code>INSERT INTO cats (name, owner<em>name) VALUES ('Wilford', 'Wilford')`)\nError: table cats has no column named owner</em>name\nSQL databases also support C-style comments /* like this */, which can span multiple lines.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE cats (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY\n/*\nname TEXT,\nowner_name TEXT\n*/\n</code></pre>\n<p>  )\n<code>) exec(</code>INSERT INTO cats (name, owner_name) VALUES ('Wilford', 'Wilford')`)\nError: table cats has no column named name </p>\n<p>SQL: Comparing with null\nNULL in SQL databases has some sharp edges. For example, mathematical operations on NULL give another NULL (which comes back to us as JavaScript's null).</p>\n<blockquote>\n<p>exec(<code>SELECT NULL + 0 AS result</code>)\n[{result: null}] </p>\n<p>exec(<code>SELECT NULL + 1 AS result</code>)\n[{result: null}] </p>\n<p>exec(<code>SELECT NULL * 5 AS result</code>)\n[{result: null}]\nWhen we use = to compare anything with NULL, we get another NULL. That's even true when comparing NULL = NULL.</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>SELECT NULL = NULL AS result</code>)\n[{result: null}] </p>\n<p>exec(<code>SELECT NULL = 1 AS result</code>)\n[{result: null}] </p>\n<p>exec(<code>SELECT 'cat' = NULL AS result</code>)\n[{result: null}]\nFortunately, SQL also has IS NULL and IS NOT NULL comparisons that properly check for NULL values. (As usual, SQLite uses 1 and 0 to represent true and false.)</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>SELECT NULL IS NULL AS result</code>)\n[{result: 1}] </p>\n<p>exec(<code>SELECT NULL IS NOT NULL AS result</code>)\n[{result: 0}] </p>\n<p>exec(<code>SELECT 5 IS NULL AS result</code>)\n[{result: 0}] </p>\n<p>exec(<code>SELECT 5 IS NOT NULL AS result</code>)\n[{result: 1}] </p>\n<p>exec(<code>SELECT (NULL = NULL) IS NULL AS result</code>)\n[{result: 1}]\nUsually, you'll see IS NULL and IS NOT NULL as conditions in WHERE queries.</p>\n</blockquote>\n<p>For example, suppose that we have a database where only some users have emails. We want to email all of our users. To do that, we need to select all users who have an email address.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (name TEXT NOT NULL, email TEXT NULL)</code>)\nexec(<code>INSERT INTO users (name, email) VALUES ('Amir', 'amir@example.com')</code>)\nexec(<code>INSERT INTO users (name, email) VALUES ('Cindy', NULL)</code>)\nexec(<code>SELECT * FROM users WHERE email IS NOT NULL</code>)\n[{email: 'amir@example.com', name: 'Amir'}]\nHere's a code problem for you to complete:</p>\n</blockquote>\n<p>Here's a table where some users have a cat, and some don't. Select all users that have a cat.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (name TEXT NOT NULL, cat_name TEXT NULL)</code>)\nexec(<code>INSERT INTO users (name, cat_name) VALUES ('Amir', 'Ms. Fluff')</code>)\nexec(<code>INSERT INTO users (name, cat_name) VALUES ('Betty', 'Keanu')</code>)\nexec(<code>INSERT INTO users (name, cat_name) VALUES ('Cindy', NULL)</code>)\nexec(<code>INSERT INTO users (name, cat_name) VALUES ('Dalili', NULL)</code>)\nexec(<code>INSERT INTO users (name, cat_name) VALUES ('Wilford', 'Wilford')</code>)\nexec(<code>SELECT * FROM users WHERE cat_name IS NOT NULL</code>)</p>\n</blockquote>\n<p>GOAL:\n[{cat<em>name: 'Ms. Fluff', name: 'Amir'}, {cat</em>name: 'Keanu', name: 'Betty'}, {cat_name: 'Wilford', name: 'Wilford'}]\nYOURS:\n[{cat<em>name: 'Ms. Fluff', name: 'Amir'}, {cat</em>name: 'Keanu', name: 'Betty'}, {cat_name: 'Wilford', name: 'Wilford'}]\nThe specific details of null handling vary from database to database. Fortunately, SQLite's NULL behavior was designed to be similar to other SQL databases, so the specifics above apply to most databases.</p>\n<p>SQL: Selecting expressions from tables\nWhen SELECTing from a table, we can SELECT expressions computed from the table's columns.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE cats (name TEXT, age INTEGER)</code>)\nexec(<code>INSERT INTO cats (name, age) VALUES ('Ms. Fluff', 3)</code>)\nexec(<code>SELECT age, age + 1 AS age_next_year FROM cats</code>)\n[{age: 3, age<em>next</em>year: 4}]\nIn JavaScript, we can concatenate strings like \"a\" + \"b\". In SQLite, we concatenate with \"a\" || \"b\". This syntax is unfortunate because || means \"or\" in most other languages. (In SQL, \"or\" is simply OR.)</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>CREATE TABLE cats (name TEXT)</code>)\nexec(<code>INSERT INTO cats (name) VALUES ('Ms. Fluff')</code>)\nexec(<code>SELECT name || ' the cat' AS name FROM cats</code>)\n[{name: 'Ms. Fluff the cat'}]\nThis doesn't change Ms. Fluff because SELECT never changes tables. That makes it safer to hack away at SELECTs when exploring the data.</p>\n</blockquote>\n<p>SQL dialects tend to have more built-in operators than other programming languages. For example, most programming languages have >, &#x3C;, >=, and &#x3C;=. SQL has those too.</p>\n<p>But most SQL dialects also have a special BETWEEN operator. In SQL, instead of x >= y and x &#x3C;= z, we can say x BETWEEN y AND z. (Remember that SQLite represents true as 1 and false as 0.)</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE cats (name TEXT, age INTEGER)</code>)\nexec(<code>INSERT INTO cats (name, age) VALUES ('Ms. Fluff', 3)</code>)\nexec(<code>INSERT INTO cats (name, age) VALUES ('Katy Purry', 5)</code>)\nexec(<code>SELECT name, age BETWEEN 2 AND 3 AS is_2_or_3 FROM cats</code>)\n[{is<em>2</em>or<em>3: 1, name: 'Ms. Fluff'}, {is</em>2<em>or</em>3: 0, name: 'Katy Purry'}]\nThe AND in x BETWEEN y AND z is an interesting example of SQL syntax. Normally, AND in SQL is a \"logical and\", like &#x26;&#x26; in most programming languages. SELECT 1 AND 1 returns 1, SELECT 1 AND 0 returns 0, etc.</p>\n</blockquote>\n<p>SQL often reuses keywords, which is happening here. When we select x BETWEEN y AND z, the AND is part of BETWEEN. It has nothing to do with the logical AND of SELECT x AND y.</p>\n<p>We can think of this by analogy to JavaScript's syntax. In JavaScript objects like {a: 1}, : separates the property from its value. In JavaScript switch statements, we say case x:, with the : marking the case clause. Both of these use the same : character, but it means something different in each context. A similar thing is happening with AND: in SQL, it can be either a \"logical and\" or it can be part of BETWEEN.</p>\n<p>SQL is making a trade-off here that doesn't exist in any popular language created since the 90s: it's using huge numbers of language keywords instead of providing functions.</p>\n<p>In JavaScript, most functions are required or imported from third-party NPM modules. In Python or Java, which have larger standard libraries, a lot of functions come with the language. In SQL, many \"functions\" aren't functions at all; they're syntax of the language itself, like x BETWEEN y AND z. This is why JavaScript has 64 keywords, but PostgreSQL's SQL dialect has 760.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Select two values from the cats table. First: the cats' names, with \" the cat\" appended to each. Second: is<em>3</em>years_old, a boolean (represented as 0 or 1 in SQLite). Remember that equality comparison in SQL is =, not == or ===.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE cats (name TEXT, age INTEGER)</code>)\nexec(<code>INSERT INTO cats (name, age) VALUES ('Ms. Fluff', 3)</code>)\nexec(<code>INSERT INTO cats (name, age) VALUES ('Keanu', 2)</code>)\nexec(<code>SELECT name || ' the cat' as name, age = 3 AS is_3_years_old FROM cats</code>)</p>\n</blockquote>\n<p>GOAL:\n[{is<em>3</em>years<em>old: 1, name: 'Ms. Fluff the cat'}, {is</em>3<em>years</em>old: 0, name: 'Keanu the cat'}]\nYOURS:\n[{is<em>3</em>years<em>old: 1, name: 'Ms. Fluff the cat'}, {is</em>3<em>years</em>old: 0, name: 'Keanu the cat'}] </p>\n<p>SQL: Multiple statements\nSQL allows us to separate statements with ;. When we do that, only the data from the final statement will be returned.</p>\n<blockquote>\n<p>exec(<code>SELECT 1; SELECT 2 AS two</code>)\n[{two: 2}]\nHere's a code problem for you to complete:</p>\n</blockquote>\n<p>Use SQL's ; syntax to:</p>\n<p>Create a users table with a text name.\nInsert a user named \"Amir\".\nSelect the user back out.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (name TEXT); INSERT INTO users (name) VALUES ('Amir'); SELECT * FROM users</p>\n</blockquote>\n<p>`)\nGOAL:\n[{name: 'Amir'}]\nYOURS:\n[{name: 'Amir'}]\nWhen using multiple statements, later statements will always see changes made by earlier statements. That's true for INSERT, UPDATE, DELETE, and any other kind of change.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Use ; to update Amir's name to \"Amir A\", then select all of the users.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (name TEXT)</code>)\nexec(<code>INSERT INTO users (name) VALUES ('Amir')</code>)\nexec(`\nUPDATE users SET name = 'Amir A';SELECT * FROM users</p>\n</blockquote>\n<p>`)\nGOAL:\n[{name: 'Amir A'}]\nYOURS:\n[{name: 'Amir A'}]\nUsually, ; will work like you'd expect: it's like you're calling exec multiple times. However, there's one notable exception.</p>\n<p>Many database APIs don't let us use ; with bind parameters. Our database API has that constraint: if we use both of these API features at the same time, it will cause an error. Unlike most errors in this course, this one comes from Execute Program itself, not from SQLite.</p>\n<blockquote>\n<p>// Bind parameters can't be used with multiple statements.\n// (Many database libraries have this limitation.)\nexec(<code>SELECT 1; SELECT ? AS two</code>, [1])\nError: It looks like you tried to execute multiple statements with \";\" while also using bind parameters. Many database APIs, including Execute Program's, don't allow you to do both of those at the same time. Try executing each statement in a separate call to \"exec\" instead of using semicolons. (This error is specific to Execute Program; it doesn't come from SQLite.) </p>\n<p>exec(<code>SELECT ?; SELECT ? AS two</code>, [1, 2])\nError: It looks like you tried to execute multiple statements with \";\" while also using bind parameters. Many database APIs, including Execute Program's, don't allow you to do both of those at the same time. Try executing each statement in a separate call to \"exec\" instead of using semicolons. (This error is specific to Execute Program; it doesn't come from SQLite.)\nFinish Lesson</p>\n</blockquote>\n<p>SQL: Null in unique constraints\nWhat happens if there are NULLs in a column with a UNIQUE constraint? At first glance, here's what you might expect: one NULL is allowed, but multiple NULLs will violate the UNIQUE constraint. But that would make some things very difficult in practice. Here's an example:</p>\n<p>Suppose that we have a users table with an email column, which has a UNIQUE constraint. Some users will register with a third-party authentication system like Google's, Twitter's, or GitHub's. Those users will have a NULL email address column.</p>\n<p>If a UNIQUE constraint only allowed one NULL, then only one user would be allowed to register with those third-party authentication systems. After that, all further registration attempts would violate the UNIQUE constraint.</p>\n<p>For exactly this reason, UNIQUE has special behavior for NULL. NULL values are effectively ignored by a UNIQUE constraint.</p>\n<p>(In the following examples, you can answer with error if a query will result in an error. Queries like INSERT and CREATE that return no rows will have a return value of [].)</p>\n<p>Each of these example uses this table. Each example is separate, and each starts with the table empty.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (email TEXT NULL UNIQUE)</code>)\n[] </p>\n<p>exec(<code>INSERT INTO users (email) VALUES ('amir@example.com')</code>)\nexec(<code>INSERT INTO users (email) VALUES ('betty@example.com')</code>)\n[] </p>\n<p>exec(<code>INSERT INTO users (email) VALUES (NULL)</code>)\nexec(<code>SELECT * FROM users</code>)\n[{email: null}] </p>\n<p>exec(<code>INSERT INTO users (email) VALUES ('amir@example.com')</code>)\nexec(<code>INSERT INTO users (email) VALUES ('amir@example.com')</code>)\nError: UNIQUE constraint failed: users.email </p>\n<p>exec(<code>INSERT INTO users (email) VALUES (NULL)</code>)\nexec(<code>INSERT INTO users (email) VALUES (NULL)</code>)\nexec(<code>SELECT * FROM users</code>)\n[{email: null}, {email: null}]\nSometimes, language quirks are mistakes: a language designer might not anticipate problems with the language they've designed. This NULL/UNIQUE behavior is a quirk, but it's not a language design mistake. It's an intentional choice that allows us to build databases like the one above.</p>\n</blockquote>\n<p>SQL: Referencing other tables\nUntil this lesson, every table in the course has been an island: it hasn't related to other tables. In real systems, data relates to other data. To start with a simple example: people can own cats.</p>\n<p>In a general-purpose programming language like JavaScript, we might represent that as: {name: 'Amir', cats: [{name: 'Ms. Fluff'}]}. The cats are stored as part of the person. Many SQL databases will allow us to store cats \"inside\" people in this way. However, if we use that style then we give up much of SQL's value.</p>\n<p>Instead, we'll create two separate tables. Each person will have an integer ID. Each cat will have an integer owner_id holding the owner's ID. (Remember that execing an INSERT, CREATE, etc. returns [].)</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT NOT NULL); CREATE TABLE cats (owner_id INTEGER NOT NULL, name TEXT NOT NULL); INSERT INTO people (id, name) VALUES (100, 'Amir'); INSERT INTO cats (owner_id, name) VALUES (100, 'Ms. Fluff');</code>)\n[] </p>\n<p>exec(<code>SELECT id FROM people WHERE name = 'Amir';</code>)\n[{id: 100}] </p>\n<p>exec(<code>SELECT name FROM cats WHERE owner_id = 100;</code>)\n[{name: 'Ms. Fluff'}] </p>\n<p>exec(<code>SELECT name FROM cats WHERE owner_id = 101;</code>)\n[]\nWe can combine the person and cat queries in a JavaScript function.</p>\n</blockquote>\n<blockquote>\n<p>function findCatNames(personName) {\nconst allCatNames = []\nconst people = exec(<code>SELECT id FROM people WHERE name = ?</code>, [personName])\nfor (const person of people) {</p>\n</blockquote>\n<pre><code>const cats = exec(`SELECT name FROM cats WHERE owner_id = ?`, [person.id])\nfor (const cat of cats) {\n  allCatNames.push(cat.name)\n}\n</code></pre>\n<p>  }\nreturn allCatNames\n}\nfindCatNames('Amir')\n['Ms. Fluff']\nOne important note about tables that reference each other. We would never create separate tables named amir<em>cats, betty</em>cats, etc. Instead, we leave all of the cats in one table. When we need to find a certain person's cats, we let the ID columns guide us.</p>\n<p>That's part of a more general rule of SQL databases: the application itself never changes the database's structure. The application doesn't create or drop tables or change columns. We set the database schema up in advance. Then the application creates, updates, and deletes rows.</p>\n<p>Having only one cats table doesn't limit us. We can select a person's cats by owner_id, even when there are multiple people with different cats:</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT NOT NULL);\nCREATE TABLE cats (owner_id INTEGER NOT NULL, name TEXT NOT NULL);</p>\n</blockquote>\n<p>  -- Amir owns Ms. Fluff.\nINSERT INTO people (id, name) VALUES (100, 'Amir');\nINSERT INTO cats (owner_id, name) VALUES (100, 'Ms. Fluff');</p>\n<p>  -- Betty owns Keanu.\nINSERT INTO people (id, name) VALUES (101, 'Betty');\nINSERT INTO cats (owner_id, name) VALUES (101, 'Keanu');\n`)</p>\n<p>// The database holds both Amir's and Betty's cats.\n// Selecting by owner ID lets us distinguish between them.\nexec(<code>SELECT name FROM cats WHERE owner_id = ?</code>, [100])\n[{name: 'Ms. Fluff'}]\nHere's a code problem for you to complete:</p>\n<p>Write a function to find the names of all toys owned by a certain cat.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE cats (id INTEGER PRIMARY KEY, name TEXT NOT NULL); CREATE TABLE toys (cat_id INTEGER NOT NULL, name TEXT NOT NULL); INSERT INTO cats (name) VALUES ('Ms. Fluff'); INSERT INTO cats (name) VALUES ('Keanu'); INSERT INTO toys (cat_id, name) VALUES (1, 'Birdo'); INSERT INTO toys (cat_id, name) VALUES (2, 'Mouser');</code>)\nfunction findToys(catName) {\nconst allToyNames = []</p>\n</blockquote>\n<p>  const cats = exec(<code>SELECT id FROM cats WHERE name =?</code>, [catName])\nfor (let i=0; i&#x3C;cats.length; i++){\nconst toys = exec(<code>SELECT name FROM toys WHERE cat_id =?</code>, [cats[i].id])\nfor (let j=0; j&#x3C;toys.length;j++){\nallToyNames.push(toys[j].name)\n}\n}\nreturn allToyNames\n}\nfindToys('Ms. Fluff')\nGOAL:\n['Birdo']\nYOURS:\n['Birdo']\nSQL: SQL injection\nAt first glance, SQL databases' bind parameters seem unnecessary. (Bind parameters are the ? in SELECT * FROM users WHERE id = ?.) Can't we just use string concatenation instead?</p>\n<p>Imagine that we're writing an account registration form for a web app. The user enters their email address into our form. Then we insert the email address into our database.</p>\n<p>In the next example, look at how we build the INSERT statement. We're concatenating strings to build the SQL rather than using bind parameters.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (email TEXT UNIQUE)</code>)</p>\n</blockquote>\n<p>function register(email) {\nexec(<code>INSERT INTO users (email) VALUES ('</code> + email + <code>')</code>)\n}</p>\n<p>register('amir@example.com')\nexec(<code>SELECT * FROM users</code>)\n[{email: 'amir@example.com'}]\nThat code example will technically work... if all of our users are very nice people who don't know about SQL injection attacks!</p>\n<p>In any real-world system, that code is very, very bad. It's the worst code in this course! It contains a security hole that will allow an attacker to execute any SQL that they want. They can pull data out of our database, or change it, or delete it. All they have to do is enter a carefully built string into the account registration form.</p>\n<p>Let's start by examining the way that we build the query: by combining strings with +. We'll forget about the database itself for a moment and just focus on the SQL.</p>\n<p>Be careful with the next few code examples; it's easy to make a mistake with the quotes. You may find it useful to copy and paste the strings together, emulating what JavaScript will do.</p>\n<blockquote>\n<p>const email = \"amir@example.com\"\n\"INSERT INTO users (email) VALUES ('\" + email + \"')\"\n\"INSERT INTO users (email) VALUES ('amir@example.com')\" </p>\n<p>const email = \"' oh no '\"\n\"INSERT INTO users (email) VALUES ('\" + email + \"')\"\n\"INSERT INTO users (email) VALUES ('' oh no '')\" </p>\n<p>const email = \"'); DROP TABLE users; --\"\n\"INSERT INTO users (email) VALUES ('\" + email + \"')\"\n\"INSERT INTO users (email) VALUES (''); DROP TABLE users; --')\"\nWhat will happen if the user types that last email string into our registration form's email field? It won't result in a user with an email column of ''); DROP TABLE users; --. Instead, the combined string shown above will be executed as SQL... including the DROP TABLE after the semicolon. It will actually drop the entire users table in our production database!</p>\n</blockquote>\n<p>Let's see the SQL injection run for real, deleting the table. (Remember that you can type error if the code will error.)</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (email TEXT UNIQUE)</code>)\nexec(<code>INSERT INTO users (email) VALUES (''); DROP TABLE users; --')</code>)\nexec(<code>SELECT * FROM users</code>)\nError: no such table: users\nAnd here's a more complete version, using our original register function:</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (email TEXT UNIQUE)</code>)</p>\n</blockquote>\n<p>function register(email) {\nexec(<code>INSERT INTO users (email) VALUES ('</code> + email + <code>')</code>)\n}</p>\n<p>register(\"'); DROP TABLE users; --\")</p>\n<p>exec(<code>SELECT * FROM users</code>)\nError: no such table: users\nThe key to this attack is the quote (') that closes the string in our INSERT. After that point, the rest of the user's \"email address\" string is executed as SQL code.</p>\n<p>This technique is one of the most common security exploits on the Internet. It's called a \"SQL injection attack\" because the attacker injects their own SQL code into our database query. That makes this the most important lesson in this SQL course!</p>\n<p>SQL injection is still a huge real-world problem \"that will never go away\". Some people keep lists of data leaks caused by SQL injection attacks. When this lesson was written, the four most recent entries in the list included: data stolen from the government of India, patient records from a medical company, and users' financial data.</p>\n<p>One interesting question about the attack string: why is there a comment (--) at the end? Because otherwise there would be a dangling ') at the end of the combined SQL string, causing a syntax error in the SQL. The attacker adds the comment to prevent that syntax error, which would stop their attack code from running.</p>\n<p>(For the next two examples, remember that successful CREATEs and INSERTs return no rows: []. And you can answer \"error\" if the code will result in an error.)</p>\n<p>This is valid SQL:</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (email TEXT UNIQUE)</code>)\nexec(<code>INSERT INTO users (email) VALUES (''); DROP TABLE users; --')</code>)\n[]\nBut this is not, because of the mismatched single quote (') at the end:</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (email TEXT UNIQUE)</code>)\nexec(<code>INSERT INTO users (email) VALUES (''); DROP TABLE users;')</code>)\nError: unrecognized token: \"')\"\nThis form of SQL injection has been made even more famous by an XKCD comic about it. Take a look at the code in that comic: it's exactly the kind of attack that we just saw! It closes off a string, uses a semicolon to start a new statement, drops a table, and has a comment to avoid a syntax error.</p>\n</blockquote>\n<p>Here's a code problem for you to complete:</p>\n<p>Drop the students table by executing a \"Bobby Tables\" SQL injection attack, as made famous by XKCD. (If you get stuck, try using a text editor to manually combine your attack string with the other strings in the register function. Make sure that that combined SQL string looks right.)</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE students (name TEXT)</code>)</p>\n</blockquote>\n<p>function register(name) {\nexec(<code>INSERT INTO students (name) VALUES ('</code> + name + <code>')</code>)\n}</p>\n<p>register(\n\"Robert');DROP TABLE students; --\"</p>\n<p>)</p>\n<p>exec(<code>SELECT * FROM students</code>)\nGOAL:\nError: no such table: students\nYOURS:\nError: no such table: students\nWe've used DROP TABLE to show that an attacker can run SQL maliciously. However, deleting data isn't their only option. For example, they might UPDATE our database to become an administrator without us noticing.</p>\n<p>Like before, let's start by seeing how the attack SQL is constructed. (And like before, you may want to copy and paste the pieces of this string together.)</p>\n<blockquote>\n<p>const email = \"attacker@example.com'); UPDATE users SET admin = 1 WHERE email = 'attacker@example.com';--\"\n\"INSERT INTO users (email) VALUES ('\" + email + \"')\"\n\"INSERT INTO users (email) VALUES ('attacker@example.com'); UPDATE users SET admin = 1 WHERE email = 'attacker@example.com';--')\"\nHere's a code problem for you to complete:</p>\n</blockquote>\n<p>Use a SQL injection attack to make attacker@example.com an administrator. (Note: our code here also inserts an innocent user. After the attack is executed, the innocent user shouldn't be an admin, so you'll need a WHERE on your UPDATE. The final SELECT here will return both users: attacker and innocent.)</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE users (email TEXT, admin INTEGER NOT NULL DEFAULT 0)</code>)\nexec(<code>INSERT INTO users (email) VALUES ('innocent@example.com')</code>)</p>\n</blockquote>\n<p>function register(email) {\nexec(<code>INSERT INTO users (email) VALUES ('</code> + email + <code>')</code>)\n}</p>\n<p>register(\n\"attacker@example.com'); UPDATE users SET admin = 1 WHERE email = 'attacker@example.com'; UPDATE users SET admin = 0 WHERE email = 'innocent@example.com';--'\"</p>\n<p>)</p>\n<p>exec(<code>SELECT * FROM users</code>)\nGOAL:\n[{admin: 0, email: 'innocent@example.com'}, {admin: 1, email: 'attacker@example.com'}]\nYOURS:\n[{admin: 0, email: 'innocent@example.com'}, {admin: 1, email: 'attacker@example.com'}]\nGreat! Now please never do that to anyone else's web app!</p>\n<p>SQL injection attacks are subtle, but the practical takeaway from this lesson is simple. Never concatenate SQL strings, even if it seems safe. Write your SQL in a single, self-contained string. If you need to pass dynamic data to your INSERTs, SELECTs, etc., use bind parameters. Bind parameters are carefully implemented by the database authors to inject values securely.</p>\n<p>Please don't let the direness of this warning scare you away from SQL! Avoiding SQL injection is relatively easy if you never concatenate SQL strings. And in practice, most projects use object-relational mappers or other higher-level libraries that generate SQL. When using those libraries, you'll still need to understand the concepts in this course. But the library will help you to avoid SQL injection vulnerabilities.</p>\n<p>A final note: this kind of attack can happen in other languages, too; it's not specific to SQL. If your application ever executes user input as code, then there's a potential security vulnerability. This is why most teams' linter configurations disallow the eval function. Always treat user input with care!</p>\n<p>Finish Lesson\nBrag…</p>\n<p>SQL: Foreign keys\nOne big selling point of SQL databases is correctness: the database lets us set up constraints that should never be violated. Then it makes sure that we don't accidentally violate them.</p>\n<p>We can't insert into columns that don't exist.\nWe can't insert or update nulls into NOT NULL columns.\nWe can't insert or update duplicate values in UNIQUE columns.\nIn most databases, we can't insert the wrong data type into columns. (SQLite is an anomaly here; it allows us to make this mistake.)\nWe've seen tables referencing other tables, like a cat's owner<em>id referencing a person's id. What if we make a mistake with those IDs? What if we insert a cat whose owner</em>id doesn't reference any actual person? So far, we haven't seen a way to prevent that.</p>\n<p>(Remember that statements like CREATE and INSERT return [].)</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT NOT NULL);\n-- Remember that INTEGER PRIMARY KEYs start at 1.\nINSERT INTO people (name) VALUES ('Amir');</p>\n</blockquote>\n<p>  CREATE TABLE cats (owner<em>id INTEGER NOT NULL, name TEXT NOT NULL);\nINSERT INTO cats (owner</em>id, name) VALUES (2170, 'Ms. Fluff');\n`)\n[] </p>\n<blockquote>\n<p>exec(<code>SELECT id FROM people</code>)\n[{id: 1}] </p>\n<p>exec(<code>SELECT owner_id FROM cats WHERE name = 'Ms. Fluff'</code>)\n[{owner_id: 2170}] </p>\n<p>exec(<code>SELECT name FROM people WHERE id = 2170</code>)\n[]\nThis is a problem! The cat has an owner_id, but there's no person with that ID.</p>\n</blockquote>\n<p>Suppose that this database is being used by a cat groomer. Ms. Fluff is dropped off, gets her grooming, looks great... and the database says that her owner is person 2170, who doesn't exist. Who do we call to pick her up? The database is wrong; cats are supposed to have owners who actually exist!</p>\n<p>We can prevent this mistake with a foreign key: a column whose value must equal a value in another table. In our case, we want the database to ensure that every cat's owner_id equals some person's id.</p>\n<p>Note the new REFERENCES syntax in the cats table below.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT NOT NULL);\nCREATE TABLE cats (</p>\n</blockquote>\n<pre><code>owner_id INTEGER REFERENCES people(id),\nname TEXT NOT NULL\n</code></pre>\n<p>  );\n`)\n[]\nThe database won't let us violate this foreign key in any way.</p>\n<p>We can't insert a cat whose owner<em>id references a person ID that doesn't exist.\nWe can't change an existing cat's owner</em>id to one that doesn't match some person.\nIf some cats reference a person, then we can't change the person's ID. That would leave the cats referencing a person ID that doesn't exist.\nFor the same reason, we can't delete a person referenced by some cats.\n(All of the following examples use the two tables above. Each example is separate, and each starts with the tables empty. Remember that you can type error to indicate an error.)</p>\n<blockquote>\n<p>exec(<code>INSERT INTO people (id, name) VALUES (100, 'Amir'); INSERT INTO cats (owner_id, name) VALUES (100, 'Ms. Fluff');</code>)\n[] </p>\n<p>exec(<code>INSERT INTO cats (owner_id, name) VALUES (200, 'Keanu')</code>)\nError: FOREIGN KEY constraint failed </p>\n<p>exec(<code>INSERT INTO people (id, name) VALUES (100, 'Amir'); INSERT INTO cats (owner_id, name) VALUES (100, 'Ms. Fluff'); UPDATE people SET id = 101 WHERE name = 'Amir';</code>)\nError: FOREIGN KEY constraint failed </p>\n<p>exec(<code>INSERT INTO people (id, name) VALUES (100, 'Amir'); INSERT INTO cats (owner_id, name) VALUES (100, 'Ms. Fluff'); UPDATE cats SET owner_id = 101 WHERE name = 'Ms. Fluff';</code>)\nError: FOREIGN KEY constraint failed </p>\n<p>exec(<code>INSERT INTO people (id, name) VALUES (200, 'Betty'); INSERT INTO cats (owner_id, name) VALUES (200, 'Keanu'); DELETE FROM people WHERE name = 'Betty';</code>)\nError: FOREIGN KEY constraint failed </p>\n<p>exec(<code>INSERT INTO people (id, name) VALUES (200, 'Betty'); INSERT INTO cats (owner_id, name) VALUES (200, 'Keanu'); DELETE FROM cats WHERE name = 'Keanu'; DELETE FROM people WHERE name = 'Betty';</code>)\n[]\nAll of this safety comes from that one little REFERENCES in our table definition. This shows us the power of SQL's declarative constraints. We don't have to write separate code to say \"a person can't be deleted if they still have cats\", \"a cat can't be updated to have an owner ID who doesn't exist\", etc. That one REFERENCES clause prevents many kinds of mistakes.</p>\n</blockquote>\n<p>We have a nice phrase that describes preventing all of those mistakes: referential integrity. Referential as in \"concerning references from one table to another\"; and integrity as in \"the references are guaranteed to be correct\".</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Create a cats table with a TEXT name and an owner_id INTEGER foreign key that references the id column of the people table.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT NOT NULL);</code>)\nexec(`\nCREATE TABLE cats (name TEXT, owner_id INTEGER REFERENCES people(id))</p>\n</blockquote>\n<p><code>) exec(</code>INSERT INTO cats (owner<em>id, name) VALUES (200, 'Keanu')`)\nGOAL:\nError: FOREIGN KEY constraint failed\nYOURS:\nError: FOREIGN KEY constraint failed\nWe're still allowed to UPDATE and DELETE rows in any way that satisfies the foreign key constraint. For example, we can update Keanu's owner</em>id to reference Amir instead of Betty. Then Betty can be deleted because no cats reference her any more.</p>\n<blockquote>\n<p>exec(`\n-- Ms. Fluff belongs to Amir (user 100)\nINSERT INTO people (id, name) VALUES (100, 'Amir');\nINSERT INTO cats (owner_id, name) VALUES (100, 'Ms. Fluff');</p>\n</blockquote>\n<p>  -- Keanu belongs to Betty (user 200)\nINSERT INTO people (id, name) VALUES (200, 'Betty');\nINSERT INTO cats (owner_id, name) VALUES (200, 'Keanu');</p>\n<p>  -- Keanu belongs to Amir instead of Betty\nUPDATE cats SET owner_id = 100 WHERE name = 'Keanu';</p>\n<p>  -- Delete Betty, who is no longer referenced by any cats\nDELETE FROM people WHERE name = 'Betty';\nSELECT name, owner<em>id FROM cats;\n`)\n[{name: 'Ms. Fluff', owner</em>id: 100}, {name: 'Keanu', owner_id: 100}]\nThe foreign keys were respected at every step of that change:</p>\n<p>Initially, both cats' owner<em>ids reference different people.\nWe update Keanu's owner</em>id to be 100, which is Amir's ID. Now both cats are owned by Amir.\nThen we delete Betty, which is OK because no cats reference her any more.\nSetting up these constraints takes effort. It's more work than throwing all of our data into a schemaless database with no foreign keys. However, we do this work because it saves us from other work that's more annoying, more difficult, and more error-prone.</p>\n<p>Carefully creating a schema now means that we're less likely to end up with invalid data in our production database. Our foreign key means that we'll never find \"orphaned\" cats whose owner_id references an owner who doesn't exist. If PostgreSQL ever allows us to orphan a cat, that's a bug in PostgreSQL!</p>\n<p>You may also hear people talk about \"leaked\" records, by analog to memory leaks. That means the same thing as \"orphaned\": a row that's referencing another row that no longer exists, because we didn't add a foreign key constraint.</p>\n<p>Finally, a note about terminology. Why are these called foreign keys? A key is a column that uniquely identifies a row. We've seen several tables with a numeric key called id. But we could have other types of keys. For example, users tables often have an email column that's a key: no two users ever have the same email.</p>\n<p>A cat's owner<em>id references the person's id key. From the cat's perspective, owner</em>id is referencing something \"foreign\": the id column of the people table. That's why it's a \"foreign key\".</p>\n<p>Quiz: \"Two foreign keys\"\nLet's write some code. You can solve this problem using only what you've learned in this course so far. If you need a reminder, there's a cheat sheet for all of the lessons that you've finished at the bottom-right of the page.</p>\n<p>Each test below shows some code and its result. Your goal is to get each test's actual result to match the expected result.</p>\n<p>Edit the code below until all tests pass. If you get stuck, try getting each test to pass individually.</p>\n<p>Create three tables:</p>\n<p>People have an id and a name.\nCats have an id, an owner<em>id, and a name.\nToys have a cat</em>id and a name.\nBoth IDs are integer primary keys.</p>\n<blockquote>\n<p>exec(<code>-- Deleting a person with cats fails. INSERT INTO people (id, name) VALUES (100, 'Amir'); INSERT INTO cats (id, owner_id, name) VALUES (1000, 100, 'Ms. Fluff'); INSERT INTO toys (cat_id, name) VALUES (1000, 'Birdo'); DELETE FROM people WHERE name = 'Amir';</code>)\nExpected: Error: FOREIGN KEY constraint failed OK!</p>\n<p>exec(<code>-- Deleting a cat with toys fails. INSERT INTO people (id, name) VALUES (100, 'Amir'); INSERT INTO cats (id, owner_id, name) VALUES (1000, 100, 'Ms. Fluff'); INSERT INTO toys (cat_id, name) VALUES (1000, 'Birdo'); DELETE FROM cats WHERE name = 'Ms. Fluff';</code>)\nExpected: Error: FOREIGN KEY constraint failed OK!</p>\n<p>exec(<code>-- Changing a toy's cat_id fails. INSERT INTO people (id, name) VALUES (100, 'Amir'); INSERT INTO cats (id, owner_id, name) VALUES (1000, 100, 'Ms. Fluff'); INSERT INTO toys (cat_id, name) VALUES (1000, 'Birdo'); UPDATE toys SET cat_id = 1001 WHERE name = 'Birdo';</code>)\nExpected: Error: FOREIGN KEY constraint failed OK!\n3 tests, 0 failures\nexec(`\nCREATE TABLE people (name TEXT, id INTEGER UNIQUE);\nCREATE TABLE cats (name TEXT, id INTEGER UNIQUE, owner<em>id REFERENCES people(id));\nCREATE TABLE toys (name TEXT, cat</em>id INTEGER REFERENCES cats(id));</p>\n</blockquote>\n<p>`)</p>\n<p>const email = \"'); DROP TABLE users; --\"\n\"INSERT INTO users (email) VALUES ('\" + email + \"')\"\n\"INSERT INTO users (email) VALUES (''); DROP TABLE users; --')\"  </p>\n<p>SQL: On conflict do nothing\nSuppose that we want to track whether the cats have been vaccinated. Vaccination only needs to happen once, so we don't need to track a vaccination count. If a cat exists in the vaccinations table, then they've been vaccinated.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE vaccinations (cat_name TEXT UNIQUE NOT NULL)</code>)\nexec(<code>INSERT INTO vaccinations (cat_name) VALUES ('Ms. Fluff')</code>)\nexec(<code>SELECT * FROM vaccinations</code>)\n[{cat_name: 'Ms. Fluff'}]\nThe fact that Ms. Fluff is in the vaccinations table tells us that she's been vaccinated. But what if she's accidentally vaccinated a second time, and we try to insert her again? (Remember that the cat_name column has a UNIQUE constraint.)</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>CREATE TABLE vaccinations (cat_name TEXT UNIQUE NOT NULL)</code>)\nexec(<code>INSERT INTO vaccinations (cat_name) VALUES ('Ms. Fluff')</code>)\nexec(<code>INSERT INTO vaccinations (cat_name) VALUES ('Ms. Fluff')</code>)\nError: UNIQUE constraint failed: vaccinations.cat_name\nThis isn't what we want! She was already vaccinated, so vaccinating her again shouldn't change this table.</p>\n</blockquote>\n<p>We could use JavaScript's catch to catch the error, but there's a better way. SQL allows us to specify what happens when there's a conflict (that is, when a constraint is violated).</p>\n<p>The simplest thing that we can do is nothing at all: when there's a conflict, we ignore it. In SQL terms, we tell the database ON CONFLICT, the column that might conflict (cat_name), and what to do (DO NOTHING). The insert is aborted, so nothing in the database changes.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE vaccinations (cat_name TEXT UNIQUE NOT NULL)</code>)\nexec(<code>INSERT INTO vaccinations (cat_name) VALUES ('Ms. Fluff')</code>)\nexec(<code>INSERT INTO vaccinations (cat_name) VALUES ('Ms. Fluff') ON CONFLICT (cat_name) DO NOTHING</code>)\nexec(<code>SELECT * FROM vaccinations</code>)\n[{cat_name: 'Ms. Fluff'}]\nON CONFLICT ... DO NOTHING is useful whenever you want to make sure that a certain row exists, but don't need to do anything if it already exists.</p>\n</blockquote>\n<p>Imagine that we allow users to request deactivation of their accounts. To do that, they email support, and the support representative deactivates the account for them. We track the date that the account was deactivated.</p>\n<p>Sometimes, a user will request account deactivation again because they forget that they're already deactivated. When that happens, we don't create another deactivation record, and we don't change the deactivation date. The support representative still tells our system to deactivate the account, but the system uses ON CONFLICT (...) DO NOTHING to ignore the request.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Amir requested account deactivation on 2025-10-03. We deactivated his account as requested. Then they requested deactivation again on 2025-10-22. We want that request to be ignored, and it shouldn't change the deactivation date. Finish the final INSERT here to use ON CONFLICT to ignore the deactivation request if the account is already deactivated.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  )\n<code>) exec(</code>\nCREATE TABLE deactivations (\nuser<em>id UNIQUE REFERENCES users(id),\ndate TEXT NOT NULL\n)\n<code>) exec(</code>INSERT INTO users (name) VALUES ('Amir')<code>) exec(</code>INSERT INTO deactivations (user</em>id, date) VALUES (1, '2025-10-03')<code>) exec(</code>\nINSERT INTO deactivations (user<em>id, date) VALUES (1, '2025-10-22')\nON CONFLICT (user</em>id) DO NOTHING</p>\n<p><code>) exec(</code>SELECT * FROM deactivations`)\nGOAL:\n[{date: '2025-10-03', user_id: 1}]\nYOURS:\n[{date: '2025-10-03', user_id: 1}] </p>\n<p>SQL: Constraint analysis\nWhat if a foreign key column is null? By default, that's allowed. A cat with a null owner_id means \"this cat has no owner\".</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT NOT NULL);\nCREATE TABLE cats (</p>\n</blockquote>\n<pre><code>owner_id INTEGER REFERENCES people(id),\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nINSERT INTO cats (owner<em>id, name) VALUES (null, 'Ms. Fluff');\nSELECT * FROM cats;\n`)\n[{name: 'Ms. Fluff', owner</em>id: null}]\nThe database lets us do this because we might want it! For example, imagine that we're building a site where users can register with discount codes. Some users register with a discount code, but others don't. We want to track which users registered with which discount codes.</p>\n<p>This sounds simple, but there are a few subtle decisions to be made. Let's do some analysis to come up with appropriate database constraints.</p>\n<p>Our database will have two tables, discounts (id, discount<em>code) and users (id, discount</em>id, name). We'll analyze the three most common types of constraints: foreign keys, nullability, and uniqueness.</p>\n<p>First: should users' discount<em>id be a foreign key to discounts? Yes! Otherwise users could reference discounts that don't exist, which doesn't make sense.\nSecond: should every user have a discount</em>id, or is it OK for some of them to be null? Some users will register without using a discount code. For those users, discount<em>id should be null. So discount</em>id should be nullable.\nThird: can two users reference the same discount? This is a more subtle decision.\nIn some systems, discount codes can be used many times; in others, they can only be used once. We'll decide that discount codes can only be used once. We can guarantee that by making users' discount<em>id unique. If no two users can have the same discount</em>id, then no discount code can be used twice.</p>\n<p>That gives us three constraint decisions:</p>\n<p>Users' discount<em>id is a foreign key to discounts.\nUsers' discount</em>id is nullable.\nUsers' discount_id is unique.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL,\ndiscount_id INTEGER REFERENCES discounts(id) NULL UNIQUE\n</code></pre>\n<p>  );\nCREATE TABLE discounts (id INTEGER PRIMARY KEY, discount_code TEXT NOT NULL);\n`)\n[]\nNow let's make sure that these tables work as intended. We'll run four different checks.</p>\n<p>(Each of these examples uses the tables above, but the tables always begin empty. If you think that a statement will cause an error, you can type error as its output. Remember that executing a successful INSERT returns [].)</p>\n<p>First, users can't reference discounts that don't exist.</p>\n<blockquote>\n<p>exec(<code>INSERT INTO users (name, discount_id) VALUES ('Amir', 1234)</code>)\nError: FOREIGN KEY constraint failed\nSecond, users can register with no discount at all (discount_id can be null).</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>INSERT INTO users (name, discount_id) VALUES ('Amir', null)</code>)\n[]\nThird, users can reference discounts that do exist.</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>INSERT INTO discounts (id, discount_code) VALUES (1, 'one-time-use-a1b2c3'); INSERT INTO users (name, discount_id) VALUES ('Amir', 1);</code>)\n[]\nFourth, two users can't reference the same discount. (Amir uses the discount, then shares it with Betty, who tries to use it.)</p>\n</blockquote>\n<blockquote>\n<p>exec(`\nINSERT INTO discounts (id, discount<em>code) VALUES (1, 'one-time-use-a1b2c3');\nINSERT INTO users (name, discount</em>id)</p>\n</blockquote>\n<pre><code>VALUES\n  ('Amir', 1),\n  ('Betty', 1);\n</code></pre>\n<p>`)\nError: UNIQUE constraint failed: users.discount<em>id\nAs you gain experience with SQL, you'll learn patterns about when certain constraints are appropriate. For example, users' email addresses are usually TEXT NOT NULL UNIQUE. An is</em>admin flag will usually be BOOLEAN NOT NULL DEFAULT FALSE. And so on.</p>\n<p>Foreign keys are more tricky. For foreign keys, it's a good idea to always slow down and explicitly ask the questions that we asked above:</p>\n<p>\"Is it OK for a row to have no value for this foreign key?\"\n\"Is it OK for two rows to have the same value for this foreign key?\"\nHere's another example where we ask the same questions, but get very different answers. Users can post comments. Each comment has a user_id referencing the user who posted it. Now, the analysis questions:</p>\n<p>First: should user<em>id be a foreign key to users? Yes! We don't want the database to think that a comment was posted by someone who doesn't exist.\nSecond: should every comment have a user</em>id, or is it OK for some of them to have a null user<em>id? Every comment is posted by someone (unless the computer is haunted by ghosts). So comments' user</em>id should be NOT NULL.\nThird: can two comments reference the same user? Like before, this one is more subtle.\nIf only one comment can reference a given user, then trying to insert a second comment by the same user will error. A system with that constraint would only allow each user to post exactly one comment, ever. We want users to post multiple comments, so the comments' user_id foreign key should not be unique.</p>\n<p>Again, we have three constraint decisions. But when compared to the user/discount example, we've made opposite decisions about nullability and uniqueness:</p>\n<p>Comments' user<em>id is a foreign key to users (the same as user/discount).\nComments' user</em>id is not nullable (the opposite of user/discount).\nComments' user_id is not unique (the opposite of user/discount).</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE comments (\nuser<em>id REFERENCES users(id) NOT NULL,\ncomment</em>text TEXT NOT NULL\n);\n`)\n[]\nNow let's check each of those constraints, like we did for the user/discount example. (Each of these examples uses the tables above, but the tables always begin empty.)</p>\n<p>First, comments can't reference users that don't exist.</p>\n<blockquote>\n<p>exec(`\nINSERT INTO comments (user<em>id, comment</em>text)</p>\n</blockquote>\n<pre><code>VALUES (1, 'Ms. Fluff needs a bath!');\n</code></pre>\n<p>`)\nError: FOREIGN KEY constraint failed\nSecond, comments must reference a user (user_id can't be null).</p>\n<blockquote>\n<p>exec(`\nINSERT INTO comments (user<em>id, comment</em>text)</p>\n</blockquote>\n<pre><code>VALUES (null, 'Ms. Fluff needs a bath!');\n</code></pre>\n<p>`)\nError: NOT NULL constraint failed: comments.user_id\nThird, comments can reference users that exist.</p>\n<blockquote>\n<p>exec(`\nINSERT INTO users (id, name) VALUES (1, 'Amir');\nINSERT INTO comments (user<em>id, comment</em>text)</p>\n</blockquote>\n<pre><code>VALUES (1, 'Ms. Fluff needs a bath!');\n</code></pre>\n<p>`)\n[]\nFourth, two comments can reference the same user.</p>\n<blockquote>\n<p>exec(`\nINSERT INTO users (id, name) VALUES (1, 'Amir');\nINSERT INTO comments (user<em>id, comment</em>text)</p>\n</blockquote>\n<pre><code>VALUES\n  (1, 'Ms. Fluff needs a bath!'),\n  (1, 'Ms. Fluff strongly dislikes water.');\n</code></pre>\n<p>`)\n[]\nOur user/discount example is what's often called a \"one-to-one\" relationship. Each user relates to zero or one discounts, and each discount relates to zero or one users. A user never has multiple discounts, and a discount is never used by multiple users.</p>\n<p>The user/comment example is a \"one-to-many\" relationship. One user can have many comments, but a comment is only related to one user.</p>\n<p>Shorthand terms like one-to-one and one-to-many are useful for talking to other developers, but the database doesn't know what they mean. The database only knows about constraints. Even if you use shorthand with other humans, you have to make decisions about the individual constraints in your tables:</p>\n<p>Should this column be a foreign key?\nCan this column be null?\nCan multiple rows have the same value for this column?</p>\n<p>Quiz: \"Discounts and users and comments\"\nLet's write some code. You can solve this problem using only what you've learned in this course so far. If you need a reminder, there's a cheat sheet for all of the lessons that you've finished at the bottom-right of the page.</p>\n<p>Each test below shows some code and its result. Your goal is to get each test's actual result to match the expected result.</p>\n<p>Edit the code below until all tests pass. If you get stuck, try getting each test to pass individually.</p>\n<p>Create users, discounts, and comments tables. A user can have one discount (but may have no discount at all). Many comments can belong to the same user.</p>\n<p>We've given you the basic table structure. However, the constraints are missing (foreign keys, nullability, and uniqueness). Insert the appropriate constraints, using the tests as a guide.</p>\n<blockquote>\n<p>// Users can't reference discounts that don't exist.\nexec(<code>INSERT INTO users (name, discount_id) VALUES ('Amir', 1234)</code>)\nExpected: Error: FOREIGN KEY constraint failed OK!</p>\n<p>// Users can have no discount.\nexec(<code>INSERT INTO users (name, discount_id) VALUES ('Amir', null)</code>)\nExpected: [] OK!</p>\n<p>// Two users can't reference the same discount.\nexec(<code>INSERT INTO discounts (id, discount_code) VALUES (1, 'one-time-use-a1b2c3')</code>)\nexec(<code>INSERT INTO users (name, discount_id) VALUES ('Amir', 1)</code>)\nexec(<code>INSERT INTO users (name, discount_id) VALUES ('Betty', 1)</code>)\nExpected: Error: UNIQUE constraint failed: users.discount_id OK!</p>\n<p>// Comments can't reference users that don't exist.\nexec(<code>INSERT INTO comments (user_id, comment_text) VALUES (1, 'Ms. Fluff needs a bath!')</code>)\nExpected: Error: FOREIGN KEY constraint failed OK!</p>\n<p>// Comments can't have a null user reference.\nexec(<code>INSERT INTO comments (user_id, comment_text) VALUES (null, 'Ms. Fluff needs a bath!')</code>)\nExpected: Error: NOT NULL constraint failed: comments.user_id OK!</p>\n<p>// Comments can reference a user.\nexec(<code>INSERT INTO users (id, name) VALUES (1, 'Amir')</code>)\nexec(<code>INSERT INTO comments (user_id, comment_text) VALUES (1, 'Ms. Fluff needs a bath!')</code>)\nExpected: [] OK!</p>\n<p>// Comments can reference users which themselves reference discounts.\nexec(<code>INSERT INTO discounts (id, discount_code) VALUES (1, 'one-time-use-a1b2c3')</code>)\nexec(<code>INSERT INTO users (id, name, discount_id) VALUES (1, 'Amir', 1)</code>)\nexec(<code>INSERT INTO comments (user_id, comment_text) VALUES (1, 'Ms. Fluff strongly dislikes water.')</code>)\nExpected: [] OK!\n7 tests, 0 failures\nexec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\ndiscount_id INTEGER UNIQUE REFERENCES discounts(id),\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE discounts (\nid INTEGER PRIMARY KEY,\ndiscount<em>code TEXT NULL\n);\nCREATE TABLE comments (\nuser</em>id INTEGER NOT NULL REFERENCES users(id),\ncomment_text TEXT NOT NULL\n);\n`)</p>\n<p>SQL: Review\nIt's time to review! These examples are all taken from lessons that you've finished. Revisiting them makes sure that you haven't forgotten anything.</p>\n<p>Type in what each expression will evaluate to. For example, for the prompt 1 + 1, you would type 2.</p>\n<p>In this course, the exec function runs SQL code. It returns database rows as arrays of objects like [{name: 'Amir'}]. When you execute SQL statements that don't return data, like INSERT and UPDATE, exec returns []. You can type error if the code will result in an error.</p>\n<blockquote>\n<p>exec(<code>CREATE TABLE vaccinations (cat_name TEXT UNIQUE NOT NULL)</code>)\nexec(<code>INSERT INTO vaccinations (cat_name) VALUES ('Ms. Fluff')</code>)\nexec(<code>INSERT INTO vaccinations (cat_name) VALUES ('Ms. Fluff') ON CONFLICT (cat_name) DO NOTHING</code>)\nexec(<code>SELECT * FROM vaccinations</code>)\n[{cat_name: 'Ms. Fluff'}] </p>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE comments (\nuser<em>id REFERENCES users(id) NOT NULL,\ncomment</em>text TEXT NOT NULL\n);\n<code>) exec(</code>\nINSERT INTO comments (user<em>id, comment</em>text)\nVALUES (null, 'Ms. Fluff needs a bath!');\n`)\nerror </p>\n<blockquote>\n<p>const email = \"'); DROP TABLE users; --\"\n\"INSERT INTO users (email) VALUES ('\" + email + \"')\"\n\"INSERT INTO users (email) VALUES (''); DROP TABLE users; --')\" </p>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE comments (\nuser<em>id REFERENCES users(id) NOT NULL,\ncomment</em>text TEXT NOT NULL\n);\n<code>) exec(</code>\nINSERT INTO users (id, name) VALUES (1, 'Amir');\nINSERT INTO comments (user<em>id, comment</em>text)\nVALUES\n(1, 'Ms. Fluff needs a bath!'),\n(1, 'Ms. Fluff strongly dislikes water.');\n`)\n[] </p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL,\ndiscount_id INTEGER REFERENCES discounts(id) NULL UNIQUE\n</code></pre>\n<p>  );\nCREATE TABLE discounts (id INTEGER PRIMARY KEY, discount<em>code TEXT NOT NULL);\n<code>) exec(</code>\nINSERT INTO users (name, discount</em>id) VALUES ('Amir', null)\n`)\n[]\nHere's a code problem for you to complete:</p>\n<p>Amir requested account deactivation on 2025-10-03. We deactivated his account as requested. Then they requested deactivation again on 2025-10-22. We want that request to be ignored, and it shouldn't change the deactivation date. Finish the final INSERT here to use ON CONFLICT to ignore the deactivation request if the account is already deactivated.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  )\n<code>) exec(</code>\nCREATE TABLE deactivations (\nuser<em>id UNIQUE REFERENCES users(id),\ndate TEXT NOT NULL\n)\n<code>) exec(</code>INSERT INTO users (name) VALUES ('Amir')<code>) exec(</code>INSERT INTO deactivations (user</em>id, date) VALUES (1, '2025-10-03')<code>) exec(</code>\nINSERT INTO deactivations (user<em>id, date) VALUES (1, '2025-10-22')\nON CONFLICT (user</em>id) DO NOTHING</p>\n<p><code>) exec(</code>SELECT * FROM deactivations`)\nGOAL:\n[{date: '2025-10-03', user_id: 1}]\nYOURS:\n[{date: '2025-10-03', user_id: 1}] </p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL,\ndiscount_id INTEGER REFERENCES discounts(id) NULL UNIQUE\n</code></pre>\n<p>  );\nCREATE TABLE discounts (id INTEGER PRIMARY KEY, discount<em>code TEXT NOT NULL);\n<code>) exec(</code>\nINSERT INTO discounts (id, discount</em>code) VALUES (1, 'one-time-use-a1b2c3');\nINSERT INTO users (name, discount_id)\nVALUES\n('Amir', 1),\n('Betty', 1);\n`)\nerror </p>\n<p>SQL: Simple joins\nForeign keys let us guarantee that rows in one table correctly reference rows in another table. With that guarantee in place, we can ask the database system to combine the tables' data for us.</p>\n<p>In this lesson, our goal is to produce a list of every cat's name, along with their owner's name. We could write that code in JavaScript, using a nested loop that executes one cat query per person. But that would be inefficient. SQL can do it in one query!</p>\n<p>Here's our cats-and-owners database. (We'll use this database throughout this lesson, but it will always begin empty in each code example.)</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nfirst_name TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nid INTEGER PRIMARY KEY NOT NULL,\nowner_id INTEGER NOT NULL REFERENCES people(id),\nname TEXT NOT NULL\n);</p>\n<p>  -- Amir has a cat named Ms. Fluff.\nINSERT INTO people (id, first<em>name) VALUES (100, 'Amir');\nINSERT INTO cats (owner</em>id, name) VALUES (100, 'Ms. Fluff');</p>\n<p>  -- Betty has a cat named Keanu.\nINSERT INTO people (id, first<em>name) VALUES (200, 'Betty');\nINSERT INTO cats (owner</em>id, name) VALUES (200, 'Keanu');\n`)\n[]\nWe can build our cats-and-owners list by JOINing the two tables together into one. First, we'll do the simplest possible join: people JOIN cats, giving us combinations of every person with every cat. (It will look strange, so we don't recommend dwelling on it; we'll improve it soon.)</p>\n<blockquote>\n<p>exec(<code>SELECT * FROM people JOIN cats</code>)\n[{first<em>name: 'Amir', id: 1, name: 'Ms. Fluff', owner</em>id: 100}, {first<em>name: 'Amir', id: 2, name: 'Keanu', owner</em>id: 200}, {first<em>name: 'Betty', id: 1, name: 'Ms. Fluff', owner</em>id: 100}, {first<em>name: 'Betty', id: 2, name: 'Keanu', owner</em>id: 200}]\nThe join gave us every combination of a person and a cat, whether or not they're related via owner_id. There are 2 people and 2 cats, so the join gave us 4 rows (2 * 2):</p>\n</blockquote>\n<p>Amir and Ms. Fluff\nAmir and Keanu\nBetty and Ms. Fluff\nBetty and Keanu\nIf we had 100 people and 100 cats then this join would give us 10,000 rows: each of the 100 people would be independently combined with each of the 100 cats. You can think of it like this:</p>\n<p>For each person in the people table:\nFor each cat in the cats table:\nReturn a row with the columns from that person and this cat.\nThe join has all of the columns from people (id and first<em>name) and all of the columns from cats (id, name, and owner</em>id). Both tables have an id column, which is awkward because we can't have two columns with the same name. The cats' ids are \"winning\" here, so we see them rather than the peoples' ids. We'll address the issue of conflicting column names in more detail later.</p>\n<p>To make our join more useful, we can add an ON clause. ON is like WHERE, but it applies specifically to joins. We \"select where\", but we \"join on\". For our cats-and-owners list, we want all pairs of people and cats where people.id equals cats.owner_id:</p>\n<blockquote>\n<p>exec(<code>SELECT * FROM people JOIN cats ON people.id = cats.owner_id</code>)\n[{first<em>name: 'Amir', id: 1, name: 'Ms. Fluff', owner</em>id: 100}, {first<em>name: 'Betty', id: 2, name: 'Keanu', owner</em>id: 200}]\nThis is much better! Our condition was people.id = cats.owner<em>id, so people and cats get matched up. For example, the cat with owner</em>id 100 gets joined with person 100: Amir gets matched with Ms. Fluff. Because our cats table has a FOREIGN KEY that associates cats.owner_id to people.id, we know our cats will always be matched with their correct owner!</p>\n</blockquote>\n<p>There's a simple rule for thinking about what a join will do. It's always correct to think about basic JOINs as two nested loops with a filter, like this:</p>\n<p>For each person in the people table:\nFor each cat in the cats table:\nIf the ON condition is true for this person and this cat:\nReturn a row with the columns from this person and this cat.\nHere's a code problem for you to complete:</p>\n<p>Write a JOIN that joins people and cats on cats.owner_id = people.id. Make sure that you join people to cats, in that order.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nfirst_name TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nid INTEGER PRIMARY KEY NOT NULL,\nowner_id INTEGER NOT NULL REFERENCES people(id),\nname TEXT NOT NULL\n);</p>\n<p>  -- Amir owns Ms. Fluff\nINSERT INTO people (id, first<em>name) VALUES (100, 'Amir');\nINSERT INTO cats (owner</em>id, name) VALUES (100, 'Ms. Fluff');</p>\n<p>  -- Betty owns Keanu\nINSERT INTO people (id, first<em>name) VALUES (200, 'Betty');\nINSERT INTO cats (owner</em>id, name) VALUES (200, 'Keanu');\n<code>) exec(</code>\nSELECT * FROM people JOIN cats ON cats.owner_id = people.id</p>\n<p>`)\nGOAL:\n[{first<em>name: 'Amir', id: 1, name: 'Ms. Fluff', owner</em>id: 100}, {first<em>name: 'Betty', id: 2, name: 'Keanu', owner</em>id: 200}]\nYOURS:\n[{first<em>name: 'Amir', id: 1, name: 'Ms. Fluff', owner</em>id: 100}, {first<em>name: 'Betty', id: 2, name: 'Keanu', owner</em>id: 200}]\nWith our cats and owners matched, we can pick the columns that we want with AS, like we've done for more basic SELECTs. (For example, SELECT name AS person, age AS oldness FROM some<em>table.) In a JOIN, data is identified by the table it comes from, like people.first</em>name AS person.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Write a JOIN that joins people and cats on cats.owner_id = people.id. Using AS, return data in the form of [{person: 'Amir', cat: 'Ms. Fluff'}]</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nfirst_name TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nid INTEGER PRIMARY KEY NOT NULL,\nowner_id INTEGER NOT NULL REFERENCES people(id),\nname TEXT NOT NULL\n);</p>\n<p>  INSERT INTO people (id, first<em>name) VALUES (100, 'Amir');\nINSERT INTO cats (id, owner</em>id, name) VALUES (1, 100, 'Ms. Fluff');\nINSERT INTO people (id, first<em>name) VALUES (200, 'Betty');\nINSERT INTO cats (id, owner</em>id, name) VALUES (2, 200, 'Keanu');\n<code>) exec(</code>\nSELECT people.first<em>name AS person, cats.name AS cat FROM people JOIN cats ON cats.owner</em>id = people.id</p>\n<p>`)\nGOAL:\n[{cat: 'Ms. Fluff', person: 'Amir'}, {cat: 'Keanu', person: 'Betty'}]\nYOURS:\n[{cat: 'Ms. Fluff', person: 'Amir'}, {cat: 'Keanu', person: 'Betty'}]\nUsually, the order of tables in a join doesn't matter: cats JOIN people is the same as people JOIN cats. There are two cases where join order may matter, though, depending on your database system.</p>\n<p>The first case is query optimization. In rare cases, your database engine may optimize a complex join badly, causing it to be slower than it could be. Reordering the join may help.</p>\n<p>The second case is when there are duplicate column names. When the joined tables have duplicate column names, the last table in the JOIN wins. Here's an example from earlier in the lesson: we select from people JOIN cats with no AS to alias the column names.</p>\n<blockquote>\n<p>exec(<code>SELECT * FROM people JOIN cats ON people.id = cats.owner_id</code>)\n[{first<em>name: 'Amir', id: 1, name: 'Ms. Fluff', owner</em>id: 100}, {first<em>name: 'Betty', id: 2, name: 'Keanu', owner</em>id: 200}]\nNotice that the id columns returned are the cats' IDs: 1 and 2. If we reverse the order and select cats JOIN people, the id column will be the people's IDs, 100 and 200.</p>\n</blockquote>\n<blockquote>\n<p>exec(<code>SELECT * FROM cats JOIN people ON people.id = cats.owner_id</code>)\n[{first<em>name: 'Amir', id: 100, name: 'Ms. Fluff', owner</em>id: 100}, {first<em>name: 'Betty', id: 200, name: 'Keanu', owner</em>id: 200}]\nIt's common for tables to have the same column names, especially for id columns. This can get very confusing, so it's best to use AS to explicitly alias every joined column, rather than blindly selecting *. That will make your SQL code more clear to other programmers. We recommend writing those aliases on their own lines, indented inside the SELECT.</p>\n</blockquote>\n<blockquote>\n<p>exec(`\nSELECT</p>\n</blockquote>\n<pre><code>cats.id AS cat_id,\npeople.id AS person_id\n</code></pre>\n<p>  FROM people JOIN cats ON people.id = cats.owner<em>id\n`)\n[{cat</em>id: 1, person<em>id: 100}, {cat</em>id: 2, person_id: 200}]\nWe've been treating JOIN as if it returns a table. The proper term is \"relation\", which means: \"it has rows and columns and supports operations like WHERE, AS, JOIN, etc.\"</p>\n<p>(If a join combines two relations into a new relation, does that mean that we can join on the result of a join? Yes! We'll see that in a later lesson.)</p>\n<p>Relations are the core concept in SQL databases. We've called them \"SQL databases\" so far, but \"relational databases\" is a more correct term. SQL is just the most popular relational query language.</p>\n<p>There are many kind of relations. A table is a relation stored on the disk. A join gives us a relation that the database constructs on the fly based on our join condition.</p>\n<p>Even SELECT 1 gives us a relation: it has one row with one column named 1. That's why execing that statement gives us an array of objects, as if we were selecting from a table: [{'1': 1}]. We could join a table against SELECT 1 if we wanted to!</p>\n<p>When querying relations, we can use all of the query operations that we've already seen on tables: AS, WHERE, etc. In the example above, we already did that with AS.</p>\n<p>When we use WHERE with joins, it filters the rows, just like it does with a normal table. The WHERE can see columns from both of the joined tables.</p>\n<blockquote>\n<p>exec(`\nSELECT people.first_name AS person, cats.name AS cat\nFROM people\nJOIN cats</p>\n</blockquote>\n<pre><code>ON people.id = cats.owner_id\n</code></pre>\n<p>  WHERE people.first_name = 'Amir'\n`)\n[{cat: 'Ms. Fluff', person: 'Amir'}] </p>\n<blockquote>\n<p>exec(`\nSELECT people.first_name AS person, cats.name AS cat\nFROM people\nJOIN cats</p>\n</blockquote>\n<pre><code>ON people.id = cats.owner_id\n</code></pre>\n<p>  WHERE people.first<em>name = 'Betty'\n`)\n[{cat: 'Keanu', person: 'Betty'}]\nWhat if we join people and cats, but some people have no cats? They won't show up in the results because ON people.id = cats.owner</em>id is never true for a person with no cats.</p>\n<p>For example: Betty's id is 200. If no cat's owner_id is 200, then no cat can be paired with Betty in our JOIN. Betty won't show up at all in the results. Amir and Ms. Fluff will still show up because they're still related.</p>\n<blockquote>\n<p>exec(`\n-- Delete Keanu, so Betty now has no cats.\nDELETE FROM cats WHERE owner_id = 200;</p>\n</blockquote>\n<p>  SELECT people.first<em>name AS person, cats.name AS cat\nFROM people\nJOIN cats\nON people.id = cats.owner</em>id\n`)\n[{cat: 'Ms. Fluff', person: 'Amir'}]\nWhen a person has multiple cats, the JOIN will find them all.</p>\n<p>One important note, though. Suppose that Betty owns two cats, Keanu and Kim. The query will NOT combine the cats' names into an array like [{person: 'Betty', cat: ['Keanu', 'Kim']}]. Instead, the join returns two separate rows:</p>\n<p>{person: 'Betty', cat: 'Keanu'}\n{person: 'Betty', cat: 'Kim'}</p>\n<blockquote>\n<p>exec(`\n-- Betty also has a cat named Kim\nINSERT INTO cats (owner_id, name) VALUES (200, 'Kim');</p>\n</blockquote>\n<p>  SELECT\npeople.first<em>name AS person,\ncats.name AS cat\nFROM people\nJOIN cats\nON people.id = cats.owner</em>id\nWHERE people.first_name = 'Betty'\n`)\n[{cat: 'Keanu', person: 'Betty'}, {cat: 'Kim', person: 'Betty'}]\nHere's a code problem for you to complete:</p>\n<p>Use a join to find cats and their toys. The join should return two columns aliased with AS: cat (the cat's name) and toy (the toy's name).</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE cats (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE toys (\ncat_id INTEGER REFERENCES cats(id) NOT NULL,\nname TEXT NOT NULL\n);</p>\n<p>  INSERT INTO cats (id, name) VALUES (1, 'Ms. Fluff');\nINSERT INTO cats (id, name) VALUES (2, 'Keanu');\nINSERT INTO toys (cat<em>id, name) VALUES (1, 'Birdo');\nINSERT INTO toys (cat</em>id, name) VALUES (2, 'Mouser');\nINSERT INTO toys (cat<em>id, name) VALUES (2, 'Shy Guy');\n<code>) exec(</code>\nSELECT cats.name AS cat, toys.name AS toy FROM cats JOIN toys ON cats.id = toys.cat</em>id</p>\n<p>`)\nGOAL:\n[{cat: 'Ms. Fluff', toy: 'Birdo'}, {cat: 'Keanu', toy: 'Mouser'}, {cat: 'Keanu', toy: 'Shy Guy'}]\nYOURS:\n[{cat: 'Ms. Fluff', toy: 'Birdo'}, {cat: 'Keanu', toy: 'Mouser'}, {cat: 'Keanu', toy: 'Shy Guy'}]\nYou'll sometimes see the \"simple\" joins from this lesson called \"inner joins\", which is the full technical term for them. We can even write cats INNER JOIN toys if we like. However, that does exactly the same thing, so it's not necessary.</p>\n<p>The existence of \"inner\" joins implies that there are also \"outer\" joins, and it's true! They're much less common, so we won't look at them in detail. We will see one type of outer join in a later lesson, though.</p>\n<p>SQL: On conflict update\nImagine that we want to track how many times someone has visited our website. If a person has never visited, no row exists for them. When a person visits, a row is created or updated to reflect how many times they've visited.</p>\n<p>The SQL features that we've learned so far aren't sufficient to directly express this kind of \"create-or-update\" logic. We'll have to do it in JavaScript instead. First, we query the table to see whether any visits row exists for this person's email address. If a row exists then we update it. Otherwise, we create a new row.</p>\n<p>In this example, our first call to the visit() will create the visits row. Then the second call will notice that existing row and update it.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE visits (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\n-- email is unique because we only want one row per person\nemail TEXT UNIQUE NOT NULL,\ncount INTEGER NOT NULL\n</code></pre>\n<p>  )\n`)</p>\n<p>function visit(email) {\nconst visits = exec(\n\"SELECT * FROM visits WHERE email = ?\",\n[email]\n)</p>\n<p>  if (visits.length === 0) {\nexec(\n\"INSERT INTO visits (email, count) VALUES (?, ?)\",\n[email, 1]\n)\n} else {\nconst visit = visits[0]\nexec(\n\"UPDATE visits SET count = ? WHERE id = ?\",\n[visit.count + 1, visit.id]\n)\n}\n}</p>\n<p>visit('amir@example.com')\nvisit('amir@example.com')\nexec(<code>SELECT email, count FROM visits</code>)\n[{count: 2, email: 'amir@example.com'}]\nThat worked, but there's a subtle problem that will bite us in practice. We need to make two observations to see it:</p>\n<p>First: imagine that a user hits the refresh button while a page is loading. That causes two requests to our servers with very little time between them. If our luck is bad, the two requests will end up running at the same time on two different physical servers.</p>\n<p>Second: our SELECT and INSERT queries are executed separately, so there's always a small delay between them. It's possible for server 2 to execute its SELECT after server 1's SELECT, but before server 1's INSERT.</p>\n<p>Here's a step-by-step view of the problem:</p>\n<p>Server 1 does its SELECT and sees nothing.\nServer 2 does its SELECT and sees nothing.\nServer 1 does its INSERT.\nServer 2 does its INSERT. But there's already a record for this email address, so this insert violates the UNIQUE constraint on email. An exception is thrown!\nThese bugs are called \"race conditions\": the two servers are \"racing\" to complete their write, and the slower server \"loses\" the race. This may seem like a nitpick: how likely is it that this will actually happen?</p>\n<p>It's relatively unlikely for any given request. However, unlikely problems become likely at scale. If our site gets 1,000,000 requests per month, then one-in-a-million situations will happen once per month. This happens in practice: recently, two Execute Program users saw error pages caused by a UNIQUE constraint violation, which in turn was caused by exactly this kind of race condition!</p>\n<p>Fortunately, SQL gives us a way to shorten this code while simultaneously fixing the bug. There's already a UNIQUE constraint on visits' email column, because we only want to maintain one row per visitor. If we try to insert two rows for the same person, it will be an error. This is the same constraint violation error that showed up in our race condition bug.</p>\n<p>(When you think that code in this course will cause an error, you can type error as its output.)</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE visits (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\n-- email is unique because we only want one row per person\nemail TEXT UNIQUE NOT NULL,\ncount INTEGER NOT NULL\n</code></pre>\n<p>  )\n<code>) exec(</code>INSERT INTO visits (email, count) VALUES ('amir@example.com', 1)<code>) exec(</code>INSERT INTO visits (email, count) VALUES ('amir@example.com', 1)`)\nError: UNIQUE constraint failed: visits.email\nThat error is good: it shows that the UNIQUE constraint is working! We can use this error to our advantage with SQL's ON CONFLICT clause.</p>\n<p>We've already seen ON CONFLICT (column<em>name) DO NOTHING, which would leave our record unchanged. But there's also ON CONFLICT (column</em>name) DO UPDATE [...]. We'll tell the database \"if the insert conflicts with an existing record's email, increment that row's count instead of erroring\".</p>\n<p>Here's an isolated example of that. Look closely at the ON CONFLICT (email) DO UPDATE SET count = count + 1. It means:</p>\n<p>If our insert violates the email column's uniqueness constraint,\nUpdate that existing row by incrementing its count by 1.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE visits (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\n-- email is unique because we only want one row per person\nemail TEXT UNIQUE NOT NULL,\ncount INTEGER NOT NULL\n</code></pre>\n<p>  )\n<code>) exec(</code>\nINSERT INTO visits (email, count) VALUES ('amir@example.com', 1)\n<code>) exec(</code>\nINSERT INTO visits (email, count) VALUES ('amir@example.com', 1)\nON CONFLICT (email) DO UPDATE SET count = count + 1\n<code>) exec(</code>SELECT email, count FROM visits`)\n[{count: 2, email: 'amir@example.com'}]\nNow we can write a better version of our visit function. Instead of retrieving the row and using if to decide what to do, we'll use an ON CONFLICT. That way the database already knows what to do if the row exists!</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Write a visit function that:</p>\n<p>INSERTs a row for the given email when one doesn't exist.\nUPDATEs the row if the given email already exists.\nUses an ON CONFLICT (...) DO UPDATE ... to do both of the above at once.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE visits (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\n-- email is unique because we only want one row per person\nemail TEXT UNIQUE NOT NULL,\ncount INTEGER NOT NULL\n</code></pre>\n<p>  )\n`)</p>\n<p>function visit(email) {\nexec(\n`\nINSERT INTO visits (email, count) VALUES (?, 1)\nON CONFLICT (email) DO UPDATE SET count = count + 1</p>\n<pre><code>`,\n[email]\n</code></pre>\n<p>  )\n}\nvisit('amir@example.com')\nvisit('amir@example.com')\nexec(<code>SELECT email, count FROM visits</code>)\nGOAL:\n[{count: 2, email: 'amir@example.com'}]\nYOURS:\n[{count: 2, email: 'amir@example.com'}]\nThe new version of visit fixes the race condition bug while being simpler than the original. There's no conditional in the JavaScript, and we've replaced a trio of SELECT/INSERT/UPDATE statements with a single INSERT ... ON CONFLICT statement.</p>\n<p>The new version is also more efficient. Our original version had to retrieve the visits count from the database, then make a decision, then go back to the database again to create or update the visits row. The new version is a single statement that hits the database only once.</p>\n<p>SQL: Join performance\nIn a previous lesson, we used JOIN to list all pairs of people and their cats. We could have done that by looping in JavaScript, querying to find each person's cats. In this lesson, we'll see why we chose to write a JOIN instead of using JavaScript.</p>\n<p>(In this lesson, our database will always be set up with a people table and a cats table. The cats table has an owner_id, which is a foreign key to a person. Amir has a cat named Ms. Fluff, and Betty has a cat named Keanu. You'll see this in the setup for each example, but it's always the same, so you can skip reading it.)</p>\n<p>First, let's get every person-and-cat pair using JavaScript.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Finish the function peopleAndCats() so that it creates a list of each pair of cat and person. For every cat, call results.push({person: person.name, cat: cat.name}) to build up a list of results.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nowner_id INTEGER REFERENCES people(id) NOT NULL,\nname TEXT NOT NULL\n);</p>\n<p>  INSERT INTO people (id, name) VALUES (100, 'Amir');\nINSERT INTO cats (owner<em>id, name) VALUES (100, 'Ms. Fluff');\nINSERT INTO people (id, name) VALUES (200, 'Betty');\nINSERT INTO cats (owner</em>id, name) VALUES (200, 'Keanu');\n`)</p>\n<p>function peopleAndCats() {\nconst results = []\nconst people = exec(<code>SELECT * FROM people</code>)\nfor (const person of people) {\nconst catsOwnedByPerson = exec(<code>SELECT * FROM cats WHERE cats.owner_id = ?</code>, [person.id])\nfor (const cat of catsOwnedByPerson) {\nresults.push({person: person.name, cat: cat.name})}</p>\n<p>  }\nreturn results\n}\npeopleAndCats()\nGOAL:\n[{cat: 'Ms. Fluff', person: 'Amir'}, {cat: 'Keanu', person: 'Betty'}]\nYOURS:\n[{cat: 'Ms. Fluff', person: 'Amir'}, {cat: 'Keanu', person: 'Betty'}]\nThis is correct, in the sense that it will return the right results. But it has a big problem: its performance is terrible!</p>\n<p>What happens if we have 10,000 people? Our outer loop for (const person of people) will run 10,000 times! We'll do a total of 10,001 queries: one query to find all of the people, then a separate cat query for each of the 10,000 people.</p>\n<p>This is a very common problem when querying any kind of database, SQL or otherwise. It's called an \"N+1 problem\": we do 1 person query, then N (10,000) cat queries. That's too many queries; we can't afford to put that much load on the database for a single pageview on our site.</p>\n<p>We'll fix this in stages. First, let's reduce the number of queries. We'll get all of the people, then get all of the cats. Then we'll write a nested loop:</p>\n<p>For each person:\nFor each cat:\nIf this person is this cat's owner:\nAdd the cat to the results.\nHere's a code problem for you to complete:</p>\n<p>Add an entry to the results array for each person and cat where cat.owner_id equals person.id. (You can use results.push({person: person.name, cat: cat.name}) to add an entry to the results.) You won't need to add any more database queries.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nowner_id INTEGER REFERENCES people(id) NOT NULL,\nname TEXT NOT NULL\n);</p>\n<p>  INSERT INTO people (id, name) VALUES (100, 'Amir');\nINSERT INTO cats (owner<em>id, name) VALUES (100, 'Ms. Fluff');\nINSERT INTO people (id, name) VALUES (200, 'Betty');\nINSERT INTO cats (owner</em>id, name) VALUES (200, 'Keanu');\n`)</p>\n<p>function peopleAndCats() {\nconst results = []\nconst people = exec(<code>SELECT * FROM people</code>)\nconst cats = exec(<code>SELECT * FROM cats</code>)\nfor (const person of people) {\nfor (const cat of cats) {\nif (cat.owner_id === person.id){\nresults.push({person: person.name, cat: cat.name})}</p>\n<pre><code>}\n</code></pre>\n<p>  }\nreturn results\n}\npeopleAndCats()\nGOAL:\n[{cat: 'Ms. Fluff', person: 'Amir'}, {cat: 'Keanu', person: 'Betty'}]\nYOURS:\n[{cat: 'Ms. Fluff', person: 'Amir'}, {cat: 'Keanu', person: 'Betty'}]\nWe reduced the number of queries to 2!</p>\n<p>But this still has a performance problem. What if we have 10,000 people and 10,000 cats, but we only want to retrieve Amir and his cat Ms. Fluff? We could do it by calling our peopleAndCats function, then filtering its results. But we'll end up retrieving a total of 20,000 rows from the database even though we only need 2.</p>\n<p>Also, even though we've reduced the number of queries, we've made our JavaScript very slow. The inner loop that looks at each cat runs 10,000 times for every iteration of the outer loop. With 10,000 people and 10,000 cats, the comparison of owner_id to person.id will run a total of 100,000,000 times (10,000 * 10,000). All of that just to find out that Amir owns Ms. Fluff. This method does not work in real systems.</p>\n<p>Here's where relational databases show their usefulness. We can use a JOIN to get the same result.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Write a SELECT ... FROM ... JOIN ... ON ... query to get a list of all cats and people. Remember to select people.name AS person, cats.name AS cat to get the right column names.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nowner_id INTEGER REFERENCES people(id) NOT NULL,\nname TEXT NOT NULL\n);</p>\n<p>  INSERT INTO people (id, name) VALUES (100, 'Amir');\nINSERT INTO cats (owner<em>id, name) VALUES (100, 'Ms. Fluff');\nINSERT INTO people (id, name) VALUES (200, 'Betty');\nINSERT INTO cats (owner</em>id, name) VALUES (200, 'Keanu');\n<code>) exec(</code>\nSELECT\ncats.name AS cat, people.name AS person FROM people JOIN cats ON cats.owner_id = people.id</p>\n<p>`)\nGOAL:\n[{cat: 'Ms. Fluff', person: 'Amir'}, {cat: 'Keanu', person: 'Betty'}]\nYOURS:\n[{cat: 'Ms. Fluff', person: 'Amir'}, {cat: 'Keanu', person: 'Betty'}]\nWe got the same result in a single database query! This fixes the two performance problems we've talked about so far: it requires only one query, and it doesn't have any nested loops.</p>\n<p>What's really going on in the JOIN, though? So far, we've been thinking about JOINs as nested loops, similar to the ones that we wrote in JavaScript above. Aren't we just asking the database to do 100,000,000 (10,000 * 10,000) iterations, which will be slow?</p>\n<p>Fortunately, no! Nested loops are a perfect mental model for how JOIN works, but they're only a mental model. In reality, the database will optimize the query, rebuilding it to be more efficient while still giving the same results.</p>\n<p>Here's a concrete example. (Your answer here should be identical to the one above, with an extra WHERE added.)</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Write a JOIN query to find all cats that are owned by a person with a name of \"Amir\".</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nowner_id INTEGER REFERENCES people(id) NOT NULL,\nname TEXT NOT NULL\n);</p>\n<p>  INSERT INTO people (id, name) VALUES (100, 'Amir');\nINSERT INTO cats (owner<em>id, name) VALUES (100, 'Ms. Fluff');\nINSERT INTO people (id, name) VALUES (200, 'Betty');\nINSERT INTO cats (owner</em>id, name) VALUES (200, 'Keanu');\n<code>) exec(</code>\nSELECT people.name AS person, cats.name AS cat FROM people JOIN cats ON cats.owner_id = people.id WHERE people.name = 'Amir'</p>\n<p><code>) GOAL: [{cat: 'Ms. Fluff', person: 'Amir'}] YOURS: [{cat: 'Ms. Fluff', person: 'Amir'}] In the example above, WHERE people.name = ... tells the database that only one person matters. Then ON people.id = cats.owner_id tells it that it only needs to consider cats owned by that person. By understanding both of those limitations, the database can execute the query more intelligently. It will do something similar to exec(</code>SELECT * FROM cats WHERE owner_id = ?`, [amir.id]), selecting only the cats that are relevant.</p>\n<p>This is impressive, but it's still a simple example. The bigger the query gets, the harder it is for a human to optimize manually. But the database has no such limitation; it will happily optimize any query that we come up with.</p>\n<p>Imagine that we we're joining across 8 different tables instead of just 2. (That's not extremely common, but it does happen.)</p>\n<p>Each table has 10,000 records. With 8 nested loops, we'd require 10,000,000,000,000,000,000,000,000,000,0000 iterations (10,000 to the 8th power). That would take something like 3,170,979,198,376,458,752 years.</p>\n<p>If our database is set up properly, an 8-table join with a WHERE that matches only one row will execute in less than a millisecond. That lets us have our cake while eating it! We get to think about joins using a simple conceptual model: nested loops with an if inside. But the query actually executes in a much more intelligent way.</p>\n<p>(Full disclosure: database optimizers aren't perfect. In real databases, we give them certain kinds of manual hints that we'll learn about in later lessons. In rare cases, the optimizer does a bad job and we have to change our queries significantly to work around it. But in 99.9% of cases, the optimizer will do what you want!)</p>\n<p>SQL: Left and right joins\nIn an earlier lesson, we saw an example where users can register with discount codes. The discount codes were optional: some users register with a code, so they have a foreign key to the discount. Other users register without a code, so the foreign key is null.</p>\n<p>Suppose that we want to produce a report listing our users and what discount codes they used. The report should include all users, whether they used a discount code or not.</p>\n<p>We could write a loop in JavaScript: loop over each user, selecting any discounts for that user. That would cause an N+1 query problem: we'd query all of the users, followed by N individual queries to get each user's discount, if any. (Imagine that N is 10,000,000, to see why this is a problem: too many queries!)</p>\n<p>As usual, SQL has an answer. In this case, it's a join. However, the type of join that we've seen so far doesn't help us. If we select from users JOIN discounts ON users.id = discounts.user<em>id, we'll only get results for users who have corresponding discounts. (The users.id = discounts.user</em>id will never be true for a user who has no corresponding discount row.)</p>\n<p>That doesn't solve our problem because we want to include all users, even if they have no discount. Here's an example of that solution, even though it doesn't solve our problem:</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL,\ndiscount_id INTEGER REFERENCES discounts(id) NULL UNIQUE\n</code></pre>\n<p>  );\nCREATE TABLE discounts (id INTEGER PRIMARY KEY, discount_code TEXT NOT NULL);</p>\n<p>  -- Amir registered with a discount (both Amir and the discount get ID 1).\nINSERT INTO discounts (discount<em>code) VALUES ('free-month');\nINSERT INTO users (name, discount</em>id) VALUES ('Amir', 1);</p>\n<p>  -- Betty registered with no discount.\nINSERT INTO users (name, discount_id) VALUES ('Betty', NULL);</p>\n<p>  SELECT\nusers.name AS name,\ndiscounts.discount<em>code AS discount</em>code\nFROM users JOIN discounts\nON users.discount<em>id = discounts.id\n`)\n[{discount</em>code: 'free-month', name: 'Amir'}]\nBetty existed, but she wasn't in our query's results. To fix that, we can tell the database to include users in the report even when there's no matching discount. This is called a left join: users LEFT JOIN discounts. The \"left\" means \"include rows from the left table (users), even if there's no corresponding row from the right table (discounts).</p>\n<p>With a LEFT JOIN, both Amir and Betty will show up in the results. Amir will have his discount<em>code, but Betty's discount</em>code will be NULL (which will be represented as JavaScript's null).</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL,\ndiscount_id INTEGER REFERENCES discounts(id) NULL UNIQUE\n</code></pre>\n<p>  );\nCREATE TABLE discounts (id INTEGER PRIMARY KEY, discount_code TEXT NOT NULL);</p>\n<p>  -- Amir registered with a discount (both Amir and the discount get ID 1).\nINSERT INTO discounts (discount<em>code) VALUES ('free-month');\nINSERT INTO users (name, discount</em>id) VALUES ('Amir', 1);</p>\n<p>  -- Betty registered with no discount.\nINSERT INTO users (name, discount_id) VALUES ('Betty', NULL);</p>\n<p>  SELECT\nusers.name AS name,\ndiscounts.discount<em>code AS discount</em>code\nFROM users LEFT JOIN discounts\nON users.discount<em>id = discounts.id\n`)\n[{discount</em>code: 'free-month', name: 'Amir'}, {discount_code: null, name: 'Betty'}]\nLEFT JOIN adds one small tweak to our mental model of joins. Inner joins (the simple kind that we've seen without LEFT) still work in the same way. But here's how the database executes a left join (the new part is the \"If no discounts matched this user\" section):</p>\n<p>For each user:\nFor each discount:\nIf this user's discount_id matches this discount's id:\nReturn a row with all of the user's columns and all of the discount's columns.\nIf no discounts matched this user:\nReturn a row with all of the user's columns, and NULLs in all of the missing discount's columns.\nAs usual, this is only a mental model, but it's a correct one. In reality, the database will use a more efficient method that gives exactly the same result.</p>\n<p>You might wonder whether LEFT JOIN implies that there's also a RIGHT JOIN. There is! In a RIGHT JOIN, rows from the right table are always included, even if there's no corresponding row from the left table.</p>\n<p>Left and right joins are much less common than the basic inner joins that we've seen before, where every row must exactly match the ON. But when you need a left or right join, you'll be glad that it's available. They're useful when you want a list of records (like users) along with other corresponding records (like discounts) that may or may not exist.</p>\n<p>(As is often the case, SQLite is a bit weird here. It supports left joins, but not right joins. Fortunately, we can convert right joins into left joins by flipping the order of the tables.)</p>\n<p>Like with basic inner joins, left and right joins will produce any combination of rows that match. For example, suppose that we select from users LEFT JOIN comments ON users.id = comments.user_id.</p>\n<p>Every comment in the database will show up in the results. If Amir has written 100 comments, he'll show up 100 times: once with each of his comments. But because it's a LEFT JOIN, every user is guaranteed to show up at least once. Betty will show up even if she's never written a comment.</p>\n<p>Here's a code problem for you to complete:</p>\n<p>Use a join to get a list of usernames and comment texts for every comment in the system. Make it a left join so that it also includes users who have never written a comment. (They'll have a null comment text.) Select only the name and comment_text columns.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE comments (\nuser<em>id REFERENCES users(id) NOT NULL,\ncomment</em>text TEXT NOT NULL\n);</p>\n<p>  -- Amir has written two comments.\nINSERT INTO users (name) VALUES ('Amir');\nINSERT INTO comments (\nuser<em>id,\ncomment</em>text\n) VALUES (1, 'Ms. Fluff needs a bath!');\nINSERT INTO comments (\nuser<em>id,\ncomment</em>text\n) VALUES (1, 'Ms. Fluff strongly dislikes water.');</p>\n<p>  -- Betty has written no comments.\nINSERT INTO users (name) VALUES ('Betty');\nSELECT users.name, comments.comment<em>text FROM users LEFT JOIN comments ON users.id = comments.user</em>id</p>\n<p>`)\nGOAL:\n[{comment<em>text: 'Ms. Fluff needs a bath!', name: 'Amir'}, {comment</em>text: 'Ms. Fluff strongly dislikes water.', name: 'Amir'}, {comment_text: null, name: 'Betty'}]\nYOURS:\n[{comment<em>text: 'Ms. Fluff needs a bath!', name: 'Amir'}, {comment</em>text: 'Ms. Fluff strongly dislikes water.', name: 'Amir'}, {comment_text: null, name: 'Betty'}]\nYou'll sometimes see left and right joins called LEFT OUTER JOINs and RIGHT OUTER JOINs. Fortunately, \"outer\" doesn't change the meaning; it's just a more precise name for the same idea.</p>\n<p>In this course, we only address inner (\"simple\") joins and left joins. However, there's a surprising array of additional join types. For 99% of your practical work, inner joins will be sufficient. Left joins will probably get you through the final 1%.</p>\n<p>We don't recommend focusing on other join types until you've spent a lot of time using SQL databases on projects. However, if you'd like a taste of how deep the join rabbit hole goes, we think that this article is thorough and understandable without belaboring the point.</p>\n<p>SQL: Join mistakes\nLet's examine some subtle mistakes that we might make with SQL joins. First, what happens if we forget to add the ON condition to an inner join?</p>\n<p>With no ON, an inner join returns every combination of the left table's rows with the right table's rows. If the left table has N rows and the right table has M rows, then the join will have N*M total rows.</p>\n<p>However, we won't notice that mistake if we only test with simple cases! For example, imagine that we're joining users with their comments, but we forget the ON. If we only test with one user and one comment, then the results will look correct.</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE comments (\nuser<em>id REFERENCES users(id) NOT NULL,\ncomment</em>text TEXT NOT NULL\n);</p>\n<p>  -- Amir has written a comment.\nINSERT INTO users (name) VALUES ('Amir');\nINSERT INTO comments (\nuser<em>id,\ncomment</em>text\n) VALUES (1, 'Ms. Fluff needs a bath!');</p>\n<p>  -- \"Test\" our JOIN by querying all of the users and comments.\nSELECT\nusers.name AS name,\ncomments.comment<em>text AS comment</em>text\nFROM users JOIN comments;\n`)\n[{comment_text: 'Ms. Fluff needs a bath!', name: 'Amir'}]\nThe ON is missing, but our test doesn't notice! There's a great rule of thumb in testing that goes something like: \"If you're testing code that deals with arrays, write separate tests for 0 elements, 1 element, and many elements.\" We can imagine a similar process for testing joins. When joining tables, it's a good idea to test multiple cases, like:</p>\n<p>There are no rows at all.\nOnly the left table has rows.\nOnly the right table has rows.\nBoth tables have multiple rows.\n(Sometimes you'll want to add even more cases: \"what happens if the left table has multiple rows that match one row on the right?\" Etc. As usual, the amount of testing should match your confidence in the code.)</p>\n<p>Testing is deep and subtle, but there's a baseline rule that you should always use when writing a join: never test a join by inserting only one row into each table. That \"test\" is too loose, like the one above. Almost any join will pass it, even if it's the wrong join!</p>\n<p>That rule will catch other mistakes as well. For example, what happens if we accidentally flip the order of the tables in a LEFT JOIN?</p>\n<p>In the next example, we meant to select from users LEFT JOIN comments. However, we mixed up left and right joins, so we accidentally selected from comments LEFT JOIN users. (It's common to mix up the different join types, so this is a realistic mistake.)</p>\n<p>We only test the join with one user and one comment. It could be a LEFT JOIN, a RIGHT JOIN, an INNER JOIN, or an OUTER JOIN. They're all the same for that test case, but only one is correct!</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE comments (\nuser<em>id REFERENCES users(id) NOT NULL,\ncomment</em>text TEXT NOT NULL\n);</p>\n<p>  -- Amir has written a comment.\n-- This is a bad test case: it won't notice if we switch the tables!\nINSERT INTO users (name) VALUES ('Amir');\nINSERT INTO comments (\nuser<em>id,\ncomment</em>text\n) VALUES (1, 'Ms. Fluff needs a bath!');</p>\n<p>  -- This join contains an error: the table order is flipped.\n-- But our test can't tell!\nSELECT\nusers.name AS name,\ncomments.comment<em>text AS comment</em>text\nFROM comments LEFT JOIN users\nON users.id = comments.user<em>id\n`)\n[{comment</em>text: 'Ms. Fluff needs a bath!', name: 'Amir'}]\nOne final type of join mistake. So far, all of our examples have used foreign keys in the ON. Usually, that's a good idea. Joining on foreign keys means that we don't have to worry about cases where the join condition column has a value, but it doesn't match any value in the other table.</p>\n<p>However, the database will let us write any ON that we want. It doesn't care whether there's a foreign key or not. For example, it will let us join against the wrong table's ID.</p>\n<p>(Be careful with this example. It will successfully produce one joined row of \"user\" with comment, but the \"user\"'s name will be Ms. Fluff, not Amir!)</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nid INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n);\nCREATE TABLE comments (\nuser<em>id REFERENCES users(id) NOT NULL,\ncomment</em>text TEXT NOT NULL\n);</p>\n<p>  -- Ms. Fluff is a cat (with ID 1).\nINSERT INTO cats (name) VALUES ('Ms. Fluff');</p>\n<p>  -- Amir (user ID 1) has written a comment.\nINSERT INTO users (name) VALUES ('Amir');\nINSERT INTO comments (\nuser<em>id,\ncomment</em>text\n) VALUES (1, 'Ms. Fluff needs a bath!');</p>\n<p>  -- Select all of the comments joined with \"users\".\n-- But we accidentally join against cats' IDs instead of users' IDs.\n-- The database won't stop us!\n-- It will happily match up comments' \"user<em>id\"s with cats' \"id\"s.\nSELECT\nname,\ncomment</em>text\nFROM cats JOIN comments\nON id = comments.user<em>id;\n`)\n[{comment</em>text: 'Ms. Fluff needs a bath!', name: 'Ms. Fluff'}]\nWe can tell that this is wrong because no cat who has ever existed would say that they need a bath!</p>\n<p>Like our previous examples, more thorough testing will highlight this kind of mistake.</p>\n<p>There's another method to spot it as well. In past lessons, we've recommended listing the columns in a SELECT on separate lines, like we did in this example. For joins, we've also recommended explicitly naming those columns' tables, like SELECT users.name. However, we intentionally didn't follow that advice above: we selected only the names of the columns without specifying which tables they came from.</p>\n<p>Qualifying the column names with their tables makes it easier to spot this kind of mistake. In order for this mistake to happen, we'd have to write SELECT cats.name. Just seeing the table name a second time gives us a chance to notice the mistake.</p>\n<p>Hopefully, we type the correct table name the second time: users.name. If we do that while selecting from a join that doesn't include users, we'll get an error. (You can type \"error\" to indicate an error.\")</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE users (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nid INTEGER PRIMARY KEY,\nname TEXT NOT NULL\n);\nCREATE TABLE comments (\nuser<em>id REFERENCES users(id) NOT NULL,\ncomment</em>text TEXT NOT NULL\n);</p>\n<p>  -- Ms. Fluff is a cat (with ID 1).\nINSERT INTO cats (name) VALUES ('Ms. Fluff');</p>\n<p>  -- Amir (user ID 1) has written a comment.\nINSERT INTO users (name) VALUES ('Amir');\nINSERT INTO comments (\nuser<em>id,\ncomment</em>text\n) VALUES (1, 'Ms. Fluff needs a bath!');</p>\n<p>  -- Select all of the comments joined with \"users\".\n-- But we accidentally join against cats' IDs instead of users' IDs.\n-- The database won't stop us!\n-- It will happily match up comments' \"user<em>id\"s with cats' \"id\"s.\n--\n-- Naming the tables explicitly gives us a second chance to notice.\nSELECT\nusers.name,\ncomments.comment</em>text\nFROM cats JOIN comments\nON id = comments.user_id;\n`)\nError: no such column: users.name\nSQL is quite good at preventing mistakes. That's what all of its constraint types are for. However, it can't save us from every mistake. Hopefully this lesson helps you to catch some mistakes earlier. We can reduce the advice here into two minimal rules:</p>\n<p>When testing a join, use more than one row in each table.\nWhen selecting from a join, qualify your selects with table names (like SELECT users.name) to make sure that you're selecting the right things.</p>\n<p>SQL: ON vs WHERE\nFor this lesson, our goal is: find the pairs of cats and owners where the person's name is the same as the cat's name.</p>\n<p>(All of the examples in this lesson will use this database, but it will always be empty at the beginning of each example.)</p>\n<blockquote>\n<p>exec(`\nCREATE TABLE people (</p>\n</blockquote>\n<pre><code>id INTEGER PRIMARY KEY NOT NULL,\nname TEXT NOT NULL\n</code></pre>\n<p>  );\nCREATE TABLE cats (\nid INTEGER PRIMARY KEY NOT NULL,\nowner_id INTEGER NOT NULL REFERENCES people(id),\nname TEXT NOT NULL\n);</p>\n<p>  -- Wilford has a cat named Wilford.\nINSERT INTO people (id, name) VALUES (300, 'Wilford');\nINSERT INTO cats (owner_id, name) VALUES (300, 'Wilford');</p>\n<p>  -- Cindy has no cats.\nINSERT INTO people (id, name) VALUES (200, 'Cindy');\n`)\n[]\nFirst, we'll do the query in a straightforward way, using both an ON and a WHERE. We use the ON to match people and cats using the owner_id foreign key. We use the WHERE to select only the person-cat pairs where the owner's name is the same as the cat's name. (Note the AS column aliases.)</p>\n<blockquote>\n<p>exec(`\nSELECT</p>\n</blockquote>\n<pre><code>people.name AS person_name,\ncats.name AS cat_name\n</code></pre>\n<p>  FROM people\nINNER JOIN cats\nON people.id = cats.owner<em>id\nWHERE people.name = cats.name\n`)\n[{cat</em>name: 'Wilford', person_name: 'Wilford'}]\nIf we like, we can move the people.name = cats.name check into the ON, eliminating the WHERE.</p>\n<blockquote>\n<p>exec(`\nSELECT</p>\n</blockquote>\n<pre><code>people.name AS person_name,\ncats.name AS cat_name\n</code></pre>\n<p>  FROM people\nINNER JOIN cats\nON people.id = cats.owner<em>id\nAND people.name = cats.name\n`)\n[{cat</em>name: 'Wilford', person_name: 'Wilford'}]\nThe cat's name isn't a foreign key to the person's name, but that's OK; we can still compare those columns in the ON. Databases don't limit what we put in an ON, just like they don't limit what we put in a WHERE. If the columns exist, the database will let us join on them.</p>\n<p>We can also convert the entire ON into a WHERE.</p>\n<blockquote>\n<p>exec(`\nSELECT</p>\n</blockquote>\n<pre><code>people.name AS person_name,\ncats.name AS cat_name\n</code></pre>\n<p>  FROM people\nINNER JOIN cats\nWHERE people.id = cats.owner<em>id\nAND people.name = cats.name\n`)\n[{cat</em>name: 'Wilford', person_name: 'Wilford'}]\nConceptually, this version is computing every combination of person and cat, then filtering that giant list:</p>\n<p>For each person:\nFor each cat:\nProduce a new temporary row that contains this person's columns with this cat's columns.\nFor each of those combinations of every person with every cat:\nIf the cat's owner_id matches the person's id:\nAnd the cat's name matches the person's name:\nInclude this combination of person and cat in the final results.\nAs always, the mental model above is correct, but the database will intelligently optimize the query to make it faster. (If we have 10,000 people and 10,000 cats, the database will NOT produce a temporary list of 100,000,000 rows.)</p>\n<p>All three of the queries above are truly equivalent: an ON mixed with a WHERE; an ON only; and a WHERE only. So why bother with ON at all? Why not always use WHERE? Let's analyze that question along three dimensions: performance, correctness, and clarity for human readers.</p>\n<p>First: performance. Modern databases are very good at optimizing ON and WHERE. You're unlikely to encounter a performance problem that's fixed by converting an ON to a WHERE or vice-versa. So performance isn't a reason to choose one or the other.</p>\n<p>Second: correctness. For inner joins (the common type of \"simple\" joins that we're using here), ON and WHERE are interchangeable. Your query will never be wrong if you convert one to the other. However, ON and WHERE are NOT interchangeable for any other type of join. In LEFT, RIGHT, and other more rare types that we don't cover in this course, like OUTER, converting an ON to a WHERE can change the results.</p>\n<p>Third: clarity for human readers. An ON should specify which rows from the left table go with which rows from the right table. Here are some examples of good ONs. They concern the relationship between the two tables being joined.</p>\n<p>Matching the left table's foreign key against the column that it references in the right table.\nMatching email addresses in an invitations_sent table against email addresses in our users table to find out what percentage of invited users eventually register (assuming that there's no proper foreign key between the tables).\nHere are some examples of conditions that are better in a WHERE than an ON. They're not about the two tables' relationships.</p>\n<p>Selecting a range of rows (like WHERE created<em>at > /* some date here */).\nSelecting a specific row (like WHERE user</em>id = ? or WHERE cats.name = 'Ms. Fluff').\nSeparating ON conditions from WHERE conditions helps with both correctness and clarity. It makes mistakes with rare types of joins less likely, where converting an ON to a WHERE will give different results. It also gives readers a hint about whether the condition concerns combinations of left and right rows.</p>\n<p>There's no hard-and-fast rule about when to use ON vs. WHERE. The example that we started with lives in a gray area where either choice makes sense. Putting the people.name = cats.name condition in the ON is probably slightly better, but neither is \"wrong\".</p>\n<p>You'll do fine as long as you ask yourself \"is this condition about how the left table relates to the right table, or is it about something else?\"</p>\n<p>Finish Lesson\nBrag…</p>","frontmatter":{"title":"SQL"},"excerpt":"Photo from wallpapersafari.com SQL stands for Structured Query Language. SQL is used to communicate with a database.  SQL manages data well…"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/SQL/"}}}