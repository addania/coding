{"componentChunkName":"component---src-templates-blog-post-js","path":"/JS_regular_Expressions/","webpackCompilationHash":"2111e30fbd88cd5a2593","result":{"data":{"markdownRemark":{"html":"<p><img src=\"https://i.imgur.com/ETtwNWY.jpg\" title=\"Photo from wallpapersafari.com\"><p style=\"font-size: 12px; text-align: right\"><em>Photo from wallpapersafari.com</em></p></p>\n<blockquote>\n<p>Regular expressions (regexes) are patterns that describe strings. We might write a regex for filenames ending in \".jpg\". Or we might write one that recognizes phone numbers.</p>\n</blockquote>\n<blockquote>\n<p>test if a is contained in a string</p>\n</blockquote>\n<pre><code>/a/.test('a')\ntrue\n/a/.test('b')\nfalse\n/a/.test('cat')\ntrue\n/A/.test('a')\nfalse\n/cat/.test('cart')\nfalse\n/a cat/.test('that is a cat')\ntrue\n</code></pre>\n<blockquote>\n<p>We can also define the regular expression and then test if give string maches</p>\n</blockquote>\n<pre><code>var re = /at/\nre.test('bat')\ntrue\n</code></pre>\n<blockquote>\n<p>Regexes like /a/ are literal: they specify exact characters to match. The real power in regexes is in the various operators. The most basic is ., the wildcard operator. It matches any character. But the character must be present; . won't match the empty string.</p>\n</blockquote>\n<pre><code>/./.test('a')\ntrue\n/./.test('b')\ntrue\n/./.test('')\nfalse\n/a./.test('ah')\ntrue\n/a./.test('ha')\nfalse\n/x.z/.test('xyyz')\nfalse\n/x..z/.test('xaaz')\ntrue\n</code></pre>\n<blockquote>\n<p>There is only one exception, it does not match new line characters:</p>\n</blockquote>\n<pre><code>/./.test('\\n')\nfalse\n</code></pre>\n<blockquote>\n<p>Sometimes we need to allow multiple alternatives. We can separate them with a pipe character, |, pronounced \"or\".</p>\n</blockquote>\n<pre><code>/a|b/.test('a')\ntrue\n/a|b/.test('b')\ntrue \n/a|b/.test('c')\nfalse\n/at|og/.test('cat')\ntrue\n/at|og/.test('dog')\ntrue\n</code></pre>\n<pre><code>var re = /cat|dog|horse/\nre.test('catzor')\ntrue\n</code></pre>\n<blockquote>\n<p>Boundaries match beginning or end of a string. ^ matches beginning, $ matches end.</p>\n</blockquote>\n<pre><code>/^cat/.test('cat')\ntrue\n/^cat/.test('cats are cute')\ntrue\n/^cat/.test('I like cats')\nfalse\n\n/cat$/.test('a cat')\ntrue\n/cat$/.test('cats')\nfalse\n\n/^a$/.test('a')\ntrue\n/^a$/.test('ab')\nfalse\n</code></pre>\n<blockquote>\n<p>To match empty string we use:</p>\n</blockquote>\n<pre><code>/^$/.test('')\ntrue\n/^$/.test(' ')\nfalse\n</code></pre>\n<blockquote>\n<p>Hex codes - Computers internally store text as numbers. As a shorthand, we usually write those numbers out as hexadecimal codes. For example A is in hexcode \\x41, B is \\x42 and M is \\x4d</p>\n</blockquote>\n<pre><code>/\\x41/.test('A') // \"A\" is x41\ntrue\n/\\x41/.test('CATS ARE GOOD')\ntrue\n/\\x4d/.test('M')\ntrue\n</code></pre>\n<blockquote>\n<p> \"?\" is x3f and \"!\" is x21</p>\n</blockquote>\n<blockquote>\n<p>hex codes in regex must be typed with \\x and then 2 digits</p>\n</blockquote>\n<blockquote>\n<p>Multiplication: The + operator requires something to occur one or more times.</p>\n</blockquote>\n<pre><code>/a+/.test('aaa')\ntrue\n/a+/.test('a')\ntrue\n/ca+t/.test('caaat')\ntrue \n/ca+t/.test('ct')\nfalse\n</code></pre>\n<ul>\n<li>\n<p>works with . .+ means any character at least once:</p>\n<pre><code></code></pre>\n</li>\n</ul>\n<p>/.+/.test('a')\ntrue </p>\n<p>/.+/.test('cat')\ntrue </p>\n<p>/.+/.test('')\nfalse</p>\n<p>/a.+z/.test('aveloz')\ntrue</p>\n<p>/a.+z/.test('az')\nfalse </p>\n<pre><code>>The * operator is similar to +, but means \"zero or more times\".\n</code></pre>\n<p>/a*/.test('a')\ntrue</p>\n<p>/a<em>/.test('')\ntrue\n/a</em>/.test('aa')\ntrue </p>\n<pre><code>> Some more complex examples:\n</code></pre>\n<p>/a+b<em>c+/.test('aacc')\ntrue\n/a+b</em>c+/.test('aa')\nfalse</p>\n<p>/a+b<em>c+/.test('aabccc')\ntrue\n/a+b</em>c+/.test('abbbbc')\ntrue</p>\n<p>/a+b*c+/.test('bc')\nfalse</p>\n<pre><code>>Write a regex that reckognized words which start and end with t\n</code></pre>\n<p>var re = /^t.*t$/</p>\n<pre><code>Parens\n\n> will this be true or false?\n</code></pre>\n<pre><code>>Actually true\n\n>Why? Because it says either it starts with a OR ends with b!!\n\n>We can use brackets to enforce certain logic:\n</code></pre>\n<p>/^a|b$/.test('ax')</p>\n<pre><code>is same as\n</code></pre>\n<p>/(^a)|(b$)/.test('ax')</p>\n<pre><code>>We can change it to:\n</code></pre>\n<p>(a|b)$/.test('ax')\nfalse</p>\n<pre><code>>Brackets can also shorten the code:\n</code></pre>\n<p>/^(jpg|p(ng|df))$/.test('jpg')\ntrue </p>\n<pre><code>> How to make sure our code also takes into consideration jpeg??\n</code></pre>\n<p>/^(jpe*g)|p(ng|df))$/.test('jpg')</p>\n<pre><code></code></pre>\n<p>/^(a|b)+$/.test('bababa')\ntrue </p>\n<pre><code>> We can say a or empty like this:\n</code></pre>\n<p>^(a|)$/.test('')\ntrue</p>\n<p>/^(a|)$/.test('a')\ntrue</p>\n<pre><code>> We can excape characters with \\\n</code></pre>\n<p>/./.test('That is a cat.')\ntrue</p>\n<p>/.+./.test('111')\nfalse </p>\n<p>/.+./.test('1+1')\ntrue </p>\n<pre><code>Character classes:\n\n> \\d means a digit\n\n> \\s means a white space\n\n> \\t is a tab\n\n> \\D any character that is NOT a digit\n</code></pre>\n<p>/\\s/.test(' ')\ntrue</p>\n<p>/\\s/.test('\\n')\ntrue</p>\n<p>/\\s/.test('')\nfalse</p>\n<p>/\\d/.test('0')\ntrue</p>\n<p>/\\D/.test('0')\nfalse </p>\n<p>/\\S/.test(' ')\nfalse </p>\n<p>/\\S/.test('0')\ntrue</p>\n<pre><code>> If we need only lets say 3 characters, we can write (a|o|u) or alternatively [aou] -which is a character set\n</code></pre>\n<p>/^c(a|o|u)t$/.test('cat')\ntrue\n/^c[aou]t$/.test('cat')\ntrue </p>\n<p>/^c[aou]t$/.test('cot')\ntrue</p>\n<pre><code>>What if we want to allow any string of lower case letters? We'd have to write /(a|b|c|d|e| and so on. Instead, we can write another character set.\n</code></pre>\n<blockquote>\n<p>/[abcdefghijklmnopqrstuvwxyz]/.test('a')\ntrue </p>\n<p>/[abcdefghijklmnopqrstuvwxyz]/.test('g')\ntrue </p>\n</blockquote>\n<pre><code>>That was shorter, but still wordy. We can specify an entire range of characters by using -.\n</code></pre>\n<p>/[a-z]/.test('g')\ntrue </p>\n<blockquote>\n<p>/[1-3]/.test('1')\ntrue </p>\n<p>/[1-3]/.test('a')\nfalse </p>\n<p>/[1-3]/.test('2')\ntrue</p>\n</blockquote>\n<pre><code>>As usual, we escape special characters when we want them to be literal. This range contains only one character, an escaped ] written as \\].\n</code></pre>\n<p>/[]]/.test(']')\ntrue </p>\n<pre><code>> Character sets can be negated to mean \"everything not in the set\".We negate with ^, a character that we already saw. Normally it means \"beginning of line\". But inside [square brackets], it means \"negate the character set\". (There are only so many symbols on a keyboard, so some get reused.)\n</code></pre>\n<p>/<sup id=\"fnref-a\"><a href=\"#fn-a\" class=\"footnote-ref\">a</a></sup>/.test('a')\nfalse </p>\n<blockquote>\n<p>/<sup id=\"fnref-a\"><a href=\"#fn-a\" class=\"footnote-ref\">a</a></sup>/.test('5')\ntrue </p>\n</blockquote>\n<pre><code>>Negation also applies to ranges.\n</code></pre>\n<p>/[a-z]/.test('h')\ntrue </p>\n<blockquote>\n<p>/<sup id=\"fnref-a-z\"><a href=\"#fn-a-z\" class=\"footnote-ref\">a-z</a></sup>/.test('h')\nfalse </p>\n</blockquote>\n<pre><code>>Character sets match exactly one character in the string. (This is like character classes, which also match only one character.) To match more than one character, we can use + or *.\n</code></pre>\n<p>^[a-z]$/.test('cat')\nfalse </p>\n<blockquote>\n<p>/^[a-z]+$/.test('cat')\ntrue </p>\n</blockquote>\n<pre><code>>Maybe\nThe ? operator matches a character zero or one times, but not more than one.\n</code></pre>\n<p>/^a?$/.test('a')\ntrue </p>\n<blockquote>\n<p>/^a?$/.test('')\ntrue </p>\n<p>/^a?$/.test('b')\nfalse </p>\n<p>/^a?$/.test('aa')\nfalse</p>\n</blockquote>\n<pre><code>>The ? operator affects whatever is immediately before it. For example, in ab?, the ? operators only affects \"b\", not \"a\". We say that it binds tightly.\n</code></pre>\n<p>/^ab?$/.test('a')\ntrue </p>\n<blockquote>\n<p>/^ab?$/.test('b')\nfalse </p>\n<p>/^ab?$/.test('ab')\ntrue </p>\n</blockquote>\n<pre><code>>To make ? include more characters, we can group them using parens. Then we apply the ? to the whole group.\n</code></pre>\n<p>/^(555-)?555-5555$/.test('555-555-5555')\ntrue </p>\n<blockquote>\n<p>/^(555-)?555-5555$/.test('555-5555')\ntrue </p>\n</blockquote>\n<pre><code>>to match \"letters, numbers, and underscores.\" we can use the character class \\w. The \"w\" in \\w stands for \"word\", which is another name for an identifier. This can be tricky: \"word\" has a special meaning in programming! \\W negates it\n</code></pre>\n<p>/\\w/.test('a')\ntrue </p>\n<blockquote>\n<p>/\\w/.test('+')\nfalse </p>\n<p>/\\w/.test('F')\ntrue </p>\n<p>/\\w/.test('_')\ntrue </p>\n<p>/a\\wc/.test('abc')\ntrue </p>\n<p>/a\\wc/.test('a-c')\nfalse </p>\n<p>/^\\w$/.test('aaa')\nfalse </p>\n</blockquote>\n<pre><code>Character sets\nIn a character set, characters and ranges can be mixed in any order. This regex is equivalent to /[g]|[c-e]|[a]/.\n\n> \n/[gc-ea]/.test('a')\ntrue \n> \n/[gc-ea]/.test('b')\nfalse \n> \n/[gc-ea]/.test('c')\ntrue \n> \n/[gc-ea]/.test('d')\ntrue \n> \n/[gc-ea]/.test('h')\nfalse \nWe can also negate the whole character set, even if it's complex.\n\n> \n/[^gc-ea]/.test('a')\nfalse \n> \n/[^gc-ea]/.test('d')\nfalse \n> \n/[^gc-ea]/.test('b')\ntrue \nIf a character set ever gives you trouble, you can always break it up. For example, /[hbd-fa]/ can be thought of as /(h|b|[d-f]|a)/. This trick works for anything in regexes. Most regex features are syntactic sugar for simple features like |.\n\nSpecial characters aren't special inside a character set. For example, \".\" means a literal \".\" and \"$\" is a literal \"$\".\n</code></pre>\n<p>/[a$]/.test('$')\ntrue </p>\n<blockquote>\n<p>/[a$]/.test('a')\ntrue </p>\n<p>/[a$]/.test('^')\nfalse </p>\n<p>/^[a$]$/.test('ab')\nfalse </p>\n</blockquote>\n<pre><code>The ^ is only special if it's the first character in the set. There, it means \"negate this set\". But a ^ anywhere else in the set is just another literal character.\n</code></pre>\n<p>/<sup id=\"fnref-b\"><a href=\"#fn-b\" class=\"footnote-ref\">b</a></sup>/.test('b')\nfalse </p>\n<blockquote>\n<p>/[b^]/.test('b')\ntrue </p>\n<p>/[b^]/.test('^')\ntrue </p>\n<p>/<sup id=\"fnref-^\"><a href=\"#fn-^\" class=\"footnote-ref\">^</a></sup>/.test('b')\ntrue </p>\n<p>/<sup id=\"fnref-^\"><a href=\"#fn-^\" class=\"footnote-ref\">^</a></sup>/.test('^')\nfalse </p>\n</blockquote>\n<pre><code>Regular Expressions: Constrained repetition\nSometimes we need text to be of a certain length. We could repeat . to enforce length.\n\n> \n/^.....$/.test('1234')\nfalse \n> \n/^.....$/.test('12345')\ntrue \n> \n/^.....$/.test('123456')\nfalse \nThis is awkward, especially if we want to match exactly, say, 20 characters. Fortunately, there's a better way: {curly braces}.\n\n> \n/^.{5}$/.test('1234')\nfalse \n> \n/^.{5}$/.test('12345')\ntrue \n> \n/^.{5}$/.test('123456')\nfalse \nWe can repeat anything in this way, not just .\n\n> \n/^(a|b){3}$/.test('aaa')\ntrue \n> \n/^(a|b){3}$/.test('bba')\ntrue \n> \n/^(a|b){3}$/.test('ab')\nfalse \nBy adding a comma, we can specify a range of allowed lengths.\n\n> \n/^.{2,3}$/.test('1')\nfalse \n> \n/^.{2,3}$/.test('12')\ntrue \n> \n/^.{2,3}$/.test('123')\ntrue \n> \n/^.{2,3}$/.test('1234')\nfalse \nWe can also specify \"n or more characters\" by omitting the second number. For example, .{8,} means \"at least eight characters\".\n\n> \n/^[fho]{3,}$/.test('of')\nfalse \n> \n/^[fho]{3,}$/.test('off')\ntrue \n> \n/^[fho]{3,}$/.test('hoof')\ntrue \nIn some regex systems, .{,5} means \"at most five characters\". Unfortunately, that's not true in JavaScript's regexes. JavaScript won't tell us about our mistake either. Instead, the {,5} gets interpreted as a literal string!\n\n> \n/^.{,5}$/.test('12345')\nfalse \n> \n/^.{,5}$/.test('.{,5}')\ntrue \nThis is bizarre, but not a big problem. If we need five or fewer characters, we can say .{0,5}.\n\n> \n/^.{0,5}$/.test('1234')\ntrue \n> \n/^.{0,5}$/.test('12345')\ntrue \n> \n/^.{0,5}$/.test('123456')\nfalse \n\nRegular Expressions: Word boundaries\nWhen using a regular expression to search for a word, we usually don't want to match those letters inside another word.\n\n> \n/cat/.test(\"I couldn't locate Mr. Meow.\")\ntrue \nThe word 'locate' contains 'cat', so this sentence matches.\n\nThat's not what we want! We'd like to match the word 'cat'. Regexes provide a way to do this using the word boundary \\b:\n\n> \n/\\bcat\\b/.test('It was difficult to locate, but')\nfalse \n> \n/\\bcat\\b/.test('the cat returned.')\ntrue \n\\b only matches where a word character is next to a non-word character. (Remember that word-characters are letters, numbers and underscores.)\n\n> \n/\\bcat\\b/.test('cat-like reflexes')\ntrue \n> \n/\\bcat\\b/.test(\"var cat_name = 'Mr. Meow';\")\nfalse \n> \n/\\bcat\\b/.test(\"Where's the cat's toy?\")\ntrue \nLike most character classes, \\b can be negated by capitalizing it. \\B only matches between two word characters. It's pronounced \"non-word-boundary\".\n\n> \n/\\Bcat\\B/.test('The cat over there')\nfalse \n> \n/\\Bcat\\B/.test('concatenate')\ntrue \n\\B can be used to find out if a word has 'cat' in particular places, which could help win scrabble games.\n\nIf you'd like to find words that contain \"cat\", but don't end with \"cat\":\n\n> \n/cat\\B/.test('publication')\ntrue \n> \n/cat\\B/.test('wildcat')\nfalse \n> \n/cat\\B/.test('catenary')\ntrue \nOr words that contain \"cat\" only in the middle:\n\n> \n/\\Bcat\\B/.test('cathode')\nfalse \n> \n/\\Bcat\\B/.test('muscat')\nfalse \n> \n/\\Bcat\\B/.test('hecatomb')\ntrue \n\nRegular Expressions: Character classes in sets\nSuppose that we're writing a regex to process Lisp code. Unlike most languages, Lisp allows the \"-\" character in identifiers. We can use a character set including everything in \\w as well as -.\n\n> \n/^[\\w-]+$/.test('a_function')\ntrue \n> \n/^[\\w-]+$/.test('a-function')\ntrue \n> \n/^[\\w-]+$/.test('a-function()')\nfalse \n</code></pre>\n<pre><code></code></pre>","frontmatter":{"title":"Javascript Regular expressions"},"excerpt":"Photo from wallpapersafari.com Regular expressions (regexes) are patterns that describe strings. We might write a regex for filenames ending…"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/JS_regular_Expressions/"}}}